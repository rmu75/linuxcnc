// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCERROR_EMC_H_
#define FLATBUFFERS_GENERATED_EMCERROR_EMC_H_

#include "flatbuffers/flatbuffers.h"

#include "emc_common_generated.h"

namespace EMC {

struct OperatorError;
struct OperatorErrorBuilder;
struct OperatorErrorT;

struct OperatorText;
struct OperatorTextBuilder;
struct OperatorTextT;

struct OperatorDisplay;
struct OperatorDisplayBuilder;
struct OperatorDisplayT;

struct ErrorChannelMsg;
struct ErrorChannelMsgBuilder;
struct ErrorChannelMsgT;

enum Message {
  Message_NONE = 0,
  Message_operator_error = 1,
  Message_operator_text = 2,
  Message_operator_display = 3,
  Message_MIN = Message_NONE,
  Message_MAX = Message_operator_display
};

inline const Message (&EnumValuesMessage())[4] {
  static const Message values[] = {
    Message_NONE,
    Message_operator_error,
    Message_operator_text,
    Message_operator_display
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[5] = {
    "NONE",
    "operator_error",
    "operator_text",
    "operator_display",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (flatbuffers::IsOutRange(e, Message_NONE, Message_operator_display)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<EMC::OperatorError> {
  static const Message enum_value = Message_operator_error;
};

template<> struct MessageTraits<EMC::OperatorText> {
  static const Message enum_value = Message_operator_text;
};

template<> struct MessageTraits<EMC::OperatorDisplay> {
  static const Message enum_value = Message_operator_display;
};

struct MessageUnion {
  Message type;
  void *value;

  MessageUnion() : type(Message_NONE), value(nullptr) {}
  MessageUnion(MessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Message_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageUnion(const MessageUnion &);
  MessageUnion &operator=(const MessageUnion &u)
    { MessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageUnion &operator=(MessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageTraits<typename RT::TableType>::enum_value;
    if (type != Message_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  EMC::OperatorErrorT *Asoperator_error() {
    return type == Message_operator_error ?
      reinterpret_cast<EMC::OperatorErrorT *>(value) : nullptr;
  }
  const EMC::OperatorErrorT *Asoperator_error() const {
    return type == Message_operator_error ?
      reinterpret_cast<const EMC::OperatorErrorT *>(value) : nullptr;
  }
  EMC::OperatorTextT *Asoperator_text() {
    return type == Message_operator_text ?
      reinterpret_cast<EMC::OperatorTextT *>(value) : nullptr;
  }
  const EMC::OperatorTextT *Asoperator_text() const {
    return type == Message_operator_text ?
      reinterpret_cast<const EMC::OperatorTextT *>(value) : nullptr;
  }
  EMC::OperatorDisplayT *Asoperator_display() {
    return type == Message_operator_display ?
      reinterpret_cast<EMC::OperatorDisplayT *>(value) : nullptr;
  }
  const EMC::OperatorDisplayT *Asoperator_display() const {
    return type == Message_operator_display ?
      reinterpret_cast<const EMC::OperatorDisplayT *>(value) : nullptr;
  }
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct OperatorErrorT : public flatbuffers::NativeTable {
  typedef OperatorError TableType;
  std::string error;
  OperatorErrorT() {
  }
};

struct OperatorError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorErrorT NativeTableType;
  typedef OperatorErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
  OperatorErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorErrorBuilder {
  typedef OperatorError Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(OperatorError::VT_ERROR, error);
  }
  explicit OperatorErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorError>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorError> CreateOperatorError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  OperatorErrorBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorError> CreateOperatorErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return EMC::CreateOperatorError(
      _fbb,
      error__);
}

flatbuffers::Offset<OperatorError> CreateOperatorError(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorTextT : public flatbuffers::NativeTable {
  typedef OperatorText TableType;
  std::string text;
  OperatorTextT() {
  }
};

struct OperatorText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorTextT NativeTableType;
  typedef OperatorTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  OperatorTextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorTextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorText> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorTextBuilder {
  typedef OperatorText Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(OperatorText::VT_TEXT, text);
  }
  explicit OperatorTextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorText>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorText> CreateOperatorText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  OperatorTextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorText> CreateOperatorTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return EMC::CreateOperatorText(
      _fbb,
      text__);
}

flatbuffers::Offset<OperatorText> CreateOperatorText(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorDisplayT : public flatbuffers::NativeTable {
  typedef OperatorDisplay TableType;
  std::string display;
  OperatorDisplayT() {
  }
};

struct OperatorDisplay FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorDisplayT NativeTableType;
  typedef OperatorDisplayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISPLAY = 4
  };
  const flatbuffers::String *display() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISPLAY) &&
           verifier.VerifyString(display()) &&
           verifier.EndTable();
  }
  OperatorDisplayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorDisplayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorDisplay> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorDisplayBuilder {
  typedef OperatorDisplay Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_display(flatbuffers::Offset<flatbuffers::String> display) {
    fbb_.AddOffset(OperatorDisplay::VT_DISPLAY, display);
  }
  explicit OperatorDisplayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorDisplay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorDisplay>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> display = 0) {
  OperatorDisplayBuilder builder_(_fbb);
  builder_.add_display(display);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *display = nullptr) {
  auto display__ = display ? _fbb.CreateString(display) : 0;
  return EMC::CreateOperatorDisplay(
      _fbb,
      display__);
}

flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorChannelMsgT : public flatbuffers::NativeTable {
  typedef ErrorChannelMsg TableType;
  EMC::MessageUnion message;
  ErrorChannelMsgT() {
  }
};

struct ErrorChannelMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorChannelMsgT NativeTableType;
  typedef ErrorChannelMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  EMC::Message message_type() const {
    return static_cast<EMC::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const EMC::OperatorError *message_as_operator_error() const {
    return message_type() == EMC::Message_operator_error ? static_cast<const EMC::OperatorError *>(message()) : nullptr;
  }
  const EMC::OperatorText *message_as_operator_text() const {
    return message_type() == EMC::Message_operator_text ? static_cast<const EMC::OperatorText *>(message()) : nullptr;
  }
  const EMC::OperatorDisplay *message_as_operator_display() const {
    return message_type() == EMC::Message_operator_display ? static_cast<const EMC::OperatorDisplay *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  ErrorChannelMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ErrorChannelMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const EMC::OperatorError *ErrorChannelMsg::message_as<EMC::OperatorError>() const {
  return message_as_operator_error();
}

template<> inline const EMC::OperatorText *ErrorChannelMsg::message_as<EMC::OperatorText>() const {
  return message_as_operator_text();
}

template<> inline const EMC::OperatorDisplay *ErrorChannelMsg::message_as<EMC::OperatorDisplay>() const {
  return message_as_operator_display();
}

struct ErrorChannelMsgBuilder {
  typedef ErrorChannelMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(EMC::Message message_type) {
    fbb_.AddElement<uint8_t>(ErrorChannelMsg::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(ErrorChannelMsg::VT_MESSAGE, message);
  }
  explicit ErrorChannelMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ErrorChannelMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ErrorChannelMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<ErrorChannelMsg> CreateErrorChannelMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    EMC::Message message_type = EMC::Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  ErrorChannelMsgBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<ErrorChannelMsg> CreateErrorChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const ErrorChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline OperatorErrorT *OperatorError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorErrorT> _o = std::unique_ptr<EMC::OperatorErrorT>(new OperatorErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorError::UnPackTo(OperatorErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
}

inline flatbuffers::Offset<OperatorError> OperatorError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorError> CreateOperatorError(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  return EMC::CreateOperatorError(
      _fbb,
      _error);
}

inline OperatorTextT *OperatorText::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorTextT> _o = std::unique_ptr<EMC::OperatorTextT>(new OperatorTextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorText::UnPackTo(OperatorTextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline flatbuffers::Offset<OperatorText> OperatorText::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorText(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorText> CreateOperatorText(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorTextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  return EMC::CreateOperatorText(
      _fbb,
      _text);
}

inline OperatorDisplayT *OperatorDisplay::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorDisplayT> _o = std::unique_ptr<EMC::OperatorDisplayT>(new OperatorDisplayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorDisplay::UnPackTo(OperatorDisplayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = display(); if (_e) _o->display = _e->str(); }
}

inline flatbuffers::Offset<OperatorDisplay> OperatorDisplay::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorDisplay(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorDisplayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _display = _o->display.empty() ? 0 : _fbb.CreateString(_o->display);
  return EMC::CreateOperatorDisplay(
      _fbb,
      _display);
}

inline ErrorChannelMsgT *ErrorChannelMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::ErrorChannelMsgT> _o = std::unique_ptr<EMC::ErrorChannelMsgT>(new ErrorChannelMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ErrorChannelMsg::UnPackTo(ErrorChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; }
  { auto _e = message(); if (_e) _o->message.value = EMC::MessageUnion::UnPack(_e, message_type(), _resolver); }
}

inline flatbuffers::Offset<ErrorChannelMsg> ErrorChannelMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateErrorChannelMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ErrorChannelMsg> CreateErrorChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const ErrorChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorChannelMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return EMC::CreateErrorChannelMsg(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_operator_error: {
      auto ptr = reinterpret_cast<const EMC::OperatorError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_operator_text: {
      auto ptr = reinterpret_cast<const EMC::OperatorText *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_operator_display: {
      auto ptr = reinterpret_cast<const EMC::OperatorDisplay *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageUnion::UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Message_operator_error: {
      auto ptr = reinterpret_cast<const EMC::OperatorError *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_operator_text: {
      auto ptr = reinterpret_cast<const EMC::OperatorText *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_operator_display: {
      auto ptr = reinterpret_cast<const EMC::OperatorDisplay *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Message_operator_error: {
      auto ptr = reinterpret_cast<const EMC::OperatorErrorT *>(value);
      return CreateOperatorError(_fbb, ptr, _rehasher).Union();
    }
    case Message_operator_text: {
      auto ptr = reinterpret_cast<const EMC::OperatorTextT *>(value);
      return CreateOperatorText(_fbb, ptr, _rehasher).Union();
    }
    case Message_operator_display: {
      auto ptr = reinterpret_cast<const EMC::OperatorDisplayT *>(value);
      return CreateOperatorDisplay(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageUnion::MessageUnion(const MessageUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Message_operator_error: {
      value = new EMC::OperatorErrorT(*reinterpret_cast<EMC::OperatorErrorT *>(u.value));
      break;
    }
    case Message_operator_text: {
      value = new EMC::OperatorTextT(*reinterpret_cast<EMC::OperatorTextT *>(u.value));
      break;
    }
    case Message_operator_display: {
      value = new EMC::OperatorDisplayT(*reinterpret_cast<EMC::OperatorDisplayT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageUnion::Reset() {
  switch (type) {
    case Message_operator_error: {
      auto ptr = reinterpret_cast<EMC::OperatorErrorT *>(value);
      delete ptr;
      break;
    }
    case Message_operator_text: {
      auto ptr = reinterpret_cast<EMC::OperatorTextT *>(value);
      delete ptr;
      break;
    }
    case Message_operator_display: {
      auto ptr = reinterpret_cast<EMC::OperatorDisplayT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Message_NONE;
}

inline const EMC::ErrorChannelMsg *GetErrorChannelMsg(const void *buf) {
  return flatbuffers::GetRoot<EMC::ErrorChannelMsg>(buf);
}

inline const EMC::ErrorChannelMsg *GetSizePrefixedErrorChannelMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EMC::ErrorChannelMsg>(buf);
}

inline bool VerifyErrorChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EMC::ErrorChannelMsg>(nullptr);
}

inline bool VerifySizePrefixedErrorChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EMC::ErrorChannelMsg>(nullptr);
}

inline void FinishErrorChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::ErrorChannelMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedErrorChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::ErrorChannelMsg> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<EMC::ErrorChannelMsgT> UnPackErrorChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::ErrorChannelMsgT>(GetErrorChannelMsg(buf)->UnPack(res));
}

inline std::unique_ptr<EMC::ErrorChannelMsgT> UnPackSizePrefixedErrorChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::ErrorChannelMsgT>(GetSizePrefixedErrorChannelMsg(buf)->UnPack(res));
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCERROR_EMC_H_
