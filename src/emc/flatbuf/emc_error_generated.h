// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCERROR_EMC_H_
#define FLATBUFFERS_GENERATED_EMCERROR_EMC_H_

#include "flatbuffers/flatbuffers.h"

namespace EMC {

struct OperatorError;
struct OperatorErrorBuilder;
struct OperatorErrorT;

struct OperatorText;
struct OperatorTextBuilder;
struct OperatorTextT;

struct OperatorDisplay;
struct OperatorDisplayBuilder;
struct OperatorDisplayT;

struct OperatorErrorT : public flatbuffers::NativeTable {
  typedef OperatorError TableType;
  std::string error;
  OperatorErrorT() {
  }
};

struct OperatorError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorErrorT NativeTableType;
  typedef OperatorErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4
  };
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
  OperatorErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorErrorBuilder {
  typedef OperatorError Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(OperatorError::VT_ERROR, error);
  }
  explicit OperatorErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorError> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorError>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorError> CreateOperatorError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  OperatorErrorBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorError> CreateOperatorErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return EMC::CreateOperatorError(
      _fbb,
      error__);
}

flatbuffers::Offset<OperatorError> CreateOperatorError(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorTextT : public flatbuffers::NativeTable {
  typedef OperatorText TableType;
  std::string text;
  OperatorTextT() {
  }
};

struct OperatorText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorTextT NativeTableType;
  typedef OperatorTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  OperatorTextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorTextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorText> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorTextBuilder {
  typedef OperatorText Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(OperatorText::VT_TEXT, text);
  }
  explicit OperatorTextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorText>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorText> CreateOperatorText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  OperatorTextBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorText> CreateOperatorTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return EMC::CreateOperatorText(
      _fbb,
      text__);
}

flatbuffers::Offset<OperatorText> CreateOperatorText(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OperatorDisplayT : public flatbuffers::NativeTable {
  typedef OperatorDisplay TableType;
  std::string display;
  OperatorDisplayT() {
  }
};

struct OperatorDisplay FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorDisplayT NativeTableType;
  typedef OperatorDisplayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISPLAY = 4
  };
  const flatbuffers::String *display() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISPLAY) &&
           verifier.VerifyString(display()) &&
           verifier.EndTable();
  }
  OperatorDisplayT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OperatorDisplayT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OperatorDisplay> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OperatorDisplayBuilder {
  typedef OperatorDisplay Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_display(flatbuffers::Offset<flatbuffers::String> display) {
    fbb_.AddOffset(OperatorDisplay::VT_DISPLAY, display);
  }
  explicit OperatorDisplayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OperatorDisplay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorDisplay>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> display = 0) {
  OperatorDisplayBuilder builder_(_fbb);
  builder_.add_display(display);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *display = nullptr) {
  auto display__ = display ? _fbb.CreateString(display) : 0;
  return EMC::CreateOperatorDisplay(
      _fbb,
      display__);
}

flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline OperatorErrorT *OperatorError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorErrorT> _o = std::unique_ptr<EMC::OperatorErrorT>(new OperatorErrorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorError::UnPackTo(OperatorErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
}

inline flatbuffers::Offset<OperatorError> OperatorError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorError> CreateOperatorError(flatbuffers::FlatBufferBuilder &_fbb, const OperatorErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  return EMC::CreateOperatorError(
      _fbb,
      _error);
}

inline OperatorTextT *OperatorText::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorTextT> _o = std::unique_ptr<EMC::OperatorTextT>(new OperatorTextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorText::UnPackTo(OperatorTextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline flatbuffers::Offset<OperatorText> OperatorText::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorText(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorText> CreateOperatorText(flatbuffers::FlatBufferBuilder &_fbb, const OperatorTextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorTextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  return EMC::CreateOperatorText(
      _fbb,
      _text);
}

inline OperatorDisplayT *OperatorDisplay::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::OperatorDisplayT> _o = std::unique_ptr<EMC::OperatorDisplayT>(new OperatorDisplayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void OperatorDisplay::UnPackTo(OperatorDisplayT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = display(); if (_e) _o->display = _e->str(); }
}

inline flatbuffers::Offset<OperatorDisplay> OperatorDisplay::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOperatorDisplay(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OperatorDisplay> CreateOperatorDisplay(flatbuffers::FlatBufferBuilder &_fbb, const OperatorDisplayT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OperatorDisplayT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _display = _o->display.empty() ? 0 : _fbb.CreateString(_o->display);
  return EMC::CreateOperatorDisplay(
      _fbb,
      _display);
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCERROR_EMC_H_
