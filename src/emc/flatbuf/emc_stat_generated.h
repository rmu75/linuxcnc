// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCSTAT_EMC_H_
#define FLATBUFFERS_GENERATED_EMCSTAT_EMC_H_

#include "flatbuffers/flatbuffers.h"

#include "emc_common_generated.h"

namespace EMC {

struct AxisStat;
struct AxisStatBuilder;
struct AxisStatT;

struct JointStat;
struct JointStatBuilder;
struct JointStatT;

struct TrajStat;
struct TrajStatBuilder;
struct TrajStatT;

struct SpindleStat;
struct SpindleStatBuilder;
struct SpindleStatT;

struct MotionStat;
struct MotionStatBuilder;
struct MotionStatT;

struct TaskStat;
struct TaskStatBuilder;
struct TaskStatT;

struct ToolStat;
struct ToolStatBuilder;
struct ToolStatT;

struct CoolantStat;
struct CoolantStatBuilder;
struct CoolantStatT;

struct AuxStat;
struct AuxStatBuilder;
struct AuxStatT;

struct IOStat;
struct IOStatBuilder;
struct IOStatT;

struct EmcStat;
struct EmcStatBuilder;
struct EmcStatT;

enum JointType {
  JointType_linear = 0,
  JointType_angular = 1,
  JointType_MIN = JointType_linear,
  JointType_MAX = JointType_angular
};

inline const JointType (&EnumValuesJointType())[2] {
  static const JointType values[] = {
    JointType_linear,
    JointType_angular
  };
  return values;
}

inline const char * const *EnumNamesJointType() {
  static const char * const names[3] = {
    "linear",
    "angular",
    nullptr
  };
  return names;
}

inline const char *EnumNameJointType(JointType e) {
  if (flatbuffers::IsOutRange(e, JointType_linear, JointType_angular)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJointType()[index];
}

enum TrajMode {
  TrajMode_free = 0,
  TrajMode_coord = 1,
  TrajMode_MIN = TrajMode_free,
  TrajMode_MAX = TrajMode_coord
};

inline const TrajMode (&EnumValuesTrajMode())[2] {
  static const TrajMode values[] = {
    TrajMode_free,
    TrajMode_coord
  };
  return values;
}

inline const char * const *EnumNamesTrajMode() {
  static const char * const names[3] = {
    "free",
    "coord",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrajMode(TrajMode e) {
  if (flatbuffers::IsOutRange(e, TrajMode_free, TrajMode_coord)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrajMode()[index];
}

struct AxisStatT : public flatbuffers::NativeTable {
  typedef AxisStat TableType;
  int32_t axis;
  double min_position_limit;
  double max_position_limit;
  double velocity;
  AxisStatT()
      : axis(0),
        min_position_limit(0.0),
        max_position_limit(0.0),
        velocity(0.0) {
  }
};

struct AxisStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AxisStatT NativeTableType;
  typedef AxisStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_MIN_POSITION_LIMIT = 6,
    VT_MAX_POSITION_LIMIT = 8,
    VT_VELOCITY = 10
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  double min_position_limit() const {
    return GetField<double>(VT_MIN_POSITION_LIMIT, 0.0);
  }
  double max_position_limit() const {
    return GetField<double>(VT_MAX_POSITION_LIMIT, 0.0);
  }
  double velocity() const {
    return GetField<double>(VT_VELOCITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<double>(verifier, VT_MIN_POSITION_LIMIT) &&
           VerifyField<double>(verifier, VT_MAX_POSITION_LIMIT) &&
           VerifyField<double>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  AxisStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AxisStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AxisStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AxisStatBuilder {
  typedef AxisStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(AxisStat::VT_AXIS, axis, 0);
  }
  void add_min_position_limit(double min_position_limit) {
    fbb_.AddElement<double>(AxisStat::VT_MIN_POSITION_LIMIT, min_position_limit, 0.0);
  }
  void add_max_position_limit(double max_position_limit) {
    fbb_.AddElement<double>(AxisStat::VT_MAX_POSITION_LIMIT, max_position_limit, 0.0);
  }
  void add_velocity(double velocity) {
    fbb_.AddElement<double>(AxisStat::VT_VELOCITY, velocity, 0.0);
  }
  explicit AxisStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AxisStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AxisStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<AxisStat> CreateAxisStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    double min_position_limit = 0.0,
    double max_position_limit = 0.0,
    double velocity = 0.0) {
  AxisStatBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_max_position_limit(max_position_limit);
  builder_.add_min_position_limit(min_position_limit);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<AxisStat> CreateAxisStat(flatbuffers::FlatBufferBuilder &_fbb, const AxisStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JointStatT : public flatbuffers::NativeTable {
  typedef JointStat TableType;
  int32_t joint;
  EMC::JointType joint_type;
  double units;
  double backlash;
  double min_position_limit;
  double max_position_limit;
  double max_ferror;
  double min_ferror;
  double ferror_count;
  double ferror_high_mark;
  double output;
  double input;
  double velocity;
  bool is_in_position;
  bool is_homing;
  bool is_homed;
  bool is_fault;
  bool is_enabled;
  bool is_min_soft_limit_exceeded;
  bool is_max_soft_limit_exceeded;
  bool is_min_hard_limit_exceeded;
  bool is_max_hard_limit_exceeded;
  bool is_override_limits;
  JointStatT()
      : joint(0),
        joint_type(EMC::JointType_linear),
        units(0.0),
        backlash(0.0),
        min_position_limit(0.0),
        max_position_limit(0.0),
        max_ferror(0.0),
        min_ferror(0.0),
        ferror_count(0.0),
        ferror_high_mark(0.0),
        output(0.0),
        input(0.0),
        velocity(0.0),
        is_in_position(false),
        is_homing(false),
        is_homed(false),
        is_fault(false),
        is_enabled(false),
        is_min_soft_limit_exceeded(false),
        is_max_soft_limit_exceeded(false),
        is_min_hard_limit_exceeded(false),
        is_max_hard_limit_exceeded(false),
        is_override_limits(false) {
  }
};

struct JointStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointStatT NativeTableType;
  typedef JointStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOINT = 4,
    VT_JOINT_TYPE = 6,
    VT_UNITS = 8,
    VT_BACKLASH = 10,
    VT_MIN_POSITION_LIMIT = 12,
    VT_MAX_POSITION_LIMIT = 14,
    VT_MAX_FERROR = 16,
    VT_MIN_FERROR = 18,
    VT_FERROR_COUNT = 20,
    VT_FERROR_HIGH_MARK = 22,
    VT_OUTPUT = 24,
    VT_INPUT = 26,
    VT_VELOCITY = 28,
    VT_IS_IN_POSITION = 30,
    VT_IS_HOMING = 32,
    VT_IS_HOMED = 34,
    VT_IS_FAULT = 36,
    VT_IS_ENABLED = 38,
    VT_IS_MIN_SOFT_LIMIT_EXCEEDED = 40,
    VT_IS_MAX_SOFT_LIMIT_EXCEEDED = 42,
    VT_IS_MIN_HARD_LIMIT_EXCEEDED = 44,
    VT_IS_MAX_HARD_LIMIT_EXCEEDED = 46,
    VT_IS_OVERRIDE_LIMITS = 48
  };
  int32_t joint() const {
    return GetField<int32_t>(VT_JOINT, 0);
  }
  EMC::JointType joint_type() const {
    return static_cast<EMC::JointType>(GetField<int8_t>(VT_JOINT_TYPE, 0));
  }
  double units() const {
    return GetField<double>(VT_UNITS, 0.0);
  }
  double backlash() const {
    return GetField<double>(VT_BACKLASH, 0.0);
  }
  double min_position_limit() const {
    return GetField<double>(VT_MIN_POSITION_LIMIT, 0.0);
  }
  double max_position_limit() const {
    return GetField<double>(VT_MAX_POSITION_LIMIT, 0.0);
  }
  double max_ferror() const {
    return GetField<double>(VT_MAX_FERROR, 0.0);
  }
  double min_ferror() const {
    return GetField<double>(VT_MIN_FERROR, 0.0);
  }
  double ferror_count() const {
    return GetField<double>(VT_FERROR_COUNT, 0.0);
  }
  double ferror_high_mark() const {
    return GetField<double>(VT_FERROR_HIGH_MARK, 0.0);
  }
  double output() const {
    return GetField<double>(VT_OUTPUT, 0.0);
  }
  double input() const {
    return GetField<double>(VT_INPUT, 0.0);
  }
  double velocity() const {
    return GetField<double>(VT_VELOCITY, 0.0);
  }
  bool is_in_position() const {
    return GetField<uint8_t>(VT_IS_IN_POSITION, 0) != 0;
  }
  bool is_homing() const {
    return GetField<uint8_t>(VT_IS_HOMING, 0) != 0;
  }
  bool is_homed() const {
    return GetField<uint8_t>(VT_IS_HOMED, 0) != 0;
  }
  bool is_fault() const {
    return GetField<uint8_t>(VT_IS_FAULT, 0) != 0;
  }
  bool is_enabled() const {
    return GetField<uint8_t>(VT_IS_ENABLED, 0) != 0;
  }
  bool is_min_soft_limit_exceeded() const {
    return GetField<uint8_t>(VT_IS_MIN_SOFT_LIMIT_EXCEEDED, 0) != 0;
  }
  bool is_max_soft_limit_exceeded() const {
    return GetField<uint8_t>(VT_IS_MAX_SOFT_LIMIT_EXCEEDED, 0) != 0;
  }
  bool is_min_hard_limit_exceeded() const {
    return GetField<uint8_t>(VT_IS_MIN_HARD_LIMIT_EXCEEDED, 0) != 0;
  }
  bool is_max_hard_limit_exceeded() const {
    return GetField<uint8_t>(VT_IS_MAX_HARD_LIMIT_EXCEEDED, 0) != 0;
  }
  bool is_override_limits() const {
    return GetField<uint8_t>(VT_IS_OVERRIDE_LIMITS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_JOINT) &&
           VerifyField<int8_t>(verifier, VT_JOINT_TYPE) &&
           VerifyField<double>(verifier, VT_UNITS) &&
           VerifyField<double>(verifier, VT_BACKLASH) &&
           VerifyField<double>(verifier, VT_MIN_POSITION_LIMIT) &&
           VerifyField<double>(verifier, VT_MAX_POSITION_LIMIT) &&
           VerifyField<double>(verifier, VT_MAX_FERROR) &&
           VerifyField<double>(verifier, VT_MIN_FERROR) &&
           VerifyField<double>(verifier, VT_FERROR_COUNT) &&
           VerifyField<double>(verifier, VT_FERROR_HIGH_MARK) &&
           VerifyField<double>(verifier, VT_OUTPUT) &&
           VerifyField<double>(verifier, VT_INPUT) &&
           VerifyField<double>(verifier, VT_VELOCITY) &&
           VerifyField<uint8_t>(verifier, VT_IS_IN_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_IS_HOMING) &&
           VerifyField<uint8_t>(verifier, VT_IS_HOMED) &&
           VerifyField<uint8_t>(verifier, VT_IS_FAULT) &&
           VerifyField<uint8_t>(verifier, VT_IS_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIN_SOFT_LIMIT_EXCEEDED) &&
           VerifyField<uint8_t>(verifier, VT_IS_MAX_SOFT_LIMIT_EXCEEDED) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIN_HARD_LIMIT_EXCEEDED) &&
           VerifyField<uint8_t>(verifier, VT_IS_MAX_HARD_LIMIT_EXCEEDED) &&
           VerifyField<uint8_t>(verifier, VT_IS_OVERRIDE_LIMITS) &&
           verifier.EndTable();
  }
  JointStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JointStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JointStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JointStatBuilder {
  typedef JointStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_joint(int32_t joint) {
    fbb_.AddElement<int32_t>(JointStat::VT_JOINT, joint, 0);
  }
  void add_joint_type(EMC::JointType joint_type) {
    fbb_.AddElement<int8_t>(JointStat::VT_JOINT_TYPE, static_cast<int8_t>(joint_type), 0);
  }
  void add_units(double units) {
    fbb_.AddElement<double>(JointStat::VT_UNITS, units, 0.0);
  }
  void add_backlash(double backlash) {
    fbb_.AddElement<double>(JointStat::VT_BACKLASH, backlash, 0.0);
  }
  void add_min_position_limit(double min_position_limit) {
    fbb_.AddElement<double>(JointStat::VT_MIN_POSITION_LIMIT, min_position_limit, 0.0);
  }
  void add_max_position_limit(double max_position_limit) {
    fbb_.AddElement<double>(JointStat::VT_MAX_POSITION_LIMIT, max_position_limit, 0.0);
  }
  void add_max_ferror(double max_ferror) {
    fbb_.AddElement<double>(JointStat::VT_MAX_FERROR, max_ferror, 0.0);
  }
  void add_min_ferror(double min_ferror) {
    fbb_.AddElement<double>(JointStat::VT_MIN_FERROR, min_ferror, 0.0);
  }
  void add_ferror_count(double ferror_count) {
    fbb_.AddElement<double>(JointStat::VT_FERROR_COUNT, ferror_count, 0.0);
  }
  void add_ferror_high_mark(double ferror_high_mark) {
    fbb_.AddElement<double>(JointStat::VT_FERROR_HIGH_MARK, ferror_high_mark, 0.0);
  }
  void add_output(double output) {
    fbb_.AddElement<double>(JointStat::VT_OUTPUT, output, 0.0);
  }
  void add_input(double input) {
    fbb_.AddElement<double>(JointStat::VT_INPUT, input, 0.0);
  }
  void add_velocity(double velocity) {
    fbb_.AddElement<double>(JointStat::VT_VELOCITY, velocity, 0.0);
  }
  void add_is_in_position(bool is_in_position) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_IN_POSITION, static_cast<uint8_t>(is_in_position), 0);
  }
  void add_is_homing(bool is_homing) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_HOMING, static_cast<uint8_t>(is_homing), 0);
  }
  void add_is_homed(bool is_homed) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_HOMED, static_cast<uint8_t>(is_homed), 0);
  }
  void add_is_fault(bool is_fault) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_FAULT, static_cast<uint8_t>(is_fault), 0);
  }
  void add_is_enabled(bool is_enabled) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_ENABLED, static_cast<uint8_t>(is_enabled), 0);
  }
  void add_is_min_soft_limit_exceeded(bool is_min_soft_limit_exceeded) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_MIN_SOFT_LIMIT_EXCEEDED, static_cast<uint8_t>(is_min_soft_limit_exceeded), 0);
  }
  void add_is_max_soft_limit_exceeded(bool is_max_soft_limit_exceeded) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_MAX_SOFT_LIMIT_EXCEEDED, static_cast<uint8_t>(is_max_soft_limit_exceeded), 0);
  }
  void add_is_min_hard_limit_exceeded(bool is_min_hard_limit_exceeded) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_MIN_HARD_LIMIT_EXCEEDED, static_cast<uint8_t>(is_min_hard_limit_exceeded), 0);
  }
  void add_is_max_hard_limit_exceeded(bool is_max_hard_limit_exceeded) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_MAX_HARD_LIMIT_EXCEEDED, static_cast<uint8_t>(is_max_hard_limit_exceeded), 0);
  }
  void add_is_override_limits(bool is_override_limits) {
    fbb_.AddElement<uint8_t>(JointStat::VT_IS_OVERRIDE_LIMITS, static_cast<uint8_t>(is_override_limits), 0);
  }
  explicit JointStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<JointStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JointStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<JointStat> CreateJointStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t joint = 0,
    EMC::JointType joint_type = EMC::JointType_linear,
    double units = 0.0,
    double backlash = 0.0,
    double min_position_limit = 0.0,
    double max_position_limit = 0.0,
    double max_ferror = 0.0,
    double min_ferror = 0.0,
    double ferror_count = 0.0,
    double ferror_high_mark = 0.0,
    double output = 0.0,
    double input = 0.0,
    double velocity = 0.0,
    bool is_in_position = false,
    bool is_homing = false,
    bool is_homed = false,
    bool is_fault = false,
    bool is_enabled = false,
    bool is_min_soft_limit_exceeded = false,
    bool is_max_soft_limit_exceeded = false,
    bool is_min_hard_limit_exceeded = false,
    bool is_max_hard_limit_exceeded = false,
    bool is_override_limits = false) {
  JointStatBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_input(input);
  builder_.add_output(output);
  builder_.add_ferror_high_mark(ferror_high_mark);
  builder_.add_ferror_count(ferror_count);
  builder_.add_min_ferror(min_ferror);
  builder_.add_max_ferror(max_ferror);
  builder_.add_max_position_limit(max_position_limit);
  builder_.add_min_position_limit(min_position_limit);
  builder_.add_backlash(backlash);
  builder_.add_units(units);
  builder_.add_joint(joint);
  builder_.add_is_override_limits(is_override_limits);
  builder_.add_is_max_hard_limit_exceeded(is_max_hard_limit_exceeded);
  builder_.add_is_min_hard_limit_exceeded(is_min_hard_limit_exceeded);
  builder_.add_is_max_soft_limit_exceeded(is_max_soft_limit_exceeded);
  builder_.add_is_min_soft_limit_exceeded(is_min_soft_limit_exceeded);
  builder_.add_is_enabled(is_enabled);
  builder_.add_is_fault(is_fault);
  builder_.add_is_homed(is_homed);
  builder_.add_is_homing(is_homing);
  builder_.add_is_in_position(is_in_position);
  builder_.add_joint_type(joint_type);
  return builder_.Finish();
}

flatbuffers::Offset<JointStat> CreateJointStat(flatbuffers::FlatBufferBuilder &_fbb, const JointStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TrajStatT : public flatbuffers::NativeTable {
  typedef TrajStat TableType;
  double linear_units;
  double angular_units;
  double cycle_time;
  int32_t joints;
  int32_t spindles;
  int32_t axis_mask;
  EMC::TrajMode mode;
  bool is_enabled;
  bool is_in_position;
  int32_t queue;
  int32_t active_queue;
  bool is_queue_full;
  int32_t id;
  bool is_paused;
  double scale;
  double rapid_scale;
  std::unique_ptr<EMC::Pose> position;
  std::unique_ptr<EMC::Pose> actual_position;
  double velocity;
  double acceleration;
  double max_velocity;
  double max_acceleration;
  std::unique_ptr<EMC::Pose> probed_position;
  bool is_probe_tripped;
  bool is_probing;
  int32_t probeval;
  int32_t kinematics_type;
  int32_t motion_type;
  double linear_distance_to_go;
  std::unique_ptr<EMC::Pose> distance_to_go;
  double current_vel;
  bool is_feed_override_enabled;
  bool is_adaptive_feed_enabled;
  TrajStatT()
      : linear_units(0.0),
        angular_units(0.0),
        cycle_time(0.0),
        joints(0),
        spindles(0),
        axis_mask(0),
        mode(EMC::TrajMode_free),
        is_enabled(false),
        is_in_position(false),
        queue(0),
        active_queue(0),
        is_queue_full(false),
        id(0),
        is_paused(false),
        scale(0.0),
        rapid_scale(0.0),
        velocity(0.0),
        acceleration(0.0),
        max_velocity(0.0),
        max_acceleration(0.0),
        is_probe_tripped(false),
        is_probing(false),
        probeval(0),
        kinematics_type(0),
        motion_type(0),
        linear_distance_to_go(0.0),
        current_vel(0.0),
        is_feed_override_enabled(false),
        is_adaptive_feed_enabled(false) {
  }
};

struct TrajStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrajStatT NativeTableType;
  typedef TrajStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINEAR_UNITS = 4,
    VT_ANGULAR_UNITS = 6,
    VT_CYCLE_TIME = 8,
    VT_JOINTS = 10,
    VT_SPINDLES = 12,
    VT_AXIS_MASK = 14,
    VT_MODE = 16,
    VT_IS_ENABLED = 18,
    VT_IS_IN_POSITION = 20,
    VT_QUEUE = 22,
    VT_ACTIVE_QUEUE = 24,
    VT_IS_QUEUE_FULL = 26,
    VT_ID = 28,
    VT_IS_PAUSED = 30,
    VT_SCALE = 32,
    VT_RAPID_SCALE = 34,
    VT_POSITION = 36,
    VT_ACTUAL_POSITION = 38,
    VT_VELOCITY = 40,
    VT_ACCELERATION = 42,
    VT_MAX_VELOCITY = 44,
    VT_MAX_ACCELERATION = 46,
    VT_PROBED_POSITION = 48,
    VT_IS_PROBE_TRIPPED = 50,
    VT_IS_PROBING = 52,
    VT_PROBEVAL = 54,
    VT_KINEMATICS_TYPE = 56,
    VT_MOTION_TYPE = 58,
    VT_LINEAR_DISTANCE_TO_GO = 60,
    VT_DISTANCE_TO_GO = 62,
    VT_CURRENT_VEL = 64,
    VT_IS_FEED_OVERRIDE_ENABLED = 66,
    VT_IS_ADAPTIVE_FEED_ENABLED = 68
  };
  double linear_units() const {
    return GetField<double>(VT_LINEAR_UNITS, 0.0);
  }
  double angular_units() const {
    return GetField<double>(VT_ANGULAR_UNITS, 0.0);
  }
  double cycle_time() const {
    return GetField<double>(VT_CYCLE_TIME, 0.0);
  }
  int32_t joints() const {
    return GetField<int32_t>(VT_JOINTS, 0);
  }
  int32_t spindles() const {
    return GetField<int32_t>(VT_SPINDLES, 0);
  }
  int32_t axis_mask() const {
    return GetField<int32_t>(VT_AXIS_MASK, 0);
  }
  EMC::TrajMode mode() const {
    return static_cast<EMC::TrajMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool is_enabled() const {
    return GetField<uint8_t>(VT_IS_ENABLED, 0) != 0;
  }
  bool is_in_position() const {
    return GetField<uint8_t>(VT_IS_IN_POSITION, 0) != 0;
  }
  int32_t queue() const {
    return GetField<int32_t>(VT_QUEUE, 0);
  }
  int32_t active_queue() const {
    return GetField<int32_t>(VT_ACTIVE_QUEUE, 0);
  }
  bool is_queue_full() const {
    return GetField<uint8_t>(VT_IS_QUEUE_FULL, 0) != 0;
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool is_paused() const {
    return GetField<uint8_t>(VT_IS_PAUSED, 0) != 0;
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  double rapid_scale() const {
    return GetField<double>(VT_RAPID_SCALE, 0.0);
  }
  const EMC::Pose *position() const {
    return GetStruct<const EMC::Pose *>(VT_POSITION);
  }
  const EMC::Pose *actual_position() const {
    return GetStruct<const EMC::Pose *>(VT_ACTUAL_POSITION);
  }
  double velocity() const {
    return GetField<double>(VT_VELOCITY, 0.0);
  }
  double acceleration() const {
    return GetField<double>(VT_ACCELERATION, 0.0);
  }
  double max_velocity() const {
    return GetField<double>(VT_MAX_VELOCITY, 0.0);
  }
  double max_acceleration() const {
    return GetField<double>(VT_MAX_ACCELERATION, 0.0);
  }
  const EMC::Pose *probed_position() const {
    return GetStruct<const EMC::Pose *>(VT_PROBED_POSITION);
  }
  bool is_probe_tripped() const {
    return GetField<uint8_t>(VT_IS_PROBE_TRIPPED, 0) != 0;
  }
  bool is_probing() const {
    return GetField<uint8_t>(VT_IS_PROBING, 0) != 0;
  }
  int32_t probeval() const {
    return GetField<int32_t>(VT_PROBEVAL, 0);
  }
  int32_t kinematics_type() const {
    return GetField<int32_t>(VT_KINEMATICS_TYPE, 0);
  }
  int32_t motion_type() const {
    return GetField<int32_t>(VT_MOTION_TYPE, 0);
  }
  double linear_distance_to_go() const {
    return GetField<double>(VT_LINEAR_DISTANCE_TO_GO, 0.0);
  }
  const EMC::Pose *distance_to_go() const {
    return GetStruct<const EMC::Pose *>(VT_DISTANCE_TO_GO);
  }
  double current_vel() const {
    return GetField<double>(VT_CURRENT_VEL, 0.0);
  }
  bool is_feed_override_enabled() const {
    return GetField<uint8_t>(VT_IS_FEED_OVERRIDE_ENABLED, 0) != 0;
  }
  bool is_adaptive_feed_enabled() const {
    return GetField<uint8_t>(VT_IS_ADAPTIVE_FEED_ENABLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LINEAR_UNITS) &&
           VerifyField<double>(verifier, VT_ANGULAR_UNITS) &&
           VerifyField<double>(verifier, VT_CYCLE_TIME) &&
           VerifyField<int32_t>(verifier, VT_JOINTS) &&
           VerifyField<int32_t>(verifier, VT_SPINDLES) &&
           VerifyField<int32_t>(verifier, VT_AXIS_MASK) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_IS_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_IN_POSITION) &&
           VerifyField<int32_t>(verifier, VT_QUEUE) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_QUEUE) &&
           VerifyField<uint8_t>(verifier, VT_IS_QUEUE_FULL) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_IS_PAUSED) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<double>(verifier, VT_RAPID_SCALE) &&
           VerifyField<EMC::Pose>(verifier, VT_POSITION) &&
           VerifyField<EMC::Pose>(verifier, VT_ACTUAL_POSITION) &&
           VerifyField<double>(verifier, VT_VELOCITY) &&
           VerifyField<double>(verifier, VT_ACCELERATION) &&
           VerifyField<double>(verifier, VT_MAX_VELOCITY) &&
           VerifyField<double>(verifier, VT_MAX_ACCELERATION) &&
           VerifyField<EMC::Pose>(verifier, VT_PROBED_POSITION) &&
           VerifyField<uint8_t>(verifier, VT_IS_PROBE_TRIPPED) &&
           VerifyField<uint8_t>(verifier, VT_IS_PROBING) &&
           VerifyField<int32_t>(verifier, VT_PROBEVAL) &&
           VerifyField<int32_t>(verifier, VT_KINEMATICS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_MOTION_TYPE) &&
           VerifyField<double>(verifier, VT_LINEAR_DISTANCE_TO_GO) &&
           VerifyField<EMC::Pose>(verifier, VT_DISTANCE_TO_GO) &&
           VerifyField<double>(verifier, VT_CURRENT_VEL) &&
           VerifyField<uint8_t>(verifier, VT_IS_FEED_OVERRIDE_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_ADAPTIVE_FEED_ENABLED) &&
           verifier.EndTable();
  }
  TrajStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrajStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrajStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrajStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrajStatBuilder {
  typedef TrajStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_linear_units(double linear_units) {
    fbb_.AddElement<double>(TrajStat::VT_LINEAR_UNITS, linear_units, 0.0);
  }
  void add_angular_units(double angular_units) {
    fbb_.AddElement<double>(TrajStat::VT_ANGULAR_UNITS, angular_units, 0.0);
  }
  void add_cycle_time(double cycle_time) {
    fbb_.AddElement<double>(TrajStat::VT_CYCLE_TIME, cycle_time, 0.0);
  }
  void add_joints(int32_t joints) {
    fbb_.AddElement<int32_t>(TrajStat::VT_JOINTS, joints, 0);
  }
  void add_spindles(int32_t spindles) {
    fbb_.AddElement<int32_t>(TrajStat::VT_SPINDLES, spindles, 0);
  }
  void add_axis_mask(int32_t axis_mask) {
    fbb_.AddElement<int32_t>(TrajStat::VT_AXIS_MASK, axis_mask, 0);
  }
  void add_mode(EMC::TrajMode mode) {
    fbb_.AddElement<int8_t>(TrajStat::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_is_enabled(bool is_enabled) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_ENABLED, static_cast<uint8_t>(is_enabled), 0);
  }
  void add_is_in_position(bool is_in_position) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_IN_POSITION, static_cast<uint8_t>(is_in_position), 0);
  }
  void add_queue(int32_t queue) {
    fbb_.AddElement<int32_t>(TrajStat::VT_QUEUE, queue, 0);
  }
  void add_active_queue(int32_t active_queue) {
    fbb_.AddElement<int32_t>(TrajStat::VT_ACTIVE_QUEUE, active_queue, 0);
  }
  void add_is_queue_full(bool is_queue_full) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_QUEUE_FULL, static_cast<uint8_t>(is_queue_full), 0);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(TrajStat::VT_ID, id, 0);
  }
  void add_is_paused(bool is_paused) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_PAUSED, static_cast<uint8_t>(is_paused), 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(TrajStat::VT_SCALE, scale, 0.0);
  }
  void add_rapid_scale(double rapid_scale) {
    fbb_.AddElement<double>(TrajStat::VT_RAPID_SCALE, rapid_scale, 0.0);
  }
  void add_position(const EMC::Pose *position) {
    fbb_.AddStruct(TrajStat::VT_POSITION, position);
  }
  void add_actual_position(const EMC::Pose *actual_position) {
    fbb_.AddStruct(TrajStat::VT_ACTUAL_POSITION, actual_position);
  }
  void add_velocity(double velocity) {
    fbb_.AddElement<double>(TrajStat::VT_VELOCITY, velocity, 0.0);
  }
  void add_acceleration(double acceleration) {
    fbb_.AddElement<double>(TrajStat::VT_ACCELERATION, acceleration, 0.0);
  }
  void add_max_velocity(double max_velocity) {
    fbb_.AddElement<double>(TrajStat::VT_MAX_VELOCITY, max_velocity, 0.0);
  }
  void add_max_acceleration(double max_acceleration) {
    fbb_.AddElement<double>(TrajStat::VT_MAX_ACCELERATION, max_acceleration, 0.0);
  }
  void add_probed_position(const EMC::Pose *probed_position) {
    fbb_.AddStruct(TrajStat::VT_PROBED_POSITION, probed_position);
  }
  void add_is_probe_tripped(bool is_probe_tripped) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_PROBE_TRIPPED, static_cast<uint8_t>(is_probe_tripped), 0);
  }
  void add_is_probing(bool is_probing) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_PROBING, static_cast<uint8_t>(is_probing), 0);
  }
  void add_probeval(int32_t probeval) {
    fbb_.AddElement<int32_t>(TrajStat::VT_PROBEVAL, probeval, 0);
  }
  void add_kinematics_type(int32_t kinematics_type) {
    fbb_.AddElement<int32_t>(TrajStat::VT_KINEMATICS_TYPE, kinematics_type, 0);
  }
  void add_motion_type(int32_t motion_type) {
    fbb_.AddElement<int32_t>(TrajStat::VT_MOTION_TYPE, motion_type, 0);
  }
  void add_linear_distance_to_go(double linear_distance_to_go) {
    fbb_.AddElement<double>(TrajStat::VT_LINEAR_DISTANCE_TO_GO, linear_distance_to_go, 0.0);
  }
  void add_distance_to_go(const EMC::Pose *distance_to_go) {
    fbb_.AddStruct(TrajStat::VT_DISTANCE_TO_GO, distance_to_go);
  }
  void add_current_vel(double current_vel) {
    fbb_.AddElement<double>(TrajStat::VT_CURRENT_VEL, current_vel, 0.0);
  }
  void add_is_feed_override_enabled(bool is_feed_override_enabled) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_FEED_OVERRIDE_ENABLED, static_cast<uint8_t>(is_feed_override_enabled), 0);
  }
  void add_is_adaptive_feed_enabled(bool is_adaptive_feed_enabled) {
    fbb_.AddElement<uint8_t>(TrajStat::VT_IS_ADAPTIVE_FEED_ENABLED, static_cast<uint8_t>(is_adaptive_feed_enabled), 0);
  }
  explicit TrajStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrajStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrajStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrajStat> CreateTrajStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double linear_units = 0.0,
    double angular_units = 0.0,
    double cycle_time = 0.0,
    int32_t joints = 0,
    int32_t spindles = 0,
    int32_t axis_mask = 0,
    EMC::TrajMode mode = EMC::TrajMode_free,
    bool is_enabled = false,
    bool is_in_position = false,
    int32_t queue = 0,
    int32_t active_queue = 0,
    bool is_queue_full = false,
    int32_t id = 0,
    bool is_paused = false,
    double scale = 0.0,
    double rapid_scale = 0.0,
    const EMC::Pose *position = 0,
    const EMC::Pose *actual_position = 0,
    double velocity = 0.0,
    double acceleration = 0.0,
    double max_velocity = 0.0,
    double max_acceleration = 0.0,
    const EMC::Pose *probed_position = 0,
    bool is_probe_tripped = false,
    bool is_probing = false,
    int32_t probeval = 0,
    int32_t kinematics_type = 0,
    int32_t motion_type = 0,
    double linear_distance_to_go = 0.0,
    const EMC::Pose *distance_to_go = 0,
    double current_vel = 0.0,
    bool is_feed_override_enabled = false,
    bool is_adaptive_feed_enabled = false) {
  TrajStatBuilder builder_(_fbb);
  builder_.add_current_vel(current_vel);
  builder_.add_linear_distance_to_go(linear_distance_to_go);
  builder_.add_max_acceleration(max_acceleration);
  builder_.add_max_velocity(max_velocity);
  builder_.add_acceleration(acceleration);
  builder_.add_velocity(velocity);
  builder_.add_rapid_scale(rapid_scale);
  builder_.add_scale(scale);
  builder_.add_cycle_time(cycle_time);
  builder_.add_angular_units(angular_units);
  builder_.add_linear_units(linear_units);
  builder_.add_distance_to_go(distance_to_go);
  builder_.add_motion_type(motion_type);
  builder_.add_kinematics_type(kinematics_type);
  builder_.add_probeval(probeval);
  builder_.add_probed_position(probed_position);
  builder_.add_actual_position(actual_position);
  builder_.add_position(position);
  builder_.add_id(id);
  builder_.add_active_queue(active_queue);
  builder_.add_queue(queue);
  builder_.add_axis_mask(axis_mask);
  builder_.add_spindles(spindles);
  builder_.add_joints(joints);
  builder_.add_is_adaptive_feed_enabled(is_adaptive_feed_enabled);
  builder_.add_is_feed_override_enabled(is_feed_override_enabled);
  builder_.add_is_probing(is_probing);
  builder_.add_is_probe_tripped(is_probe_tripped);
  builder_.add_is_paused(is_paused);
  builder_.add_is_queue_full(is_queue_full);
  builder_.add_is_in_position(is_in_position);
  builder_.add_is_enabled(is_enabled);
  builder_.add_mode(mode);
  return builder_.Finish();
}

flatbuffers::Offset<TrajStat> CreateTrajStat(flatbuffers::FlatBufferBuilder &_fbb, const TrajStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpindleStatT : public flatbuffers::NativeTable {
  typedef SpindleStat TableType;
  double speed;
  double spindle_scale;
  double css_maximum;
  double css_factor;
  int32_t state;
  int32_t direction;
  bool is_brake_engaged;
  bool is_increasing;
  bool is_decreasing;
  bool is_enabled;
  int32_t orient_state;
  int32_t orient_fault;
  bool is_spindle_override_enabled;
  bool is_homed;
  SpindleStatT()
      : speed(0.0),
        spindle_scale(0.0),
        css_maximum(0.0),
        css_factor(0.0),
        state(0),
        direction(0),
        is_brake_engaged(false),
        is_increasing(false),
        is_decreasing(false),
        is_enabled(false),
        orient_state(0),
        orient_fault(0),
        is_spindle_override_enabled(false),
        is_homed(false) {
  }
};

struct SpindleStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpindleStatT NativeTableType;
  typedef SpindleStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPEED = 4,
    VT_SPINDLE_SCALE = 6,
    VT_CSS_MAXIMUM = 8,
    VT_CSS_FACTOR = 10,
    VT_STATE = 12,
    VT_DIRECTION = 14,
    VT_IS_BRAKE_ENGAGED = 16,
    VT_IS_INCREASING = 18,
    VT_IS_DECREASING = 20,
    VT_IS_ENABLED = 22,
    VT_ORIENT_STATE = 24,
    VT_ORIENT_FAULT = 26,
    VT_IS_SPINDLE_OVERRIDE_ENABLED = 28,
    VT_IS_HOMED = 30
  };
  double speed() const {
    return GetField<double>(VT_SPEED, 0.0);
  }
  double spindle_scale() const {
    return GetField<double>(VT_SPINDLE_SCALE, 0.0);
  }
  double css_maximum() const {
    return GetField<double>(VT_CSS_MAXIMUM, 0.0);
  }
  double css_factor() const {
    return GetField<double>(VT_CSS_FACTOR, 0.0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t direction() const {
    return GetField<int32_t>(VT_DIRECTION, 0);
  }
  bool is_brake_engaged() const {
    return GetField<uint8_t>(VT_IS_BRAKE_ENGAGED, 0) != 0;
  }
  bool is_increasing() const {
    return GetField<uint8_t>(VT_IS_INCREASING, 0) != 0;
  }
  bool is_decreasing() const {
    return GetField<uint8_t>(VT_IS_DECREASING, 0) != 0;
  }
  bool is_enabled() const {
    return GetField<uint8_t>(VT_IS_ENABLED, 0) != 0;
  }
  int32_t orient_state() const {
    return GetField<int32_t>(VT_ORIENT_STATE, 0);
  }
  int32_t orient_fault() const {
    return GetField<int32_t>(VT_ORIENT_FAULT, 0);
  }
  bool is_spindle_override_enabled() const {
    return GetField<uint8_t>(VT_IS_SPINDLE_OVERRIDE_ENABLED, 0) != 0;
  }
  bool is_homed() const {
    return GetField<uint8_t>(VT_IS_HOMED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SPEED) &&
           VerifyField<double>(verifier, VT_SPINDLE_SCALE) &&
           VerifyField<double>(verifier, VT_CSS_MAXIMUM) &&
           VerifyField<double>(verifier, VT_CSS_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_IS_BRAKE_ENGAGED) &&
           VerifyField<uint8_t>(verifier, VT_IS_INCREASING) &&
           VerifyField<uint8_t>(verifier, VT_IS_DECREASING) &&
           VerifyField<uint8_t>(verifier, VT_IS_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_ORIENT_STATE) &&
           VerifyField<int32_t>(verifier, VT_ORIENT_FAULT) &&
           VerifyField<uint8_t>(verifier, VT_IS_SPINDLE_OVERRIDE_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_IS_HOMED) &&
           verifier.EndTable();
  }
  SpindleStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpindleStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpindleStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpindleStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpindleStatBuilder {
  typedef SpindleStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_speed(double speed) {
    fbb_.AddElement<double>(SpindleStat::VT_SPEED, speed, 0.0);
  }
  void add_spindle_scale(double spindle_scale) {
    fbb_.AddElement<double>(SpindleStat::VT_SPINDLE_SCALE, spindle_scale, 0.0);
  }
  void add_css_maximum(double css_maximum) {
    fbb_.AddElement<double>(SpindleStat::VT_CSS_MAXIMUM, css_maximum, 0.0);
  }
  void add_css_factor(double css_factor) {
    fbb_.AddElement<double>(SpindleStat::VT_CSS_FACTOR, css_factor, 0.0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(SpindleStat::VT_STATE, state, 0);
  }
  void add_direction(int32_t direction) {
    fbb_.AddElement<int32_t>(SpindleStat::VT_DIRECTION, direction, 0);
  }
  void add_is_brake_engaged(bool is_brake_engaged) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_BRAKE_ENGAGED, static_cast<uint8_t>(is_brake_engaged), 0);
  }
  void add_is_increasing(bool is_increasing) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_INCREASING, static_cast<uint8_t>(is_increasing), 0);
  }
  void add_is_decreasing(bool is_decreasing) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_DECREASING, static_cast<uint8_t>(is_decreasing), 0);
  }
  void add_is_enabled(bool is_enabled) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_ENABLED, static_cast<uint8_t>(is_enabled), 0);
  }
  void add_orient_state(int32_t orient_state) {
    fbb_.AddElement<int32_t>(SpindleStat::VT_ORIENT_STATE, orient_state, 0);
  }
  void add_orient_fault(int32_t orient_fault) {
    fbb_.AddElement<int32_t>(SpindleStat::VT_ORIENT_FAULT, orient_fault, 0);
  }
  void add_is_spindle_override_enabled(bool is_spindle_override_enabled) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_SPINDLE_OVERRIDE_ENABLED, static_cast<uint8_t>(is_spindle_override_enabled), 0);
  }
  void add_is_homed(bool is_homed) {
    fbb_.AddElement<uint8_t>(SpindleStat::VT_IS_HOMED, static_cast<uint8_t>(is_homed), 0);
  }
  explicit SpindleStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpindleStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpindleStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpindleStat> CreateSpindleStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    double speed = 0.0,
    double spindle_scale = 0.0,
    double css_maximum = 0.0,
    double css_factor = 0.0,
    int32_t state = 0,
    int32_t direction = 0,
    bool is_brake_engaged = false,
    bool is_increasing = false,
    bool is_decreasing = false,
    bool is_enabled = false,
    int32_t orient_state = 0,
    int32_t orient_fault = 0,
    bool is_spindle_override_enabled = false,
    bool is_homed = false) {
  SpindleStatBuilder builder_(_fbb);
  builder_.add_css_factor(css_factor);
  builder_.add_css_maximum(css_maximum);
  builder_.add_spindle_scale(spindle_scale);
  builder_.add_speed(speed);
  builder_.add_orient_fault(orient_fault);
  builder_.add_orient_state(orient_state);
  builder_.add_direction(direction);
  builder_.add_state(state);
  builder_.add_is_homed(is_homed);
  builder_.add_is_spindle_override_enabled(is_spindle_override_enabled);
  builder_.add_is_enabled(is_enabled);
  builder_.add_is_decreasing(is_decreasing);
  builder_.add_is_increasing(is_increasing);
  builder_.add_is_brake_engaged(is_brake_engaged);
  return builder_.Finish();
}

flatbuffers::Offset<SpindleStat> CreateSpindleStat(flatbuffers::FlatBufferBuilder &_fbb, const SpindleStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MotionStatT : public flatbuffers::NativeTable {
  typedef MotionStat TableType;
  std::unique_ptr<EMC::TrajStatT> traj;
  std::vector<std::unique_ptr<EMC::JointStatT>> joint;
  std::vector<std::unique_ptr<EMC::AxisStatT>> axis;
  std::vector<std::unique_ptr<EMC::SpindleStatT>> spindle;
  std::vector<bool> synch_di;
  std::vector<bool> synch_do;
  std::vector<double> analog_input;
  std::vector<double> analog_output;
  std::vector<int32_t> misc_error;
  int32_t debug;
  bool is_on_soft_limit;
  bool is_external_offsets_applied;
  std::unique_ptr<EMC::Pose> eoffset_pose;
  int32_t num_extra_joints;
  bool is_jogging_active;
  MotionStatT()
      : debug(0),
        is_on_soft_limit(false),
        is_external_offsets_applied(false),
        num_extra_joints(0),
        is_jogging_active(false) {
  }
};

struct MotionStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MotionStatT NativeTableType;
  typedef MotionStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAJ = 4,
    VT_JOINT = 6,
    VT_AXIS = 8,
    VT_SPINDLE = 10,
    VT_SYNCH_DI = 12,
    VT_SYNCH_DO = 14,
    VT_ANALOG_INPUT = 16,
    VT_ANALOG_OUTPUT = 18,
    VT_MISC_ERROR = 20,
    VT_DEBUG = 22,
    VT_IS_ON_SOFT_LIMIT = 24,
    VT_IS_EXTERNAL_OFFSETS_APPLIED = 26,
    VT_EOFFSET_POSE = 28,
    VT_NUM_EXTRA_JOINTS = 30,
    VT_IS_JOGGING_ACTIVE = 32
  };
  const EMC::TrajStat *traj() const {
    return GetPointer<const EMC::TrajStat *>(VT_TRAJ);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EMC::JointStat>> *joint() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EMC::JointStat>> *>(VT_JOINT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EMC::AxisStat>> *axis() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EMC::AxisStat>> *>(VT_AXIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EMC::SpindleStat>> *spindle() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EMC::SpindleStat>> *>(VT_SPINDLE);
  }
  const flatbuffers::Vector<uint8_t> *synch_di() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SYNCH_DI);
  }
  const flatbuffers::Vector<uint8_t> *synch_do() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SYNCH_DO);
  }
  const flatbuffers::Vector<double> *analog_input() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ANALOG_INPUT);
  }
  const flatbuffers::Vector<double> *analog_output() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ANALOG_OUTPUT);
  }
  const flatbuffers::Vector<int32_t> *misc_error() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MISC_ERROR);
  }
  int32_t debug() const {
    return GetField<int32_t>(VT_DEBUG, 0);
  }
  bool is_on_soft_limit() const {
    return GetField<uint8_t>(VT_IS_ON_SOFT_LIMIT, 0) != 0;
  }
  bool is_external_offsets_applied() const {
    return GetField<uint8_t>(VT_IS_EXTERNAL_OFFSETS_APPLIED, 0) != 0;
  }
  const EMC::Pose *eoffset_pose() const {
    return GetStruct<const EMC::Pose *>(VT_EOFFSET_POSE);
  }
  int32_t num_extra_joints() const {
    return GetField<int32_t>(VT_NUM_EXTRA_JOINTS, 0);
  }
  bool is_jogging_active() const {
    return GetField<uint8_t>(VT_IS_JOGGING_ACTIVE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAJ) &&
           verifier.VerifyTable(traj()) &&
           VerifyOffset(verifier, VT_JOINT) &&
           verifier.VerifyVector(joint()) &&
           verifier.VerifyVectorOfTables(joint()) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.VerifyVectorOfTables(axis()) &&
           VerifyOffset(verifier, VT_SPINDLE) &&
           verifier.VerifyVector(spindle()) &&
           verifier.VerifyVectorOfTables(spindle()) &&
           VerifyOffset(verifier, VT_SYNCH_DI) &&
           verifier.VerifyVector(synch_di()) &&
           VerifyOffset(verifier, VT_SYNCH_DO) &&
           verifier.VerifyVector(synch_do()) &&
           VerifyOffset(verifier, VT_ANALOG_INPUT) &&
           verifier.VerifyVector(analog_input()) &&
           VerifyOffset(verifier, VT_ANALOG_OUTPUT) &&
           verifier.VerifyVector(analog_output()) &&
           VerifyOffset(verifier, VT_MISC_ERROR) &&
           verifier.VerifyVector(misc_error()) &&
           VerifyField<int32_t>(verifier, VT_DEBUG) &&
           VerifyField<uint8_t>(verifier, VT_IS_ON_SOFT_LIMIT) &&
           VerifyField<uint8_t>(verifier, VT_IS_EXTERNAL_OFFSETS_APPLIED) &&
           VerifyField<EMC::Pose>(verifier, VT_EOFFSET_POSE) &&
           VerifyField<int32_t>(verifier, VT_NUM_EXTRA_JOINTS) &&
           VerifyField<uint8_t>(verifier, VT_IS_JOGGING_ACTIVE) &&
           verifier.EndTable();
  }
  MotionStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MotionStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MotionStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotionStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MotionStatBuilder {
  typedef MotionStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traj(flatbuffers::Offset<EMC::TrajStat> traj) {
    fbb_.AddOffset(MotionStat::VT_TRAJ, traj);
  }
  void add_joint(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::JointStat>>> joint) {
    fbb_.AddOffset(MotionStat::VT_JOINT, joint);
  }
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::AxisStat>>> axis) {
    fbb_.AddOffset(MotionStat::VT_AXIS, axis);
  }
  void add_spindle(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::SpindleStat>>> spindle) {
    fbb_.AddOffset(MotionStat::VT_SPINDLE, spindle);
  }
  void add_synch_di(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> synch_di) {
    fbb_.AddOffset(MotionStat::VT_SYNCH_DI, synch_di);
  }
  void add_synch_do(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> synch_do) {
    fbb_.AddOffset(MotionStat::VT_SYNCH_DO, synch_do);
  }
  void add_analog_input(flatbuffers::Offset<flatbuffers::Vector<double>> analog_input) {
    fbb_.AddOffset(MotionStat::VT_ANALOG_INPUT, analog_input);
  }
  void add_analog_output(flatbuffers::Offset<flatbuffers::Vector<double>> analog_output) {
    fbb_.AddOffset(MotionStat::VT_ANALOG_OUTPUT, analog_output);
  }
  void add_misc_error(flatbuffers::Offset<flatbuffers::Vector<int32_t>> misc_error) {
    fbb_.AddOffset(MotionStat::VT_MISC_ERROR, misc_error);
  }
  void add_debug(int32_t debug) {
    fbb_.AddElement<int32_t>(MotionStat::VT_DEBUG, debug, 0);
  }
  void add_is_on_soft_limit(bool is_on_soft_limit) {
    fbb_.AddElement<uint8_t>(MotionStat::VT_IS_ON_SOFT_LIMIT, static_cast<uint8_t>(is_on_soft_limit), 0);
  }
  void add_is_external_offsets_applied(bool is_external_offsets_applied) {
    fbb_.AddElement<uint8_t>(MotionStat::VT_IS_EXTERNAL_OFFSETS_APPLIED, static_cast<uint8_t>(is_external_offsets_applied), 0);
  }
  void add_eoffset_pose(const EMC::Pose *eoffset_pose) {
    fbb_.AddStruct(MotionStat::VT_EOFFSET_POSE, eoffset_pose);
  }
  void add_num_extra_joints(int32_t num_extra_joints) {
    fbb_.AddElement<int32_t>(MotionStat::VT_NUM_EXTRA_JOINTS, num_extra_joints, 0);
  }
  void add_is_jogging_active(bool is_jogging_active) {
    fbb_.AddElement<uint8_t>(MotionStat::VT_IS_JOGGING_ACTIVE, static_cast<uint8_t>(is_jogging_active), 0);
  }
  explicit MotionStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MotionStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MotionStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<MotionStat> CreateMotionStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<EMC::TrajStat> traj = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::JointStat>>> joint = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::AxisStat>>> axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EMC::SpindleStat>>> spindle = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> synch_di = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> synch_do = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> analog_input = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> analog_output = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> misc_error = 0,
    int32_t debug = 0,
    bool is_on_soft_limit = false,
    bool is_external_offsets_applied = false,
    const EMC::Pose *eoffset_pose = 0,
    int32_t num_extra_joints = 0,
    bool is_jogging_active = false) {
  MotionStatBuilder builder_(_fbb);
  builder_.add_num_extra_joints(num_extra_joints);
  builder_.add_eoffset_pose(eoffset_pose);
  builder_.add_debug(debug);
  builder_.add_misc_error(misc_error);
  builder_.add_analog_output(analog_output);
  builder_.add_analog_input(analog_input);
  builder_.add_synch_do(synch_do);
  builder_.add_synch_di(synch_di);
  builder_.add_spindle(spindle);
  builder_.add_axis(axis);
  builder_.add_joint(joint);
  builder_.add_traj(traj);
  builder_.add_is_jogging_active(is_jogging_active);
  builder_.add_is_external_offsets_applied(is_external_offsets_applied);
  builder_.add_is_on_soft_limit(is_on_soft_limit);
  return builder_.Finish();
}

inline flatbuffers::Offset<MotionStat> CreateMotionStatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<EMC::TrajStat> traj = 0,
    const std::vector<flatbuffers::Offset<EMC::JointStat>> *joint = nullptr,
    const std::vector<flatbuffers::Offset<EMC::AxisStat>> *axis = nullptr,
    const std::vector<flatbuffers::Offset<EMC::SpindleStat>> *spindle = nullptr,
    const std::vector<uint8_t> *synch_di = nullptr,
    const std::vector<uint8_t> *synch_do = nullptr,
    const std::vector<double> *analog_input = nullptr,
    const std::vector<double> *analog_output = nullptr,
    const std::vector<int32_t> *misc_error = nullptr,
    int32_t debug = 0,
    bool is_on_soft_limit = false,
    bool is_external_offsets_applied = false,
    const EMC::Pose *eoffset_pose = 0,
    int32_t num_extra_joints = 0,
    bool is_jogging_active = false) {
  auto joint__ = joint ? _fbb.CreateVector<flatbuffers::Offset<EMC::JointStat>>(*joint) : 0;
  auto axis__ = axis ? _fbb.CreateVector<flatbuffers::Offset<EMC::AxisStat>>(*axis) : 0;
  auto spindle__ = spindle ? _fbb.CreateVector<flatbuffers::Offset<EMC::SpindleStat>>(*spindle) : 0;
  auto synch_di__ = synch_di ? _fbb.CreateVector<uint8_t>(*synch_di) : 0;
  auto synch_do__ = synch_do ? _fbb.CreateVector<uint8_t>(*synch_do) : 0;
  auto analog_input__ = analog_input ? _fbb.CreateVector<double>(*analog_input) : 0;
  auto analog_output__ = analog_output ? _fbb.CreateVector<double>(*analog_output) : 0;
  auto misc_error__ = misc_error ? _fbb.CreateVector<int32_t>(*misc_error) : 0;
  return EMC::CreateMotionStat(
      _fbb,
      traj,
      joint__,
      axis__,
      spindle__,
      synch_di__,
      synch_do__,
      analog_input__,
      analog_output__,
      misc_error__,
      debug,
      is_on_soft_limit,
      is_external_offsets_applied,
      eoffset_pose,
      num_extra_joints,
      is_jogging_active);
}

flatbuffers::Offset<MotionStat> CreateMotionStat(flatbuffers::FlatBufferBuilder &_fbb, const MotionStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskStatT : public flatbuffers::NativeTable {
  typedef TaskStat TableType;
  int32_t mode;
  int32_t state;
  int32_t exec_state;
  int32_t interp_state;
  int32_t call_level;
  int32_t motion_line;
  int32_t current_line;
  int32_t read_line;
  bool is_optional_stop_state;
  bool is_block_delete_state;
  bool is_input_timeout;
  std::string filename;
  std::string command;
  std::string ini_filename;
  int32_t g5x_index;
  std::unique_ptr<EMC::Pose> g92_offset;
  double rotation_xy;
  std::unique_ptr<EMC::Pose> tool_offset;
  std::vector<int32_t> active_g_codes;
  std::vector<int32_t> active_m_codes;
  std::vector<double> active_settings;
  int32_t interpreter_error_code;
  bool is_task_paused;
  double delay_left;
  int32_t queued_mdi_commands;
  TaskStatT()
      : mode(0),
        state(0),
        exec_state(0),
        interp_state(0),
        call_level(0),
        motion_line(0),
        current_line(0),
        read_line(0),
        is_optional_stop_state(false),
        is_block_delete_state(false),
        is_input_timeout(false),
        g5x_index(0),
        rotation_xy(0.0),
        interpreter_error_code(0),
        is_task_paused(false),
        delay_left(0.0),
        queued_mdi_commands(0) {
  }
};

struct TaskStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskStatT NativeTableType;
  typedef TaskStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_STATE = 6,
    VT_EXEC_STATE = 8,
    VT_INTERP_STATE = 10,
    VT_CALL_LEVEL = 12,
    VT_MOTION_LINE = 14,
    VT_CURRENT_LINE = 16,
    VT_READ_LINE = 18,
    VT_IS_OPTIONAL_STOP_STATE = 20,
    VT_IS_BLOCK_DELETE_STATE = 22,
    VT_IS_INPUT_TIMEOUT = 24,
    VT_FILENAME = 26,
    VT_COMMAND = 28,
    VT_INI_FILENAME = 30,
    VT_G5X_INDEX = 32,
    VT_G92_OFFSET = 34,
    VT_ROTATION_XY = 36,
    VT_TOOL_OFFSET = 38,
    VT_ACTIVE_G_CODES = 40,
    VT_ACTIVE_M_CODES = 42,
    VT_ACTIVE_SETTINGS = 44,
    VT_INTERPRETER_ERROR_CODE = 46,
    VT_IS_TASK_PAUSED = 48,
    VT_DELAY_LEFT = 50,
    VT_QUEUED_MDI_COMMANDS = 52
  };
  int32_t mode() const {
    return GetField<int32_t>(VT_MODE, 0);
  }
  int32_t state() const {
    return GetField<int32_t>(VT_STATE, 0);
  }
  int32_t exec_state() const {
    return GetField<int32_t>(VT_EXEC_STATE, 0);
  }
  int32_t interp_state() const {
    return GetField<int32_t>(VT_INTERP_STATE, 0);
  }
  int32_t call_level() const {
    return GetField<int32_t>(VT_CALL_LEVEL, 0);
  }
  int32_t motion_line() const {
    return GetField<int32_t>(VT_MOTION_LINE, 0);
  }
  int32_t current_line() const {
    return GetField<int32_t>(VT_CURRENT_LINE, 0);
  }
  int32_t read_line() const {
    return GetField<int32_t>(VT_READ_LINE, 0);
  }
  bool is_optional_stop_state() const {
    return GetField<uint8_t>(VT_IS_OPTIONAL_STOP_STATE, 0) != 0;
  }
  bool is_block_delete_state() const {
    return GetField<uint8_t>(VT_IS_BLOCK_DELETE_STATE, 0) != 0;
  }
  bool is_input_timeout() const {
    return GetField<uint8_t>(VT_IS_INPUT_TIMEOUT, 0) != 0;
  }
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  const flatbuffers::String *ini_filename() const {
    return GetPointer<const flatbuffers::String *>(VT_INI_FILENAME);
  }
  int32_t g5x_index() const {
    return GetField<int32_t>(VT_G5X_INDEX, 0);
  }
  const EMC::Pose *g92_offset() const {
    return GetStruct<const EMC::Pose *>(VT_G92_OFFSET);
  }
  double rotation_xy() const {
    return GetField<double>(VT_ROTATION_XY, 0.0);
  }
  const EMC::Pose *tool_offset() const {
    return GetStruct<const EMC::Pose *>(VT_TOOL_OFFSET);
  }
  const flatbuffers::Vector<int32_t> *active_g_codes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTIVE_G_CODES);
  }
  const flatbuffers::Vector<int32_t> *active_m_codes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTIVE_M_CODES);
  }
  const flatbuffers::Vector<double> *active_settings() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ACTIVE_SETTINGS);
  }
  int32_t interpreter_error_code() const {
    return GetField<int32_t>(VT_INTERPRETER_ERROR_CODE, 0);
  }
  bool is_task_paused() const {
    return GetField<uint8_t>(VT_IS_TASK_PAUSED, 0) != 0;
  }
  double delay_left() const {
    return GetField<double>(VT_DELAY_LEFT, 0.0);
  }
  int32_t queued_mdi_commands() const {
    return GetField<int32_t>(VT_QUEUED_MDI_COMMANDS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           VerifyField<int32_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_EXEC_STATE) &&
           VerifyField<int32_t>(verifier, VT_INTERP_STATE) &&
           VerifyField<int32_t>(verifier, VT_CALL_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MOTION_LINE) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_LINE) &&
           VerifyField<int32_t>(verifier, VT_READ_LINE) &&
           VerifyField<uint8_t>(verifier, VT_IS_OPTIONAL_STOP_STATE) &&
           VerifyField<uint8_t>(verifier, VT_IS_BLOCK_DELETE_STATE) &&
           VerifyField<uint8_t>(verifier, VT_IS_INPUT_TIMEOUT) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           VerifyOffset(verifier, VT_INI_FILENAME) &&
           verifier.VerifyString(ini_filename()) &&
           VerifyField<int32_t>(verifier, VT_G5X_INDEX) &&
           VerifyField<EMC::Pose>(verifier, VT_G92_OFFSET) &&
           VerifyField<double>(verifier, VT_ROTATION_XY) &&
           VerifyField<EMC::Pose>(verifier, VT_TOOL_OFFSET) &&
           VerifyOffset(verifier, VT_ACTIVE_G_CODES) &&
           verifier.VerifyVector(active_g_codes()) &&
           VerifyOffset(verifier, VT_ACTIVE_M_CODES) &&
           verifier.VerifyVector(active_m_codes()) &&
           VerifyOffset(verifier, VT_ACTIVE_SETTINGS) &&
           verifier.VerifyVector(active_settings()) &&
           VerifyField<int32_t>(verifier, VT_INTERPRETER_ERROR_CODE) &&
           VerifyField<uint8_t>(verifier, VT_IS_TASK_PAUSED) &&
           VerifyField<double>(verifier, VT_DELAY_LEFT) &&
           VerifyField<int32_t>(verifier, VT_QUEUED_MDI_COMMANDS) &&
           verifier.EndTable();
  }
  TaskStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TaskStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskStatBuilder {
  typedef TaskStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(int32_t mode) {
    fbb_.AddElement<int32_t>(TaskStat::VT_MODE, mode, 0);
  }
  void add_state(int32_t state) {
    fbb_.AddElement<int32_t>(TaskStat::VT_STATE, state, 0);
  }
  void add_exec_state(int32_t exec_state) {
    fbb_.AddElement<int32_t>(TaskStat::VT_EXEC_STATE, exec_state, 0);
  }
  void add_interp_state(int32_t interp_state) {
    fbb_.AddElement<int32_t>(TaskStat::VT_INTERP_STATE, interp_state, 0);
  }
  void add_call_level(int32_t call_level) {
    fbb_.AddElement<int32_t>(TaskStat::VT_CALL_LEVEL, call_level, 0);
  }
  void add_motion_line(int32_t motion_line) {
    fbb_.AddElement<int32_t>(TaskStat::VT_MOTION_LINE, motion_line, 0);
  }
  void add_current_line(int32_t current_line) {
    fbb_.AddElement<int32_t>(TaskStat::VT_CURRENT_LINE, current_line, 0);
  }
  void add_read_line(int32_t read_line) {
    fbb_.AddElement<int32_t>(TaskStat::VT_READ_LINE, read_line, 0);
  }
  void add_is_optional_stop_state(bool is_optional_stop_state) {
    fbb_.AddElement<uint8_t>(TaskStat::VT_IS_OPTIONAL_STOP_STATE, static_cast<uint8_t>(is_optional_stop_state), 0);
  }
  void add_is_block_delete_state(bool is_block_delete_state) {
    fbb_.AddElement<uint8_t>(TaskStat::VT_IS_BLOCK_DELETE_STATE, static_cast<uint8_t>(is_block_delete_state), 0);
  }
  void add_is_input_timeout(bool is_input_timeout) {
    fbb_.AddElement<uint8_t>(TaskStat::VT_IS_INPUT_TIMEOUT, static_cast<uint8_t>(is_input_timeout), 0);
  }
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(TaskStat::VT_FILENAME, filename);
  }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(TaskStat::VT_COMMAND, command);
  }
  void add_ini_filename(flatbuffers::Offset<flatbuffers::String> ini_filename) {
    fbb_.AddOffset(TaskStat::VT_INI_FILENAME, ini_filename);
  }
  void add_g5x_index(int32_t g5x_index) {
    fbb_.AddElement<int32_t>(TaskStat::VT_G5X_INDEX, g5x_index, 0);
  }
  void add_g92_offset(const EMC::Pose *g92_offset) {
    fbb_.AddStruct(TaskStat::VT_G92_OFFSET, g92_offset);
  }
  void add_rotation_xy(double rotation_xy) {
    fbb_.AddElement<double>(TaskStat::VT_ROTATION_XY, rotation_xy, 0.0);
  }
  void add_tool_offset(const EMC::Pose *tool_offset) {
    fbb_.AddStruct(TaskStat::VT_TOOL_OFFSET, tool_offset);
  }
  void add_active_g_codes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> active_g_codes) {
    fbb_.AddOffset(TaskStat::VT_ACTIVE_G_CODES, active_g_codes);
  }
  void add_active_m_codes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> active_m_codes) {
    fbb_.AddOffset(TaskStat::VT_ACTIVE_M_CODES, active_m_codes);
  }
  void add_active_settings(flatbuffers::Offset<flatbuffers::Vector<double>> active_settings) {
    fbb_.AddOffset(TaskStat::VT_ACTIVE_SETTINGS, active_settings);
  }
  void add_interpreter_error_code(int32_t interpreter_error_code) {
    fbb_.AddElement<int32_t>(TaskStat::VT_INTERPRETER_ERROR_CODE, interpreter_error_code, 0);
  }
  void add_is_task_paused(bool is_task_paused) {
    fbb_.AddElement<uint8_t>(TaskStat::VT_IS_TASK_PAUSED, static_cast<uint8_t>(is_task_paused), 0);
  }
  void add_delay_left(double delay_left) {
    fbb_.AddElement<double>(TaskStat::VT_DELAY_LEFT, delay_left, 0.0);
  }
  void add_queued_mdi_commands(int32_t queued_mdi_commands) {
    fbb_.AddElement<int32_t>(TaskStat::VT_QUEUED_MDI_COMMANDS, queued_mdi_commands, 0);
  }
  explicit TaskStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TaskStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskStat> CreateTaskStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mode = 0,
    int32_t state = 0,
    int32_t exec_state = 0,
    int32_t interp_state = 0,
    int32_t call_level = 0,
    int32_t motion_line = 0,
    int32_t current_line = 0,
    int32_t read_line = 0,
    bool is_optional_stop_state = false,
    bool is_block_delete_state = false,
    bool is_input_timeout = false,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::String> ini_filename = 0,
    int32_t g5x_index = 0,
    const EMC::Pose *g92_offset = 0,
    double rotation_xy = 0.0,
    const EMC::Pose *tool_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> active_g_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> active_m_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> active_settings = 0,
    int32_t interpreter_error_code = 0,
    bool is_task_paused = false,
    double delay_left = 0.0,
    int32_t queued_mdi_commands = 0) {
  TaskStatBuilder builder_(_fbb);
  builder_.add_delay_left(delay_left);
  builder_.add_rotation_xy(rotation_xy);
  builder_.add_queued_mdi_commands(queued_mdi_commands);
  builder_.add_interpreter_error_code(interpreter_error_code);
  builder_.add_active_settings(active_settings);
  builder_.add_active_m_codes(active_m_codes);
  builder_.add_active_g_codes(active_g_codes);
  builder_.add_tool_offset(tool_offset);
  builder_.add_g92_offset(g92_offset);
  builder_.add_g5x_index(g5x_index);
  builder_.add_ini_filename(ini_filename);
  builder_.add_command(command);
  builder_.add_filename(filename);
  builder_.add_read_line(read_line);
  builder_.add_current_line(current_line);
  builder_.add_motion_line(motion_line);
  builder_.add_call_level(call_level);
  builder_.add_interp_state(interp_state);
  builder_.add_exec_state(exec_state);
  builder_.add_state(state);
  builder_.add_mode(mode);
  builder_.add_is_task_paused(is_task_paused);
  builder_.add_is_input_timeout(is_input_timeout);
  builder_.add_is_block_delete_state(is_block_delete_state);
  builder_.add_is_optional_stop_state(is_optional_stop_state);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskStat> CreateTaskStatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t mode = 0,
    int32_t state = 0,
    int32_t exec_state = 0,
    int32_t interp_state = 0,
    int32_t call_level = 0,
    int32_t motion_line = 0,
    int32_t current_line = 0,
    int32_t read_line = 0,
    bool is_optional_stop_state = false,
    bool is_block_delete_state = false,
    bool is_input_timeout = false,
    const char *filename = nullptr,
    const char *command = nullptr,
    const char *ini_filename = nullptr,
    int32_t g5x_index = 0,
    const EMC::Pose *g92_offset = 0,
    double rotation_xy = 0.0,
    const EMC::Pose *tool_offset = 0,
    const std::vector<int32_t> *active_g_codes = nullptr,
    const std::vector<int32_t> *active_m_codes = nullptr,
    const std::vector<double> *active_settings = nullptr,
    int32_t interpreter_error_code = 0,
    bool is_task_paused = false,
    double delay_left = 0.0,
    int32_t queued_mdi_commands = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto command__ = command ? _fbb.CreateString(command) : 0;
  auto ini_filename__ = ini_filename ? _fbb.CreateString(ini_filename) : 0;
  auto active_g_codes__ = active_g_codes ? _fbb.CreateVector<int32_t>(*active_g_codes) : 0;
  auto active_m_codes__ = active_m_codes ? _fbb.CreateVector<int32_t>(*active_m_codes) : 0;
  auto active_settings__ = active_settings ? _fbb.CreateVector<double>(*active_settings) : 0;
  return EMC::CreateTaskStat(
      _fbb,
      mode,
      state,
      exec_state,
      interp_state,
      call_level,
      motion_line,
      current_line,
      read_line,
      is_optional_stop_state,
      is_block_delete_state,
      is_input_timeout,
      filename__,
      command__,
      ini_filename__,
      g5x_index,
      g92_offset,
      rotation_xy,
      tool_offset,
      active_g_codes__,
      active_m_codes__,
      active_settings__,
      interpreter_error_code,
      is_task_paused,
      delay_left,
      queued_mdi_commands);
}

flatbuffers::Offset<TaskStat> CreateTaskStat(flatbuffers::FlatBufferBuilder &_fbb, const TaskStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ToolStatT : public flatbuffers::NativeTable {
  typedef ToolStat TableType;
  int32_t pocket_prepped;
  int32_t tool_in_spindle;
  int32_t tool_from_pocket;
  ToolStatT()
      : pocket_prepped(0),
        tool_in_spindle(0),
        tool_from_pocket(0) {
  }
};

struct ToolStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ToolStatT NativeTableType;
  typedef ToolStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POCKET_PREPPED = 4,
    VT_TOOL_IN_SPINDLE = 6,
    VT_TOOL_FROM_POCKET = 8
  };
  int32_t pocket_prepped() const {
    return GetField<int32_t>(VT_POCKET_PREPPED, 0);
  }
  int32_t tool_in_spindle() const {
    return GetField<int32_t>(VT_TOOL_IN_SPINDLE, 0);
  }
  int32_t tool_from_pocket() const {
    return GetField<int32_t>(VT_TOOL_FROM_POCKET, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POCKET_PREPPED) &&
           VerifyField<int32_t>(verifier, VT_TOOL_IN_SPINDLE) &&
           VerifyField<int32_t>(verifier, VT_TOOL_FROM_POCKET) &&
           verifier.EndTable();
  }
  ToolStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ToolStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ToolStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToolStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ToolStatBuilder {
  typedef ToolStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pocket_prepped(int32_t pocket_prepped) {
    fbb_.AddElement<int32_t>(ToolStat::VT_POCKET_PREPPED, pocket_prepped, 0);
  }
  void add_tool_in_spindle(int32_t tool_in_spindle) {
    fbb_.AddElement<int32_t>(ToolStat::VT_TOOL_IN_SPINDLE, tool_in_spindle, 0);
  }
  void add_tool_from_pocket(int32_t tool_from_pocket) {
    fbb_.AddElement<int32_t>(ToolStat::VT_TOOL_FROM_POCKET, tool_from_pocket, 0);
  }
  explicit ToolStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ToolStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToolStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToolStat> CreateToolStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pocket_prepped = 0,
    int32_t tool_in_spindle = 0,
    int32_t tool_from_pocket = 0) {
  ToolStatBuilder builder_(_fbb);
  builder_.add_tool_from_pocket(tool_from_pocket);
  builder_.add_tool_in_spindle(tool_in_spindle);
  builder_.add_pocket_prepped(pocket_prepped);
  return builder_.Finish();
}

flatbuffers::Offset<ToolStat> CreateToolStat(flatbuffers::FlatBufferBuilder &_fbb, const ToolStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CoolantStatT : public flatbuffers::NativeTable {
  typedef CoolantStat TableType;
  bool is_mist;
  bool is_flood;
  CoolantStatT()
      : is_mist(false),
        is_flood(false) {
  }
};

struct CoolantStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CoolantStatT NativeTableType;
  typedef CoolantStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_MIST = 4,
    VT_IS_FLOOD = 6
  };
  bool is_mist() const {
    return GetField<uint8_t>(VT_IS_MIST, 0) != 0;
  }
  bool is_flood() const {
    return GetField<uint8_t>(VT_IS_FLOOD, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_MIST) &&
           VerifyField<uint8_t>(verifier, VT_IS_FLOOD) &&
           verifier.EndTable();
  }
  CoolantStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CoolantStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CoolantStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoolantStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CoolantStatBuilder {
  typedef CoolantStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_mist(bool is_mist) {
    fbb_.AddElement<uint8_t>(CoolantStat::VT_IS_MIST, static_cast<uint8_t>(is_mist), 0);
  }
  void add_is_flood(bool is_flood) {
    fbb_.AddElement<uint8_t>(CoolantStat::VT_IS_FLOOD, static_cast<uint8_t>(is_flood), 0);
  }
  explicit CoolantStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CoolantStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CoolantStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<CoolantStat> CreateCoolantStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_mist = false,
    bool is_flood = false) {
  CoolantStatBuilder builder_(_fbb);
  builder_.add_is_flood(is_flood);
  builder_.add_is_mist(is_mist);
  return builder_.Finish();
}

flatbuffers::Offset<CoolantStat> CreateCoolantStat(flatbuffers::FlatBufferBuilder &_fbb, const CoolantStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuxStatT : public flatbuffers::NativeTable {
  typedef AuxStat TableType;
  bool is_estopped;
  AuxStatT()
      : is_estopped(false) {
  }
};

struct AuxStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuxStatT NativeTableType;
  typedef AuxStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_ESTOPPED = 4
  };
  bool is_estopped() const {
    return GetField<uint8_t>(VT_IS_ESTOPPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_ESTOPPED) &&
           verifier.EndTable();
  }
  AuxStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuxStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuxStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuxStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuxStatBuilder {
  typedef AuxStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_estopped(bool is_estopped) {
    fbb_.AddElement<uint8_t>(AuxStat::VT_IS_ESTOPPED, static_cast<uint8_t>(is_estopped), 0);
  }
  explicit AuxStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AuxStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuxStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuxStat> CreateAuxStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_estopped = false) {
  AuxStatBuilder builder_(_fbb);
  builder_.add_is_estopped(is_estopped);
  return builder_.Finish();
}

flatbuffers::Offset<AuxStat> CreateAuxStat(flatbuffers::FlatBufferBuilder &_fbb, const AuxStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IOStatT : public flatbuffers::NativeTable {
  typedef IOStat TableType;
  int32_t debug;
  int32_t reason;
  int32_t fault;
  std::unique_ptr<EMC::ToolStatT> tool;
  std::unique_ptr<EMC::CoolantStatT> coolant;
  std::unique_ptr<EMC::AuxStatT> aux;
  IOStatT()
      : debug(0),
        reason(0),
        fault(0) {
  }
};

struct IOStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IOStatT NativeTableType;
  typedef IOStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG = 4,
    VT_REASON = 6,
    VT_FAULT = 8,
    VT_TOOL = 10,
    VT_COOLANT = 12,
    VT_AUX = 14
  };
  int32_t debug() const {
    return GetField<int32_t>(VT_DEBUG, 0);
  }
  int32_t reason() const {
    return GetField<int32_t>(VT_REASON, 0);
  }
  int32_t fault() const {
    return GetField<int32_t>(VT_FAULT, 0);
  }
  const EMC::ToolStat *tool() const {
    return GetPointer<const EMC::ToolStat *>(VT_TOOL);
  }
  const EMC::CoolantStat *coolant() const {
    return GetPointer<const EMC::CoolantStat *>(VT_COOLANT);
  }
  const EMC::AuxStat *aux() const {
    return GetPointer<const EMC::AuxStat *>(VT_AUX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEBUG) &&
           VerifyField<int32_t>(verifier, VT_REASON) &&
           VerifyField<int32_t>(verifier, VT_FAULT) &&
           VerifyOffset(verifier, VT_TOOL) &&
           verifier.VerifyTable(tool()) &&
           VerifyOffset(verifier, VT_COOLANT) &&
           verifier.VerifyTable(coolant()) &&
           VerifyOffset(verifier, VT_AUX) &&
           verifier.VerifyTable(aux()) &&
           verifier.EndTable();
  }
  IOStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IOStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IOStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IOStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IOStatBuilder {
  typedef IOStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug(int32_t debug) {
    fbb_.AddElement<int32_t>(IOStat::VT_DEBUG, debug, 0);
  }
  void add_reason(int32_t reason) {
    fbb_.AddElement<int32_t>(IOStat::VT_REASON, reason, 0);
  }
  void add_fault(int32_t fault) {
    fbb_.AddElement<int32_t>(IOStat::VT_FAULT, fault, 0);
  }
  void add_tool(flatbuffers::Offset<EMC::ToolStat> tool) {
    fbb_.AddOffset(IOStat::VT_TOOL, tool);
  }
  void add_coolant(flatbuffers::Offset<EMC::CoolantStat> coolant) {
    fbb_.AddOffset(IOStat::VT_COOLANT, coolant);
  }
  void add_aux(flatbuffers::Offset<EMC::AuxStat> aux) {
    fbb_.AddOffset(IOStat::VT_AUX, aux);
  }
  explicit IOStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IOStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IOStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<IOStat> CreateIOStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t debug = 0,
    int32_t reason = 0,
    int32_t fault = 0,
    flatbuffers::Offset<EMC::ToolStat> tool = 0,
    flatbuffers::Offset<EMC::CoolantStat> coolant = 0,
    flatbuffers::Offset<EMC::AuxStat> aux = 0) {
  IOStatBuilder builder_(_fbb);
  builder_.add_aux(aux);
  builder_.add_coolant(coolant);
  builder_.add_tool(tool);
  builder_.add_fault(fault);
  builder_.add_reason(reason);
  builder_.add_debug(debug);
  return builder_.Finish();
}

flatbuffers::Offset<IOStat> CreateIOStat(flatbuffers::FlatBufferBuilder &_fbb, const IOStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmcStatT : public flatbuffers::NativeTable {
  typedef EmcStat TableType;
  std::unique_ptr<EMC::TaskStatT> task;
  std::unique_ptr<EMC::MotionStatT> motion;
  std::unique_ptr<EMC::IOStatT> io;
  EmcStatT() {
  }
};

struct EmcStat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmcStatT NativeTableType;
  typedef EmcStatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASK = 4,
    VT_MOTION = 6,
    VT_IO = 8
  };
  const EMC::TaskStat *task() const {
    return GetPointer<const EMC::TaskStat *>(VT_TASK);
  }
  const EMC::MotionStat *motion() const {
    return GetPointer<const EMC::MotionStat *>(VT_MOTION);
  }
  const EMC::IOStat *io() const {
    return GetPointer<const EMC::IOStat *>(VT_IO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TASK) &&
           verifier.VerifyTable(task()) &&
           VerifyOffset(verifier, VT_MOTION) &&
           verifier.VerifyTable(motion()) &&
           VerifyOffset(verifier, VT_IO) &&
           verifier.VerifyTable(io()) &&
           verifier.EndTable();
  }
  EmcStatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmcStatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EmcStat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmcStatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmcStatBuilder {
  typedef EmcStat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task(flatbuffers::Offset<EMC::TaskStat> task) {
    fbb_.AddOffset(EmcStat::VT_TASK, task);
  }
  void add_motion(flatbuffers::Offset<EMC::MotionStat> motion) {
    fbb_.AddOffset(EmcStat::VT_MOTION, motion);
  }
  void add_io(flatbuffers::Offset<EMC::IOStat> io) {
    fbb_.AddOffset(EmcStat::VT_IO, io);
  }
  explicit EmcStatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmcStat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmcStat>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmcStat> CreateEmcStat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<EMC::TaskStat> task = 0,
    flatbuffers::Offset<EMC::MotionStat> motion = 0,
    flatbuffers::Offset<EMC::IOStat> io = 0) {
  EmcStatBuilder builder_(_fbb);
  builder_.add_io(io);
  builder_.add_motion(motion);
  builder_.add_task(task);
  return builder_.Finish();
}

flatbuffers::Offset<EmcStat> CreateEmcStat(flatbuffers::FlatBufferBuilder &_fbb, const EmcStatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AxisStatT *AxisStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::AxisStatT> _o = std::unique_ptr<EMC::AxisStatT>(new AxisStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AxisStat::UnPackTo(AxisStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; }
  { auto _e = min_position_limit(); _o->min_position_limit = _e; }
  { auto _e = max_position_limit(); _o->max_position_limit = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
}

inline flatbuffers::Offset<AxisStat> AxisStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AxisStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAxisStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AxisStat> CreateAxisStat(flatbuffers::FlatBufferBuilder &_fbb, const AxisStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AxisStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  auto _min_position_limit = _o->min_position_limit;
  auto _max_position_limit = _o->max_position_limit;
  auto _velocity = _o->velocity;
  return EMC::CreateAxisStat(
      _fbb,
      _axis,
      _min_position_limit,
      _max_position_limit,
      _velocity);
}

inline JointStatT *JointStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::JointStatT> _o = std::unique_ptr<EMC::JointStatT>(new JointStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JointStat::UnPackTo(JointStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = joint(); _o->joint = _e; }
  { auto _e = joint_type(); _o->joint_type = _e; }
  { auto _e = units(); _o->units = _e; }
  { auto _e = backlash(); _o->backlash = _e; }
  { auto _e = min_position_limit(); _o->min_position_limit = _e; }
  { auto _e = max_position_limit(); _o->max_position_limit = _e; }
  { auto _e = max_ferror(); _o->max_ferror = _e; }
  { auto _e = min_ferror(); _o->min_ferror = _e; }
  { auto _e = ferror_count(); _o->ferror_count = _e; }
  { auto _e = ferror_high_mark(); _o->ferror_high_mark = _e; }
  { auto _e = output(); _o->output = _e; }
  { auto _e = input(); _o->input = _e; }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = is_in_position(); _o->is_in_position = _e; }
  { auto _e = is_homing(); _o->is_homing = _e; }
  { auto _e = is_homed(); _o->is_homed = _e; }
  { auto _e = is_fault(); _o->is_fault = _e; }
  { auto _e = is_enabled(); _o->is_enabled = _e; }
  { auto _e = is_min_soft_limit_exceeded(); _o->is_min_soft_limit_exceeded = _e; }
  { auto _e = is_max_soft_limit_exceeded(); _o->is_max_soft_limit_exceeded = _e; }
  { auto _e = is_min_hard_limit_exceeded(); _o->is_min_hard_limit_exceeded = _e; }
  { auto _e = is_max_hard_limit_exceeded(); _o->is_max_hard_limit_exceeded = _e; }
  { auto _e = is_override_limits(); _o->is_override_limits = _e; }
}

inline flatbuffers::Offset<JointStat> JointStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJointStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JointStat> CreateJointStat(flatbuffers::FlatBufferBuilder &_fbb, const JointStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JointStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _joint = _o->joint;
  auto _joint_type = _o->joint_type;
  auto _units = _o->units;
  auto _backlash = _o->backlash;
  auto _min_position_limit = _o->min_position_limit;
  auto _max_position_limit = _o->max_position_limit;
  auto _max_ferror = _o->max_ferror;
  auto _min_ferror = _o->min_ferror;
  auto _ferror_count = _o->ferror_count;
  auto _ferror_high_mark = _o->ferror_high_mark;
  auto _output = _o->output;
  auto _input = _o->input;
  auto _velocity = _o->velocity;
  auto _is_in_position = _o->is_in_position;
  auto _is_homing = _o->is_homing;
  auto _is_homed = _o->is_homed;
  auto _is_fault = _o->is_fault;
  auto _is_enabled = _o->is_enabled;
  auto _is_min_soft_limit_exceeded = _o->is_min_soft_limit_exceeded;
  auto _is_max_soft_limit_exceeded = _o->is_max_soft_limit_exceeded;
  auto _is_min_hard_limit_exceeded = _o->is_min_hard_limit_exceeded;
  auto _is_max_hard_limit_exceeded = _o->is_max_hard_limit_exceeded;
  auto _is_override_limits = _o->is_override_limits;
  return EMC::CreateJointStat(
      _fbb,
      _joint,
      _joint_type,
      _units,
      _backlash,
      _min_position_limit,
      _max_position_limit,
      _max_ferror,
      _min_ferror,
      _ferror_count,
      _ferror_high_mark,
      _output,
      _input,
      _velocity,
      _is_in_position,
      _is_homing,
      _is_homed,
      _is_fault,
      _is_enabled,
      _is_min_soft_limit_exceeded,
      _is_max_soft_limit_exceeded,
      _is_min_hard_limit_exceeded,
      _is_max_hard_limit_exceeded,
      _is_override_limits);
}

inline TrajStatT *TrajStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::TrajStatT> _o = std::unique_ptr<EMC::TrajStatT>(new TrajStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TrajStat::UnPackTo(TrajStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = linear_units(); _o->linear_units = _e; }
  { auto _e = angular_units(); _o->angular_units = _e; }
  { auto _e = cycle_time(); _o->cycle_time = _e; }
  { auto _e = joints(); _o->joints = _e; }
  { auto _e = spindles(); _o->spindles = _e; }
  { auto _e = axis_mask(); _o->axis_mask = _e; }
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = is_enabled(); _o->is_enabled = _e; }
  { auto _e = is_in_position(); _o->is_in_position = _e; }
  { auto _e = queue(); _o->queue = _e; }
  { auto _e = active_queue(); _o->active_queue = _e; }
  { auto _e = is_queue_full(); _o->is_queue_full = _e; }
  { auto _e = id(); _o->id = _e; }
  { auto _e = is_paused(); _o->is_paused = _e; }
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = rapid_scale(); _o->rapid_scale = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = actual_position(); if (_e) _o->actual_position = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = velocity(); _o->velocity = _e; }
  { auto _e = acceleration(); _o->acceleration = _e; }
  { auto _e = max_velocity(); _o->max_velocity = _e; }
  { auto _e = max_acceleration(); _o->max_acceleration = _e; }
  { auto _e = probed_position(); if (_e) _o->probed_position = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = is_probe_tripped(); _o->is_probe_tripped = _e; }
  { auto _e = is_probing(); _o->is_probing = _e; }
  { auto _e = probeval(); _o->probeval = _e; }
  { auto _e = kinematics_type(); _o->kinematics_type = _e; }
  { auto _e = motion_type(); _o->motion_type = _e; }
  { auto _e = linear_distance_to_go(); _o->linear_distance_to_go = _e; }
  { auto _e = distance_to_go(); if (_e) _o->distance_to_go = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = current_vel(); _o->current_vel = _e; }
  { auto _e = is_feed_override_enabled(); _o->is_feed_override_enabled = _e; }
  { auto _e = is_adaptive_feed_enabled(); _o->is_adaptive_feed_enabled = _e; }
}

inline flatbuffers::Offset<TrajStat> TrajStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrajStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrajStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrajStat> CreateTrajStat(flatbuffers::FlatBufferBuilder &_fbb, const TrajStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrajStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _linear_units = _o->linear_units;
  auto _angular_units = _o->angular_units;
  auto _cycle_time = _o->cycle_time;
  auto _joints = _o->joints;
  auto _spindles = _o->spindles;
  auto _axis_mask = _o->axis_mask;
  auto _mode = _o->mode;
  auto _is_enabled = _o->is_enabled;
  auto _is_in_position = _o->is_in_position;
  auto _queue = _o->queue;
  auto _active_queue = _o->active_queue;
  auto _is_queue_full = _o->is_queue_full;
  auto _id = _o->id;
  auto _is_paused = _o->is_paused;
  auto _scale = _o->scale;
  auto _rapid_scale = _o->rapid_scale;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _actual_position = _o->actual_position ? _o->actual_position.get() : 0;
  auto _velocity = _o->velocity;
  auto _acceleration = _o->acceleration;
  auto _max_velocity = _o->max_velocity;
  auto _max_acceleration = _o->max_acceleration;
  auto _probed_position = _o->probed_position ? _o->probed_position.get() : 0;
  auto _is_probe_tripped = _o->is_probe_tripped;
  auto _is_probing = _o->is_probing;
  auto _probeval = _o->probeval;
  auto _kinematics_type = _o->kinematics_type;
  auto _motion_type = _o->motion_type;
  auto _linear_distance_to_go = _o->linear_distance_to_go;
  auto _distance_to_go = _o->distance_to_go ? _o->distance_to_go.get() : 0;
  auto _current_vel = _o->current_vel;
  auto _is_feed_override_enabled = _o->is_feed_override_enabled;
  auto _is_adaptive_feed_enabled = _o->is_adaptive_feed_enabled;
  return EMC::CreateTrajStat(
      _fbb,
      _linear_units,
      _angular_units,
      _cycle_time,
      _joints,
      _spindles,
      _axis_mask,
      _mode,
      _is_enabled,
      _is_in_position,
      _queue,
      _active_queue,
      _is_queue_full,
      _id,
      _is_paused,
      _scale,
      _rapid_scale,
      _position,
      _actual_position,
      _velocity,
      _acceleration,
      _max_velocity,
      _max_acceleration,
      _probed_position,
      _is_probe_tripped,
      _is_probing,
      _probeval,
      _kinematics_type,
      _motion_type,
      _linear_distance_to_go,
      _distance_to_go,
      _current_vel,
      _is_feed_override_enabled,
      _is_adaptive_feed_enabled);
}

inline SpindleStatT *SpindleStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::SpindleStatT> _o = std::unique_ptr<EMC::SpindleStatT>(new SpindleStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpindleStat::UnPackTo(SpindleStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = spindle_scale(); _o->spindle_scale = _e; }
  { auto _e = css_maximum(); _o->css_maximum = _e; }
  { auto _e = css_factor(); _o->css_factor = _e; }
  { auto _e = state(); _o->state = _e; }
  { auto _e = direction(); _o->direction = _e; }
  { auto _e = is_brake_engaged(); _o->is_brake_engaged = _e; }
  { auto _e = is_increasing(); _o->is_increasing = _e; }
  { auto _e = is_decreasing(); _o->is_decreasing = _e; }
  { auto _e = is_enabled(); _o->is_enabled = _e; }
  { auto _e = orient_state(); _o->orient_state = _e; }
  { auto _e = orient_fault(); _o->orient_fault = _e; }
  { auto _e = is_spindle_override_enabled(); _o->is_spindle_override_enabled = _e; }
  { auto _e = is_homed(); _o->is_homed = _e; }
}

inline flatbuffers::Offset<SpindleStat> SpindleStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpindleStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpindleStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpindleStat> CreateSpindleStat(flatbuffers::FlatBufferBuilder &_fbb, const SpindleStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpindleStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _speed = _o->speed;
  auto _spindle_scale = _o->spindle_scale;
  auto _css_maximum = _o->css_maximum;
  auto _css_factor = _o->css_factor;
  auto _state = _o->state;
  auto _direction = _o->direction;
  auto _is_brake_engaged = _o->is_brake_engaged;
  auto _is_increasing = _o->is_increasing;
  auto _is_decreasing = _o->is_decreasing;
  auto _is_enabled = _o->is_enabled;
  auto _orient_state = _o->orient_state;
  auto _orient_fault = _o->orient_fault;
  auto _is_spindle_override_enabled = _o->is_spindle_override_enabled;
  auto _is_homed = _o->is_homed;
  return EMC::CreateSpindleStat(
      _fbb,
      _speed,
      _spindle_scale,
      _css_maximum,
      _css_factor,
      _state,
      _direction,
      _is_brake_engaged,
      _is_increasing,
      _is_decreasing,
      _is_enabled,
      _orient_state,
      _orient_fault,
      _is_spindle_override_enabled,
      _is_homed);
}

inline MotionStatT *MotionStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::MotionStatT> _o = std::unique_ptr<EMC::MotionStatT>(new MotionStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MotionStat::UnPackTo(MotionStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = traj(); if (_e) _o->traj = std::unique_ptr<EMC::TrajStatT>(_e->UnPack(_resolver)); }
  { auto _e = joint(); if (_e) { _o->joint.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->joint[_i] = std::unique_ptr<EMC::JointStatT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = axis(); if (_e) { _o->axis.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->axis[_i] = std::unique_ptr<EMC::AxisStatT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = spindle(); if (_e) { _o->spindle.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spindle[_i] = std::unique_ptr<EMC::SpindleStatT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = synch_di(); if (_e) { _o->synch_di.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->synch_di[_i] = _e->Get(_i) != 0; } } }
  { auto _e = synch_do(); if (_e) { _o->synch_do.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->synch_do[_i] = _e->Get(_i) != 0; } } }
  { auto _e = analog_input(); if (_e) { _o->analog_input.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->analog_input[_i] = _e->Get(_i); } } }
  { auto _e = analog_output(); if (_e) { _o->analog_output.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->analog_output[_i] = _e->Get(_i); } } }
  { auto _e = misc_error(); if (_e) { _o->misc_error.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->misc_error[_i] = _e->Get(_i); } } }
  { auto _e = debug(); _o->debug = _e; }
  { auto _e = is_on_soft_limit(); _o->is_on_soft_limit = _e; }
  { auto _e = is_external_offsets_applied(); _o->is_external_offsets_applied = _e; }
  { auto _e = eoffset_pose(); if (_e) _o->eoffset_pose = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = num_extra_joints(); _o->num_extra_joints = _e; }
  { auto _e = is_jogging_active(); _o->is_jogging_active = _e; }
}

inline flatbuffers::Offset<MotionStat> MotionStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MotionStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMotionStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MotionStat> CreateMotionStat(flatbuffers::FlatBufferBuilder &_fbb, const MotionStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MotionStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _traj = _o->traj ? CreateTrajStat(_fbb, _o->traj.get(), _rehasher) : 0;
  auto _joint = _o->joint.size() ? _fbb.CreateVector<flatbuffers::Offset<EMC::JointStat>> (_o->joint.size(), [](size_t i, _VectorArgs *__va) { return CreateJointStat(*__va->__fbb, __va->__o->joint[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _axis = _o->axis.size() ? _fbb.CreateVector<flatbuffers::Offset<EMC::AxisStat>> (_o->axis.size(), [](size_t i, _VectorArgs *__va) { return CreateAxisStat(*__va->__fbb, __va->__o->axis[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _spindle = _o->spindle.size() ? _fbb.CreateVector<flatbuffers::Offset<EMC::SpindleStat>> (_o->spindle.size(), [](size_t i, _VectorArgs *__va) { return CreateSpindleStat(*__va->__fbb, __va->__o->spindle[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _synch_di = _o->synch_di.size() ? _fbb.CreateVector(_o->synch_di) : 0;
  auto _synch_do = _o->synch_do.size() ? _fbb.CreateVector(_o->synch_do) : 0;
  auto _analog_input = _o->analog_input.size() ? _fbb.CreateVector(_o->analog_input) : 0;
  auto _analog_output = _o->analog_output.size() ? _fbb.CreateVector(_o->analog_output) : 0;
  auto _misc_error = _o->misc_error.size() ? _fbb.CreateVector(_o->misc_error) : 0;
  auto _debug = _o->debug;
  auto _is_on_soft_limit = _o->is_on_soft_limit;
  auto _is_external_offsets_applied = _o->is_external_offsets_applied;
  auto _eoffset_pose = _o->eoffset_pose ? _o->eoffset_pose.get() : 0;
  auto _num_extra_joints = _o->num_extra_joints;
  auto _is_jogging_active = _o->is_jogging_active;
  return EMC::CreateMotionStat(
      _fbb,
      _traj,
      _joint,
      _axis,
      _spindle,
      _synch_di,
      _synch_do,
      _analog_input,
      _analog_output,
      _misc_error,
      _debug,
      _is_on_soft_limit,
      _is_external_offsets_applied,
      _eoffset_pose,
      _num_extra_joints,
      _is_jogging_active);
}

inline TaskStatT *TaskStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::TaskStatT> _o = std::unique_ptr<EMC::TaskStatT>(new TaskStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaskStat::UnPackTo(TaskStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); _o->mode = _e; }
  { auto _e = state(); _o->state = _e; }
  { auto _e = exec_state(); _o->exec_state = _e; }
  { auto _e = interp_state(); _o->interp_state = _e; }
  { auto _e = call_level(); _o->call_level = _e; }
  { auto _e = motion_line(); _o->motion_line = _e; }
  { auto _e = current_line(); _o->current_line = _e; }
  { auto _e = read_line(); _o->read_line = _e; }
  { auto _e = is_optional_stop_state(); _o->is_optional_stop_state = _e; }
  { auto _e = is_block_delete_state(); _o->is_block_delete_state = _e; }
  { auto _e = is_input_timeout(); _o->is_input_timeout = _e; }
  { auto _e = filename(); if (_e) _o->filename = _e->str(); }
  { auto _e = command(); if (_e) _o->command = _e->str(); }
  { auto _e = ini_filename(); if (_e) _o->ini_filename = _e->str(); }
  { auto _e = g5x_index(); _o->g5x_index = _e; }
  { auto _e = g92_offset(); if (_e) _o->g92_offset = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = rotation_xy(); _o->rotation_xy = _e; }
  { auto _e = tool_offset(); if (_e) _o->tool_offset = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = active_g_codes(); if (_e) { _o->active_g_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->active_g_codes[_i] = _e->Get(_i); } } }
  { auto _e = active_m_codes(); if (_e) { _o->active_m_codes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->active_m_codes[_i] = _e->Get(_i); } } }
  { auto _e = active_settings(); if (_e) { _o->active_settings.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->active_settings[_i] = _e->Get(_i); } } }
  { auto _e = interpreter_error_code(); _o->interpreter_error_code = _e; }
  { auto _e = is_task_paused(); _o->is_task_paused = _e; }
  { auto _e = delay_left(); _o->delay_left = _e; }
  { auto _e = queued_mdi_commands(); _o->queued_mdi_commands = _e; }
}

inline flatbuffers::Offset<TaskStat> TaskStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaskStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TaskStat> CreateTaskStat(flatbuffers::FlatBufferBuilder &_fbb, const TaskStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TaskStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode;
  auto _state = _o->state;
  auto _exec_state = _o->exec_state;
  auto _interp_state = _o->interp_state;
  auto _call_level = _o->call_level;
  auto _motion_line = _o->motion_line;
  auto _current_line = _o->current_line;
  auto _read_line = _o->read_line;
  auto _is_optional_stop_state = _o->is_optional_stop_state;
  auto _is_block_delete_state = _o->is_block_delete_state;
  auto _is_input_timeout = _o->is_input_timeout;
  auto _filename = _o->filename.empty() ? 0 : _fbb.CreateString(_o->filename);
  auto _command = _o->command.empty() ? 0 : _fbb.CreateString(_o->command);
  auto _ini_filename = _o->ini_filename.empty() ? 0 : _fbb.CreateString(_o->ini_filename);
  auto _g5x_index = _o->g5x_index;
  auto _g92_offset = _o->g92_offset ? _o->g92_offset.get() : 0;
  auto _rotation_xy = _o->rotation_xy;
  auto _tool_offset = _o->tool_offset ? _o->tool_offset.get() : 0;
  auto _active_g_codes = _o->active_g_codes.size() ? _fbb.CreateVector(_o->active_g_codes) : 0;
  auto _active_m_codes = _o->active_m_codes.size() ? _fbb.CreateVector(_o->active_m_codes) : 0;
  auto _active_settings = _o->active_settings.size() ? _fbb.CreateVector(_o->active_settings) : 0;
  auto _interpreter_error_code = _o->interpreter_error_code;
  auto _is_task_paused = _o->is_task_paused;
  auto _delay_left = _o->delay_left;
  auto _queued_mdi_commands = _o->queued_mdi_commands;
  return EMC::CreateTaskStat(
      _fbb,
      _mode,
      _state,
      _exec_state,
      _interp_state,
      _call_level,
      _motion_line,
      _current_line,
      _read_line,
      _is_optional_stop_state,
      _is_block_delete_state,
      _is_input_timeout,
      _filename,
      _command,
      _ini_filename,
      _g5x_index,
      _g92_offset,
      _rotation_xy,
      _tool_offset,
      _active_g_codes,
      _active_m_codes,
      _active_settings,
      _interpreter_error_code,
      _is_task_paused,
      _delay_left,
      _queued_mdi_commands);
}

inline ToolStatT *ToolStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::ToolStatT> _o = std::unique_ptr<EMC::ToolStatT>(new ToolStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ToolStat::UnPackTo(ToolStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pocket_prepped(); _o->pocket_prepped = _e; }
  { auto _e = tool_in_spindle(); _o->tool_in_spindle = _e; }
  { auto _e = tool_from_pocket(); _o->tool_from_pocket = _e; }
}

inline flatbuffers::Offset<ToolStat> ToolStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToolStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateToolStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ToolStat> CreateToolStat(flatbuffers::FlatBufferBuilder &_fbb, const ToolStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ToolStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pocket_prepped = _o->pocket_prepped;
  auto _tool_in_spindle = _o->tool_in_spindle;
  auto _tool_from_pocket = _o->tool_from_pocket;
  return EMC::CreateToolStat(
      _fbb,
      _pocket_prepped,
      _tool_in_spindle,
      _tool_from_pocket);
}

inline CoolantStatT *CoolantStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::CoolantStatT> _o = std::unique_ptr<EMC::CoolantStatT>(new CoolantStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CoolantStat::UnPackTo(CoolantStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_mist(); _o->is_mist = _e; }
  { auto _e = is_flood(); _o->is_flood = _e; }
}

inline flatbuffers::Offset<CoolantStat> CoolantStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CoolantStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCoolantStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CoolantStat> CreateCoolantStat(flatbuffers::FlatBufferBuilder &_fbb, const CoolantStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CoolantStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_mist = _o->is_mist;
  auto _is_flood = _o->is_flood;
  return EMC::CreateCoolantStat(
      _fbb,
      _is_mist,
      _is_flood);
}

inline AuxStatT *AuxStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::AuxStatT> _o = std::unique_ptr<EMC::AuxStatT>(new AuxStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuxStat::UnPackTo(AuxStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is_estopped(); _o->is_estopped = _e; }
}

inline flatbuffers::Offset<AuxStat> AuxStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuxStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuxStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuxStat> CreateAuxStat(flatbuffers::FlatBufferBuilder &_fbb, const AuxStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuxStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is_estopped = _o->is_estopped;
  return EMC::CreateAuxStat(
      _fbb,
      _is_estopped);
}

inline IOStatT *IOStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::IOStatT> _o = std::unique_ptr<EMC::IOStatT>(new IOStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IOStat::UnPackTo(IOStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug(); _o->debug = _e; }
  { auto _e = reason(); _o->reason = _e; }
  { auto _e = fault(); _o->fault = _e; }
  { auto _e = tool(); if (_e) _o->tool = std::unique_ptr<EMC::ToolStatT>(_e->UnPack(_resolver)); }
  { auto _e = coolant(); if (_e) _o->coolant = std::unique_ptr<EMC::CoolantStatT>(_e->UnPack(_resolver)); }
  { auto _e = aux(); if (_e) _o->aux = std::unique_ptr<EMC::AuxStatT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<IOStat> IOStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IOStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIOStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IOStat> CreateIOStat(flatbuffers::FlatBufferBuilder &_fbb, const IOStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IOStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug = _o->debug;
  auto _reason = _o->reason;
  auto _fault = _o->fault;
  auto _tool = _o->tool ? CreateToolStat(_fbb, _o->tool.get(), _rehasher) : 0;
  auto _coolant = _o->coolant ? CreateCoolantStat(_fbb, _o->coolant.get(), _rehasher) : 0;
  auto _aux = _o->aux ? CreateAuxStat(_fbb, _o->aux.get(), _rehasher) : 0;
  return EMC::CreateIOStat(
      _fbb,
      _debug,
      _reason,
      _fault,
      _tool,
      _coolant,
      _aux);
}

inline EmcStatT *EmcStat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::EmcStatT> _o = std::unique_ptr<EMC::EmcStatT>(new EmcStatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmcStat::UnPackTo(EmcStatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task(); if (_e) _o->task = std::unique_ptr<EMC::TaskStatT>(_e->UnPack(_resolver)); }
  { auto _e = motion(); if (_e) _o->motion = std::unique_ptr<EMC::MotionStatT>(_e->UnPack(_resolver)); }
  { auto _e = io(); if (_e) _o->io = std::unique_ptr<EMC::IOStatT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<EmcStat> EmcStat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EmcStatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmcStat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EmcStat> CreateEmcStat(flatbuffers::FlatBufferBuilder &_fbb, const EmcStatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EmcStatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task = _o->task ? CreateTaskStat(_fbb, _o->task.get(), _rehasher) : 0;
  auto _motion = _o->motion ? CreateMotionStat(_fbb, _o->motion.get(), _rehasher) : 0;
  auto _io = _o->io ? CreateIOStat(_fbb, _o->io.get(), _rehasher) : 0;
  return EMC::CreateEmcStat(
      _fbb,
      _task,
      _motion,
      _io);
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCSTAT_EMC_H_
