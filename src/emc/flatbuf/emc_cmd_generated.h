// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
#define FLATBUFFERS_GENERATED_EMCCMD_EMC_H_

#include "flatbuffers/flatbuffers.h"

#include "emc_common_generated.h"

namespace EMC {

struct SetDebug;

struct JogCmd;

struct JointSetBacklash;

struct JointSetMinPositionLimit;

struct JointSetMaxPositionLimit;

struct JointSetFerror;

struct JointSetMinFerror;

struct JointSetHomingParams;

struct JointHalt;

struct JointHome;

struct JointUnhome;

struct JogCont;

struct JogIncr;

struct JogAbs;

struct JogStop;

struct JoinOverrideLimits;

struct JoinLoadComp;
struct JoinLoadCompBuilder;

struct TrajSetMode;

struct TrajSetVelocity;

struct TrajSetAcceleration;

struct TrajSetMaxVelocity;

struct TrajSetScale;

struct TrajSetRapidScale;

struct TrajSetSpindleScale;

struct TrajSetFOEnable;

struct TrajSetSOEnable;

struct TrajSetFHEnable;

struct TrajAbort;

struct TrajPause;

struct TrajResume;

struct TrajDelay;

struct TrajLinearMove;

struct TrajCircularMove;
struct TrajCircularMoveBuilder;

struct TrajSetTermCond;

struct TrajSetSpindleSync;

struct TrajSetOffset;

struct TrajSetG5x;

struct TrajSetG92;

struct TrajSetRotation;

struct TrajClearProbeTrippedFlag;

struct TrajSetTeleopEnable;

struct TrajProbe;

struct TrajRigidTap;

struct MotionSetAOut;

struct MotionSetDOut;

struct MotionAdaptive;

struct TaskAbort;

struct TaskSetMode;

struct TaskSetState;

struct TaskPlanOpen;
struct TaskPlanOpenBuilder;

struct TaskPlanRun;

struct TaskPlanExecute;
struct TaskPlanExecuteBuilder;

struct TaskPlanReverse;

struct TaskPlanForward;

struct TaskPlanStep;

struct TaskPlanResume;

struct TaskPlanEnd;

struct TaskPlanClose;

struct TaskPlanInit;

struct TaskPlanSynch;

struct TaskPlanSetOptionalStop;

struct TaskPlanSetBlockDelete;

struct TaskPlanOptionalStop;

struct ToolCmd;

struct ToolHalt;

struct ToolAbort;

struct ToolPrepare;

struct ToolLoad;

struct ToolLoadToolTable;
struct ToolLoadToolTableBuilder;

struct ToolSetOffset;

struct ToolSetNumber;

struct AuxInputWait;

struct SpindleSpeed;

struct SpindleOrient;

struct SpindleWaitOrient;

struct SpindleOn;

struct SpindleOff;

struct SpindleIncrease;

struct SpindleDecrease;

struct SpindleConstant;

struct SpindleBrakeRelease;

struct SpindleBrakeEngage;

struct CoolantMistOn;

struct CoolantMistOff;

struct CoolantFloodOn;

struct CoolantFloodOff;

struct CmdChannelMsg;
struct CmdChannelMsgBuilder;

struct DebugLevel;
struct DebugLevelBuilder;

struct Result;
struct ResultBuilder;

enum Command {
  Command_NONE = 0,
  Command_set_debug = 1,
  Command_jog_cmd = 2,
  Command_join_set_backlash = 3,
  Command_joint_set_min_position_limit = 4,
  Command_joint_set_max_position_limit = 5,
  Command_joint_set_ferror = 6,
  Command_joint_set_min_ferror = 7,
  Command_joint_set_homing_params = 8,
  Command_joint_home = 9,
  Command_joint_unhome = 10,
  Command_joint_halt = 11,
  Command_jog_cont = 12,
  Command_jog_incr = 13,
  Command_jog_abs = 14,
  Command_jog_stop = 15,
  Command_join_override_limits = 16,
  Command_join_load_comp = 17,
  Command_traj_set_mode = 18,
  Command_traj_set_velocity = 19,
  Command_tral_set_acceleration = 20,
  Command_traj_set_max_velocity = 21,
  Command_traj_set_scale = 22,
  Command_traj_set_rapid_scale = 23,
  Command_traj_set_spindl_scale = 24,
  Command_traj_set_fo_enable = 25,
  Command_traj_set_so_enable = 26,
  Command_traj_set_fh_enable = 27,
  Command_traj_abort = 28,
  Command_traj_pause = 29,
  Command_traj_resume = 30,
  Command_traj_delay = 31,
  Command_traj_linear_move = 32,
  Command_traj_circular_move = 33,
  Command_traj_set_term_cond = 34,
  Command_traj_set_spindle_sync = 35,
  Command_traj_set_offset = 36,
  Command_traj_set_g5x = 37,
  Command_traj_set_g92 = 38,
  Command_traj_set_rotation = 39,
  Command_traj_clear_probe_tripped_flag = 40,
  Command_traj_set_teleop_enable = 41,
  Command_traj_probe = 42,
  Command_traj_rigid_tap = 43,
  Command_motion_set_aout = 44,
  Command_motion_set_dout = 45,
  Command_motion_adaptive = 46,
  Command_task_abort = 47,
  Command_task_set_mode = 48,
  Command_task_set_state = 49,
  Command_task_plan_open = 50,
  Command_task_plan_run = 51,
  Command_task_plan_execute = 52,
  Command_task_plan_reverse = 53,
  Command_task_plan_forward = 54,
  Command_task_plan_step = 55,
  Command_task_plan_resume = 56,
  Command_task_plan_end = 57,
  Command_task_plan_close = 58,
  Command_task_plan_init = 59,
  Command_task_plan_synch = 60,
  Command_task_plan_set_optional_stop = 61,
  Command_task_plan_set_block_delete = 62,
  Command_task_plan_optional_stop = 63,
  Command_tool_cmd = 64,
  Command_tool_halt = 65,
  Command_tool_abort = 66,
  Command_tool_prepare = 67,
  Command_tool_load = 68,
  Command_tool_load_tool_table = 69,
  Command_tool_set_offset = 70,
  Command_tool_set_number = 71,
  Command_aux_input_wait = 72,
  Command_spindle_speed = 73,
  Command_spindle_orient = 74,
  Command_spindle_wait_orient = 75,
  Command_spindle_on = 76,
  Command_spindle_off = 77,
  Command_spindle_increase = 78,
  Command_spindle_decrease = 79,
  Command_spindle_constant = 80,
  Command_spindle_brake_release = 81,
  Command_spindle_brake_engage = 82,
  Command_coolant_mist_on = 83,
  Command_coolant_mist_off = 84,
  Command_coolant_flood_on = 85,
  Command_coolant_flood_off = 86,
  Command_MIN = Command_NONE,
  Command_MAX = Command_coolant_flood_off
};

inline const Command (&EnumValuesCommand())[87] {
  static const Command values[] = {
    Command_NONE,
    Command_set_debug,
    Command_jog_cmd,
    Command_join_set_backlash,
    Command_joint_set_min_position_limit,
    Command_joint_set_max_position_limit,
    Command_joint_set_ferror,
    Command_joint_set_min_ferror,
    Command_joint_set_homing_params,
    Command_joint_home,
    Command_joint_unhome,
    Command_joint_halt,
    Command_jog_cont,
    Command_jog_incr,
    Command_jog_abs,
    Command_jog_stop,
    Command_join_override_limits,
    Command_join_load_comp,
    Command_traj_set_mode,
    Command_traj_set_velocity,
    Command_tral_set_acceleration,
    Command_traj_set_max_velocity,
    Command_traj_set_scale,
    Command_traj_set_rapid_scale,
    Command_traj_set_spindl_scale,
    Command_traj_set_fo_enable,
    Command_traj_set_so_enable,
    Command_traj_set_fh_enable,
    Command_traj_abort,
    Command_traj_pause,
    Command_traj_resume,
    Command_traj_delay,
    Command_traj_linear_move,
    Command_traj_circular_move,
    Command_traj_set_term_cond,
    Command_traj_set_spindle_sync,
    Command_traj_set_offset,
    Command_traj_set_g5x,
    Command_traj_set_g92,
    Command_traj_set_rotation,
    Command_traj_clear_probe_tripped_flag,
    Command_traj_set_teleop_enable,
    Command_traj_probe,
    Command_traj_rigid_tap,
    Command_motion_set_aout,
    Command_motion_set_dout,
    Command_motion_adaptive,
    Command_task_abort,
    Command_task_set_mode,
    Command_task_set_state,
    Command_task_plan_open,
    Command_task_plan_run,
    Command_task_plan_execute,
    Command_task_plan_reverse,
    Command_task_plan_forward,
    Command_task_plan_step,
    Command_task_plan_resume,
    Command_task_plan_end,
    Command_task_plan_close,
    Command_task_plan_init,
    Command_task_plan_synch,
    Command_task_plan_set_optional_stop,
    Command_task_plan_set_block_delete,
    Command_task_plan_optional_stop,
    Command_tool_cmd,
    Command_tool_halt,
    Command_tool_abort,
    Command_tool_prepare,
    Command_tool_load,
    Command_tool_load_tool_table,
    Command_tool_set_offset,
    Command_tool_set_number,
    Command_aux_input_wait,
    Command_spindle_speed,
    Command_spindle_orient,
    Command_spindle_wait_orient,
    Command_spindle_on,
    Command_spindle_off,
    Command_spindle_increase,
    Command_spindle_decrease,
    Command_spindle_constant,
    Command_spindle_brake_release,
    Command_spindle_brake_engage,
    Command_coolant_mist_on,
    Command_coolant_mist_off,
    Command_coolant_flood_on,
    Command_coolant_flood_off
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[88] = {
    "NONE",
    "set_debug",
    "jog_cmd",
    "join_set_backlash",
    "joint_set_min_position_limit",
    "joint_set_max_position_limit",
    "joint_set_ferror",
    "joint_set_min_ferror",
    "joint_set_homing_params",
    "joint_home",
    "joint_unhome",
    "joint_halt",
    "jog_cont",
    "jog_incr",
    "jog_abs",
    "jog_stop",
    "join_override_limits",
    "join_load_comp",
    "traj_set_mode",
    "traj_set_velocity",
    "tral_set_acceleration",
    "traj_set_max_velocity",
    "traj_set_scale",
    "traj_set_rapid_scale",
    "traj_set_spindl_scale",
    "traj_set_fo_enable",
    "traj_set_so_enable",
    "traj_set_fh_enable",
    "traj_abort",
    "traj_pause",
    "traj_resume",
    "traj_delay",
    "traj_linear_move",
    "traj_circular_move",
    "traj_set_term_cond",
    "traj_set_spindle_sync",
    "traj_set_offset",
    "traj_set_g5x",
    "traj_set_g92",
    "traj_set_rotation",
    "traj_clear_probe_tripped_flag",
    "traj_set_teleop_enable",
    "traj_probe",
    "traj_rigid_tap",
    "motion_set_aout",
    "motion_set_dout",
    "motion_adaptive",
    "task_abort",
    "task_set_mode",
    "task_set_state",
    "task_plan_open",
    "task_plan_run",
    "task_plan_execute",
    "task_plan_reverse",
    "task_plan_forward",
    "task_plan_step",
    "task_plan_resume",
    "task_plan_end",
    "task_plan_close",
    "task_plan_init",
    "task_plan_synch",
    "task_plan_set_optional_stop",
    "task_plan_set_block_delete",
    "task_plan_optional_stop",
    "tool_cmd",
    "tool_halt",
    "tool_abort",
    "tool_prepare",
    "tool_load",
    "tool_load_tool_table",
    "tool_set_offset",
    "tool_set_number",
    "aux_input_wait",
    "spindle_speed",
    "spindle_orient",
    "spindle_wait_orient",
    "spindle_on",
    "spindle_off",
    "spindle_increase",
    "spindle_decrease",
    "spindle_constant",
    "spindle_brake_release",
    "spindle_brake_engage",
    "coolant_mist_on",
    "coolant_mist_off",
    "coolant_flood_on",
    "coolant_flood_off",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (flatbuffers::IsOutRange(e, Command_NONE, Command_coolant_flood_off)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<EMC::SetDebug> {
  static const Command enum_value = Command_set_debug;
};

template<> struct CommandTraits<EMC::JogCmd> {
  static const Command enum_value = Command_jog_cmd;
};

template<> struct CommandTraits<EMC::JointSetBacklash> {
  static const Command enum_value = Command_join_set_backlash;
};

template<> struct CommandTraits<EMC::JointSetMinPositionLimit> {
  static const Command enum_value = Command_joint_set_min_position_limit;
};

template<> struct CommandTraits<EMC::JointSetMaxPositionLimit> {
  static const Command enum_value = Command_joint_set_max_position_limit;
};

template<> struct CommandTraits<EMC::JointSetFerror> {
  static const Command enum_value = Command_joint_set_ferror;
};

template<> struct CommandTraits<EMC::JointSetMinFerror> {
  static const Command enum_value = Command_joint_set_min_ferror;
};

template<> struct CommandTraits<EMC::JointSetHomingParams> {
  static const Command enum_value = Command_joint_set_homing_params;
};

template<> struct CommandTraits<EMC::JointHome> {
  static const Command enum_value = Command_joint_home;
};

template<> struct CommandTraits<EMC::JointUnhome> {
  static const Command enum_value = Command_joint_unhome;
};

template<> struct CommandTraits<EMC::JointHalt> {
  static const Command enum_value = Command_joint_halt;
};

template<> struct CommandTraits<EMC::JogCont> {
  static const Command enum_value = Command_jog_cont;
};

template<> struct CommandTraits<EMC::JogIncr> {
  static const Command enum_value = Command_jog_incr;
};

template<> struct CommandTraits<EMC::JogAbs> {
  static const Command enum_value = Command_jog_abs;
};

template<> struct CommandTraits<EMC::JogStop> {
  static const Command enum_value = Command_jog_stop;
};

template<> struct CommandTraits<EMC::JoinOverrideLimits> {
  static const Command enum_value = Command_join_override_limits;
};

template<> struct CommandTraits<EMC::JoinLoadComp> {
  static const Command enum_value = Command_join_load_comp;
};

template<> struct CommandTraits<EMC::TrajSetMode> {
  static const Command enum_value = Command_traj_set_mode;
};

template<> struct CommandTraits<EMC::TrajSetVelocity> {
  static const Command enum_value = Command_traj_set_velocity;
};

template<> struct CommandTraits<EMC::TrajSetAcceleration> {
  static const Command enum_value = Command_tral_set_acceleration;
};

template<> struct CommandTraits<EMC::TrajSetMaxVelocity> {
  static const Command enum_value = Command_traj_set_max_velocity;
};

template<> struct CommandTraits<EMC::TrajSetScale> {
  static const Command enum_value = Command_traj_set_scale;
};

template<> struct CommandTraits<EMC::TrajSetRapidScale> {
  static const Command enum_value = Command_traj_set_rapid_scale;
};

template<> struct CommandTraits<EMC::TrajSetSpindleScale> {
  static const Command enum_value = Command_traj_set_spindl_scale;
};

template<> struct CommandTraits<EMC::TrajSetFOEnable> {
  static const Command enum_value = Command_traj_set_fo_enable;
};

template<> struct CommandTraits<EMC::TrajSetSOEnable> {
  static const Command enum_value = Command_traj_set_so_enable;
};

template<> struct CommandTraits<EMC::TrajSetFHEnable> {
  static const Command enum_value = Command_traj_set_fh_enable;
};

template<> struct CommandTraits<EMC::TrajAbort> {
  static const Command enum_value = Command_traj_abort;
};

template<> struct CommandTraits<EMC::TrajPause> {
  static const Command enum_value = Command_traj_pause;
};

template<> struct CommandTraits<EMC::TrajResume> {
  static const Command enum_value = Command_traj_resume;
};

template<> struct CommandTraits<EMC::TrajDelay> {
  static const Command enum_value = Command_traj_delay;
};

template<> struct CommandTraits<EMC::TrajLinearMove> {
  static const Command enum_value = Command_traj_linear_move;
};

template<> struct CommandTraits<EMC::TrajCircularMove> {
  static const Command enum_value = Command_traj_circular_move;
};

template<> struct CommandTraits<EMC::TrajSetTermCond> {
  static const Command enum_value = Command_traj_set_term_cond;
};

template<> struct CommandTraits<EMC::TrajSetSpindleSync> {
  static const Command enum_value = Command_traj_set_spindle_sync;
};

template<> struct CommandTraits<EMC::TrajSetOffset> {
  static const Command enum_value = Command_traj_set_offset;
};

template<> struct CommandTraits<EMC::TrajSetG5x> {
  static const Command enum_value = Command_traj_set_g5x;
};

template<> struct CommandTraits<EMC::TrajSetG92> {
  static const Command enum_value = Command_traj_set_g92;
};

template<> struct CommandTraits<EMC::TrajSetRotation> {
  static const Command enum_value = Command_traj_set_rotation;
};

template<> struct CommandTraits<EMC::TrajClearProbeTrippedFlag> {
  static const Command enum_value = Command_traj_clear_probe_tripped_flag;
};

template<> struct CommandTraits<EMC::TrajSetTeleopEnable> {
  static const Command enum_value = Command_traj_set_teleop_enable;
};

template<> struct CommandTraits<EMC::TrajProbe> {
  static const Command enum_value = Command_traj_probe;
};

template<> struct CommandTraits<EMC::TrajRigidTap> {
  static const Command enum_value = Command_traj_rigid_tap;
};

template<> struct CommandTraits<EMC::MotionSetAOut> {
  static const Command enum_value = Command_motion_set_aout;
};

template<> struct CommandTraits<EMC::MotionSetDOut> {
  static const Command enum_value = Command_motion_set_dout;
};

template<> struct CommandTraits<EMC::MotionAdaptive> {
  static const Command enum_value = Command_motion_adaptive;
};

template<> struct CommandTraits<EMC::TaskAbort> {
  static const Command enum_value = Command_task_abort;
};

template<> struct CommandTraits<EMC::TaskSetMode> {
  static const Command enum_value = Command_task_set_mode;
};

template<> struct CommandTraits<EMC::TaskSetState> {
  static const Command enum_value = Command_task_set_state;
};

template<> struct CommandTraits<EMC::TaskPlanOpen> {
  static const Command enum_value = Command_task_plan_open;
};

template<> struct CommandTraits<EMC::TaskPlanRun> {
  static const Command enum_value = Command_task_plan_run;
};

template<> struct CommandTraits<EMC::TaskPlanExecute> {
  static const Command enum_value = Command_task_plan_execute;
};

template<> struct CommandTraits<EMC::TaskPlanReverse> {
  static const Command enum_value = Command_task_plan_reverse;
};

template<> struct CommandTraits<EMC::TaskPlanForward> {
  static const Command enum_value = Command_task_plan_forward;
};

template<> struct CommandTraits<EMC::TaskPlanStep> {
  static const Command enum_value = Command_task_plan_step;
};

template<> struct CommandTraits<EMC::TaskPlanResume> {
  static const Command enum_value = Command_task_plan_resume;
};

template<> struct CommandTraits<EMC::TaskPlanEnd> {
  static const Command enum_value = Command_task_plan_end;
};

template<> struct CommandTraits<EMC::TaskPlanClose> {
  static const Command enum_value = Command_task_plan_close;
};

template<> struct CommandTraits<EMC::TaskPlanInit> {
  static const Command enum_value = Command_task_plan_init;
};

template<> struct CommandTraits<EMC::TaskPlanSynch> {
  static const Command enum_value = Command_task_plan_synch;
};

template<> struct CommandTraits<EMC::TaskPlanSetOptionalStop> {
  static const Command enum_value = Command_task_plan_set_optional_stop;
};

template<> struct CommandTraits<EMC::TaskPlanSetBlockDelete> {
  static const Command enum_value = Command_task_plan_set_block_delete;
};

template<> struct CommandTraits<EMC::TaskPlanOptionalStop> {
  static const Command enum_value = Command_task_plan_optional_stop;
};

template<> struct CommandTraits<EMC::ToolCmd> {
  static const Command enum_value = Command_tool_cmd;
};

template<> struct CommandTraits<EMC::ToolHalt> {
  static const Command enum_value = Command_tool_halt;
};

template<> struct CommandTraits<EMC::ToolAbort> {
  static const Command enum_value = Command_tool_abort;
};

template<> struct CommandTraits<EMC::ToolPrepare> {
  static const Command enum_value = Command_tool_prepare;
};

template<> struct CommandTraits<EMC::ToolLoad> {
  static const Command enum_value = Command_tool_load;
};

template<> struct CommandTraits<EMC::ToolLoadToolTable> {
  static const Command enum_value = Command_tool_load_tool_table;
};

template<> struct CommandTraits<EMC::ToolSetOffset> {
  static const Command enum_value = Command_tool_set_offset;
};

template<> struct CommandTraits<EMC::ToolSetNumber> {
  static const Command enum_value = Command_tool_set_number;
};

template<> struct CommandTraits<EMC::AuxInputWait> {
  static const Command enum_value = Command_aux_input_wait;
};

template<> struct CommandTraits<EMC::SpindleSpeed> {
  static const Command enum_value = Command_spindle_speed;
};

template<> struct CommandTraits<EMC::SpindleOrient> {
  static const Command enum_value = Command_spindle_orient;
};

template<> struct CommandTraits<EMC::SpindleWaitOrient> {
  static const Command enum_value = Command_spindle_wait_orient;
};

template<> struct CommandTraits<EMC::SpindleOn> {
  static const Command enum_value = Command_spindle_on;
};

template<> struct CommandTraits<EMC::SpindleOff> {
  static const Command enum_value = Command_spindle_off;
};

template<> struct CommandTraits<EMC::SpindleIncrease> {
  static const Command enum_value = Command_spindle_increase;
};

template<> struct CommandTraits<EMC::SpindleDecrease> {
  static const Command enum_value = Command_spindle_decrease;
};

template<> struct CommandTraits<EMC::SpindleConstant> {
  static const Command enum_value = Command_spindle_constant;
};

template<> struct CommandTraits<EMC::SpindleBrakeRelease> {
  static const Command enum_value = Command_spindle_brake_release;
};

template<> struct CommandTraits<EMC::SpindleBrakeEngage> {
  static const Command enum_value = Command_spindle_brake_engage;
};

template<> struct CommandTraits<EMC::CoolantMistOn> {
  static const Command enum_value = Command_coolant_mist_on;
};

template<> struct CommandTraits<EMC::CoolantMistOff> {
  static const Command enum_value = Command_coolant_mist_off;
};

template<> struct CommandTraits<EMC::CoolantFloodOn> {
  static const Command enum_value = Command_coolant_flood_on;
};

template<> struct CommandTraits<EMC::CoolantFloodOff> {
  static const Command enum_value = Command_coolant_flood_off;
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetDebug FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t debug_level_;

 public:
  SetDebug()
      : debug_level_(0) {
  }
  SetDebug(int32_t _debug_level)
      : debug_level_(flatbuffers::EndianScalar(_debug_level)) {
  }
  int32_t debug_level() const {
    return flatbuffers::EndianScalar(debug_level_);
  }
};
FLATBUFFERS_STRUCT_END(SetDebug, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JogCmd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_or_axis_;

 public:
  JogCmd()
      : joint_or_axis_(0) {
  }
  JogCmd(int32_t _joint_or_axis)
      : joint_or_axis_(flatbuffers::EndianScalar(_joint_or_axis)) {
  }
  int32_t joint_or_axis() const {
    return flatbuffers::EndianScalar(joint_or_axis_);
  }
};
FLATBUFFERS_STRUCT_END(JogCmd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetBacklash FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double backlash_;

 public:
  JointSetBacklash()
      : joint_(0),
        padding0__(0),
        backlash_(0) {
    (void)padding0__;
  }
  JointSetBacklash(int32_t _joint, double _backlash)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        backlash_(flatbuffers::EndianScalar(_backlash)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double backlash() const {
    return flatbuffers::EndianScalar(backlash_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetBacklash, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMinPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMinPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMinPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMinPositionLimit, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMaxPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMaxPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMaxPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMaxPositionLimit, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetFerror FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double ferror_;

 public:
  JointSetFerror()
      : joint_(0),
        padding0__(0),
        ferror_(0) {
    (void)padding0__;
  }
  JointSetFerror(int32_t _joint, double _ferror)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        ferror_(flatbuffers::EndianScalar(_ferror)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double ferror() const {
    return flatbuffers::EndianScalar(ferror_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetFerror, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMinFerror FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double ferror_;

 public:
  JointSetMinFerror()
      : joint_(0),
        padding0__(0),
        ferror_(0) {
    (void)padding0__;
  }
  JointSetMinFerror(int32_t _joint, double _ferror)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        ferror_(flatbuffers::EndianScalar(_ferror)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double ferror() const {
    return flatbuffers::EndianScalar(ferror_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMinFerror, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetHomingParams FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double home_;
  double offset_;
  double home_final_vel_;
  double search_vel_;
  double latch_vel_;
  int32_t use_index_;
  int32_t encoder_does_not_reset_;
  int32_t ignore_limits_;
  int32_t home_sequence_;
  int32_t volatile_home_;
  int32_t locking_indexer_;
  int32_t absolute_encoder_;
  int32_t padding1__;

 public:
  JointSetHomingParams()
      : joint_(0),
        padding0__(0),
        home_(0),
        offset_(0),
        home_final_vel_(0),
        search_vel_(0),
        latch_vel_(0),
        use_index_(0),
        encoder_does_not_reset_(0),
        ignore_limits_(0),
        home_sequence_(0),
        volatile_home_(0),
        locking_indexer_(0),
        absolute_encoder_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JointSetHomingParams(int32_t _joint, double _home, double _offset, double _home_final_vel, double _search_vel, double _latch_vel, int32_t _use_index, int32_t _encoder_does_not_reset, int32_t _ignore_limits, int32_t _home_sequence, int32_t _volatile_home, int32_t _locking_indexer, int32_t _absolute_encoder)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        home_(flatbuffers::EndianScalar(_home)),
        offset_(flatbuffers::EndianScalar(_offset)),
        home_final_vel_(flatbuffers::EndianScalar(_home_final_vel)),
        search_vel_(flatbuffers::EndianScalar(_search_vel)),
        latch_vel_(flatbuffers::EndianScalar(_latch_vel)),
        use_index_(flatbuffers::EndianScalar(_use_index)),
        encoder_does_not_reset_(flatbuffers::EndianScalar(_encoder_does_not_reset)),
        ignore_limits_(flatbuffers::EndianScalar(_ignore_limits)),
        home_sequence_(flatbuffers::EndianScalar(_home_sequence)),
        volatile_home_(flatbuffers::EndianScalar(_volatile_home)),
        locking_indexer_(flatbuffers::EndianScalar(_locking_indexer)),
        absolute_encoder_(flatbuffers::EndianScalar(_absolute_encoder)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double home() const {
    return flatbuffers::EndianScalar(home_);
  }
  double offset() const {
    return flatbuffers::EndianScalar(offset_);
  }
  double home_final_vel() const {
    return flatbuffers::EndianScalar(home_final_vel_);
  }
  double search_vel() const {
    return flatbuffers::EndianScalar(search_vel_);
  }
  double latch_vel() const {
    return flatbuffers::EndianScalar(latch_vel_);
  }
  int32_t use_index() const {
    return flatbuffers::EndianScalar(use_index_);
  }
  int32_t encoder_does_not_reset() const {
    return flatbuffers::EndianScalar(encoder_does_not_reset_);
  }
  int32_t ignore_limits() const {
    return flatbuffers::EndianScalar(ignore_limits_);
  }
  int32_t home_sequence() const {
    return flatbuffers::EndianScalar(home_sequence_);
  }
  int32_t volatile_home() const {
    return flatbuffers::EndianScalar(volatile_home_);
  }
  int32_t locking_indexer() const {
    return flatbuffers::EndianScalar(locking_indexer_);
  }
  int32_t absolute_encoder() const {
    return flatbuffers::EndianScalar(absolute_encoder_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetHomingParams, 80);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointHalt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointHalt()
      : joint_(0) {
  }
  JointHalt(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointHalt, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointHome FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointHome()
      : joint_(0) {
  }
  JointHome(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointHome, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointUnhome FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointUnhome()
      : joint_(0) {
  }
  JointUnhome(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointUnhome, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogCont FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogCont()
      : joint_(0),
        padding0__(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogCont(int32_t _joint, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogCont, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogIncr FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double incr_;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogIncr()
      : joint_(0),
        padding0__(0),
        incr_(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogIncr(int32_t _joint, double _incr, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        incr_(flatbuffers::EndianScalar(_incr)),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double incr() const {
    return flatbuffers::EndianScalar(incr_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogIncr, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogAbs FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double pos_;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogAbs()
      : joint_(0),
        padding0__(0),
        pos_(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogAbs(int32_t _joint, double _pos, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        pos_(flatbuffers::EndianScalar(_pos)),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double pos() const {
    return flatbuffers::EndianScalar(pos_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogAbs, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JogStop FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t jjogmode_;

 public:
  JogStop()
      : joint_(0),
        jjogmode_(0) {
  }
  JogStop(int32_t _joint, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogStop, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JoinOverrideLimits FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JoinOverrideLimits()
      : joint_(0) {
  }
  JoinOverrideLimits(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JoinOverrideLimits, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetMode FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetMode()
      : mode_(0) {
  }
  TrajSetMode(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetMode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetVelocity FLATBUFFERS_FINAL_CLASS {
 private:
  double velocity_;
  double ini_maxvel_;

 public:
  TrajSetVelocity()
      : velocity_(0),
        ini_maxvel_(0) {
  }
  TrajSetVelocity(double _velocity, double _ini_maxvel)
      : velocity_(flatbuffers::EndianScalar(_velocity)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)) {
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetVelocity, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetAcceleration FLATBUFFERS_FINAL_CLASS {
 private:
  double acceleration_;

 public:
  TrajSetAcceleration()
      : acceleration_(0) {
  }
  TrajSetAcceleration(double _acceleration)
      : acceleration_(flatbuffers::EndianScalar(_acceleration)) {
  }
  double acceleration() const {
    return flatbuffers::EndianScalar(acceleration_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetAcceleration, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetMaxVelocity FLATBUFFERS_FINAL_CLASS {
 private:
  double velocity_;

 public:
  TrajSetMaxVelocity()
      : velocity_(0) {
  }
  TrajSetMaxVelocity(double _velocity)
      : velocity_(flatbuffers::EndianScalar(_velocity)) {
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetMaxVelocity, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetScale FLATBUFFERS_FINAL_CLASS {
 private:
  double scale_;

 public:
  TrajSetScale()
      : scale_(0) {
  }
  TrajSetScale(double _scale)
      : scale_(flatbuffers::EndianScalar(_scale)) {
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetScale, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetRapidScale FLATBUFFERS_FINAL_CLASS {
 private:
  double scale_;

 public:
  TrajSetRapidScale()
      : scale_(0) {
  }
  TrajSetRapidScale(double _scale)
      : scale_(flatbuffers::EndianScalar(_scale)) {
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetRapidScale, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetSpindleScale FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double scale_;

 public:
  TrajSetSpindleScale()
      : spindle_(0),
        padding0__(0),
        scale_(0) {
    (void)padding0__;
  }
  TrajSetSpindleScale(int32_t _spindle, double _scale)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        scale_(flatbuffers::EndianScalar(_scale)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSpindleScale, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetFOEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetFOEnable()
      : mode_(0) {
  }
  TrajSetFOEnable(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetFOEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetSOEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t mode_;

 public:
  TrajSetSOEnable()
      : spindle_(0),
        mode_(0) {
  }
  TrajSetSOEnable(int32_t _spindle, int32_t _mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSOEnable, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetFHEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetFHEnable()
      : mode_(0) {
  }
  TrajSetFHEnable(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetFHEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajAbort()
      : dummy_(0) {
  }
  TrajAbort(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajPause FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajPause()
      : dummy_(0) {
  }
  TrajPause(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajPause, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajResume FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajResume()
      : dummy_(0) {
  }
  TrajResume(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajResume, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajDelay FLATBUFFERS_FINAL_CLASS {
 private:
  double delay_;

 public:
  TrajDelay()
      : delay_(0) {
  }
  TrajDelay(double _delay)
      : delay_(flatbuffers::EndianScalar(_delay)) {
  }
  double delay() const {
    return flatbuffers::EndianScalar(delay_);
  }
};
FLATBUFFERS_STRUCT_END(TrajDelay, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajLinearMove FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t type_;
  int32_t padding0__;
  EMC::Pose end_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  int32_t feed_mode_;
  int32_t indexer_jnum_;

 public:
  TrajLinearMove()
      : type_(0),
        padding0__(0),
        end_(),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        feed_mode_(0),
        indexer_jnum_(0) {
    (void)padding0__;
  }
  TrajLinearMove(int32_t _type, const EMC::Pose &_end, double _vel, double _ini_maxvel, double _acc, int32_t _feed_mode, int32_t _indexer_jnum)
      : type_(flatbuffers::EndianScalar(_type)),
        padding0__(0),
        end_(_end),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        feed_mode_(flatbuffers::EndianScalar(_feed_mode)),
        indexer_jnum_(flatbuffers::EndianScalar(_indexer_jnum)) {
  }
  int32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  const EMC::Pose &end() const {
    return end_;
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  int32_t feed_mode() const {
    return flatbuffers::EndianScalar(feed_mode_);
  }
  int32_t indexer_jnum() const {
    return flatbuffers::EndianScalar(indexer_jnum_);
  }
};
FLATBUFFERS_STRUCT_END(TrajLinearMove, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetTermCond FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t cond_;
  int32_t padding0__;
  double tolerance_;

 public:
  TrajSetTermCond()
      : cond_(0),
        padding0__(0),
        tolerance_(0) {
    (void)padding0__;
  }
  TrajSetTermCond(int32_t _cond, double _tolerance)
      : cond_(flatbuffers::EndianScalar(_cond)),
        padding0__(0),
        tolerance_(flatbuffers::EndianScalar(_tolerance)) {
  }
  int32_t cond() const {
    return flatbuffers::EndianScalar(cond_);
  }
  double tolerance() const {
    return flatbuffers::EndianScalar(tolerance_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetTermCond, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetSpindleSync FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double feed_per_revolution_;
  uint8_t velocity_mode_;
  int8_t padding1__;  int16_t padding2__;  int32_t padding3__;

 public:
  TrajSetSpindleSync()
      : spindle_(0),
        padding0__(0),
        feed_per_revolution_(0),
        velocity_mode_(0),
        padding1__(0),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  TrajSetSpindleSync(int32_t _spindle, double _feed_per_revolution, bool _velocity_mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        feed_per_revolution_(flatbuffers::EndianScalar(_feed_per_revolution)),
        velocity_mode_(flatbuffers::EndianScalar(static_cast<uint8_t>(_velocity_mode))),
        padding1__(0),
        padding2__(0),
        padding3__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double feed_per_revolution() const {
    return flatbuffers::EndianScalar(feed_per_revolution_);
  }
  bool velocity_mode() const {
    return flatbuffers::EndianScalar(velocity_mode_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSpindleSync, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetOffset FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose offset_;

 public:
  TrajSetOffset()
      : offset_() {
  }
  TrajSetOffset(const EMC::Pose &_offset)
      : offset_(_offset) {
  }
  const EMC::Pose &offset() const {
    return offset_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetOffset, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetG5x FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t g5x_index_;
  int32_t padding0__;
  EMC::Pose origin_;

 public:
  TrajSetG5x()
      : g5x_index_(0),
        padding0__(0),
        origin_() {
    (void)padding0__;
  }
  TrajSetG5x(int32_t _g5x_index, const EMC::Pose &_origin)
      : g5x_index_(flatbuffers::EndianScalar(_g5x_index)),
        padding0__(0),
        origin_(_origin) {
  }
  int32_t g5x_index() const {
    return flatbuffers::EndianScalar(g5x_index_);
  }
  const EMC::Pose &origin() const {
    return origin_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetG5x, 80);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetG92 FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose origin_;

 public:
  TrajSetG92()
      : origin_() {
  }
  TrajSetG92(const EMC::Pose &_origin)
      : origin_(_origin) {
  }
  const EMC::Pose &origin() const {
    return origin_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetG92, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetRotation FLATBUFFERS_FINAL_CLASS {
 private:
  double rotation_;

 public:
  TrajSetRotation()
      : rotation_(0) {
  }
  TrajSetRotation(double _rotation)
      : rotation_(flatbuffers::EndianScalar(_rotation)) {
  }
  double rotation() const {
    return flatbuffers::EndianScalar(rotation_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetRotation, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajClearProbeTrippedFlag FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajClearProbeTrippedFlag()
      : dummy_(0) {
  }
  TrajClearProbeTrippedFlag(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajClearProbeTrippedFlag, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetTeleopEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t enable_;

 public:
  TrajSetTeleopEnable()
      : enable_(0) {
  }
  TrajSetTeleopEnable(int32_t _enable)
      : enable_(flatbuffers::EndianScalar(_enable)) {
  }
  int32_t enable() const {
    return flatbuffers::EndianScalar(enable_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetTeleopEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajProbe FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose pos_;
  int32_t type_;
  int32_t padding0__;
  double vel_;
  double ini_maxvel_;
  double acc_;
  int32_t probe_type_;
  int32_t padding1__;

 public:
  TrajProbe()
      : pos_(),
        type_(0),
        padding0__(0),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        probe_type_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  TrajProbe(const EMC::Pose &_pos, int32_t _type, double _vel, double _ini_maxvel, double _acc, int32_t _probe_type)
      : pos_(_pos),
        type_(flatbuffers::EndianScalar(_type)),
        padding0__(0),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        probe_type_(flatbuffers::EndianScalar(_probe_type)),
        padding1__(0) {
  }
  const EMC::Pose &pos() const {
    return pos_;
  }
  int32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  int32_t probe_type() const {
    return flatbuffers::EndianScalar(probe_type_);
  }
};
FLATBUFFERS_STRUCT_END(TrajProbe, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajRigidTap FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose pos_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  double scale_;

 public:
  TrajRigidTap()
      : pos_(),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        scale_(0) {
  }
  TrajRigidTap(const EMC::Pose &_pos, double _vel, double _ini_maxvel, double _acc, double _scale)
      : pos_(_pos),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        scale_(flatbuffers::EndianScalar(_scale)) {
  }
  const EMC::Pose &pos() const {
    return pos_;
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajRigidTap, 104);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MotionSetAOut FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t padding0__;
  double start_;
  double end_;
  int32_t now_;
  int32_t padding1__;

 public:
  MotionSetAOut()
      : index_(0),
        padding0__(0),
        start_(0),
        end_(0),
        now_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  MotionSetAOut(int32_t _index, double _start, double _end, int32_t _now)
      : index_(flatbuffers::EndianScalar(_index)),
        padding0__(0),
        start_(flatbuffers::EndianScalar(_start)),
        end_(flatbuffers::EndianScalar(_end)),
        now_(flatbuffers::EndianScalar(_now)),
        padding1__(0) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  double start() const {
    return flatbuffers::EndianScalar(start_);
  }
  double end() const {
    return flatbuffers::EndianScalar(end_);
  }
  int32_t now() const {
    return flatbuffers::EndianScalar(now_);
  }
};
FLATBUFFERS_STRUCT_END(MotionSetAOut, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotionSetDOut FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t start_;
  int32_t end_;
  int32_t now_;

 public:
  MotionSetDOut()
      : index_(0),
        start_(0),
        end_(0),
        now_(0) {
  }
  MotionSetDOut(int32_t _index, int32_t _start, int32_t _end, int32_t _now)
      : index_(flatbuffers::EndianScalar(_index)),
        start_(flatbuffers::EndianScalar(_start)),
        end_(flatbuffers::EndianScalar(_end)),
        now_(flatbuffers::EndianScalar(_now)) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  int32_t start() const {
    return flatbuffers::EndianScalar(start_);
  }
  int32_t end() const {
    return flatbuffers::EndianScalar(end_);
  }
  int32_t now() const {
    return flatbuffers::EndianScalar(now_);
  }
};
FLATBUFFERS_STRUCT_END(MotionSetDOut, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotionAdaptive FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t status_;

 public:
  MotionAdaptive()
      : status_(0) {
  }
  MotionAdaptive(int32_t _status)
      : status_(flatbuffers::EndianScalar(_status)) {
  }
  int32_t status() const {
    return flatbuffers::EndianScalar(status_);
  }
};
FLATBUFFERS_STRUCT_END(MotionAdaptive, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskAbort()
      : dummy_(0) {
  }
  TaskAbort(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskSetMode FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TaskSetMode()
      : mode_(0) {
  }
  TaskSetMode(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TaskSetMode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskSetState FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t state_;

 public:
  TaskSetState()
      : state_(0) {
  }
  TaskSetState(int32_t _state)
      : state_(flatbuffers::EndianScalar(_state)) {
  }
  int32_t state() const {
    return flatbuffers::EndianScalar(state_);
  }
};
FLATBUFFERS_STRUCT_END(TaskSetState, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanRun FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t line_;

 public:
  TaskPlanRun()
      : line_(0) {
  }
  TaskPlanRun(int32_t _line)
      : line_(flatbuffers::EndianScalar(_line)) {
  }
  int32_t line() const {
    return flatbuffers::EndianScalar(line_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanRun, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanReverse FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanReverse()
      : dummy_(0) {
  }
  TaskPlanReverse(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanReverse, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanForward FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanForward()
      : dummy_(0) {
  }
  TaskPlanForward(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanForward, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanStep FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanStep()
      : dummy_(0) {
  }
  TaskPlanStep(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanStep, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanResume FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanResume()
      : dummy_(0) {
  }
  TaskPlanResume(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanResume, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanEnd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanEnd()
      : dummy_(0) {
  }
  TaskPlanEnd(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanEnd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanClose FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanClose()
      : dummy_(0) {
  }
  TaskPlanClose(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanClose, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanInit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanInit()
      : dummy_(0) {
  }
  TaskPlanInit(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanInit, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanSynch FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanSynch()
      : dummy_(0) {
  }
  TaskPlanSynch(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSynch, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TaskPlanSetOptionalStop FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t state_;

 public:
  TaskPlanSetOptionalStop()
      : state_(0) {
  }
  TaskPlanSetOptionalStop(bool _state)
      : state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))) {
  }
  bool state() const {
    return flatbuffers::EndianScalar(state_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSetOptionalStop, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TaskPlanSetBlockDelete FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t state_;

 public:
  TaskPlanSetBlockDelete()
      : state_(0) {
  }
  TaskPlanSetBlockDelete(bool _state)
      : state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))) {
  }
  bool state() const {
    return flatbuffers::EndianScalar(state_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSetBlockDelete, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanOptionalStop FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanOptionalStop()
      : dummy_(0) {
  }
  TaskPlanOptionalStop(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanOptionalStop, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolCmd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolCmd()
      : dummy_(0) {
  }
  ToolCmd(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolCmd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolHalt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolHalt()
      : dummy_(0) {
  }
  ToolHalt(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolHalt, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t reason_;

 public:
  ToolAbort()
      : reason_(0) {
  }
  ToolAbort(int32_t _reason)
      : reason_(flatbuffers::EndianScalar(_reason)) {
  }
  int32_t reason() const {
    return flatbuffers::EndianScalar(reason_);
  }
};
FLATBUFFERS_STRUCT_END(ToolAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolPrepare FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t tool_;

 public:
  ToolPrepare()
      : tool_(0) {
  }
  ToolPrepare(int32_t _tool)
      : tool_(flatbuffers::EndianScalar(_tool)) {
  }
  int32_t tool() const {
    return flatbuffers::EndianScalar(tool_);
  }
};
FLATBUFFERS_STRUCT_END(ToolPrepare, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolLoad FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolLoad()
      : dummy_(0) {
  }
  ToolLoad(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolLoad, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ToolSetOffset FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t pocket_;
  int32_t toolno_;
  EMC::Pose offset_;
  double diameter_;
  double frontangle_;
  double backangle_;
  int32_t orientation_;
  int32_t padding0__;

 public:
  ToolSetOffset()
      : pocket_(0),
        toolno_(0),
        offset_(),
        diameter_(0),
        frontangle_(0),
        backangle_(0),
        orientation_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ToolSetOffset(int32_t _pocket, int32_t _toolno, const EMC::Pose &_offset, double _diameter, double _frontangle, double _backangle, int32_t _orientation)
      : pocket_(flatbuffers::EndianScalar(_pocket)),
        toolno_(flatbuffers::EndianScalar(_toolno)),
        offset_(_offset),
        diameter_(flatbuffers::EndianScalar(_diameter)),
        frontangle_(flatbuffers::EndianScalar(_frontangle)),
        backangle_(flatbuffers::EndianScalar(_backangle)),
        orientation_(flatbuffers::EndianScalar(_orientation)),
        padding0__(0) {
  }
  int32_t pocket() const {
    return flatbuffers::EndianScalar(pocket_);
  }
  int32_t toolno() const {
    return flatbuffers::EndianScalar(toolno_);
  }
  const EMC::Pose &offset() const {
    return offset_;
  }
  double diameter() const {
    return flatbuffers::EndianScalar(diameter_);
  }
  double frontangle() const {
    return flatbuffers::EndianScalar(frontangle_);
  }
  double backangle() const {
    return flatbuffers::EndianScalar(backangle_);
  }
  int32_t orientation() const {
    return flatbuffers::EndianScalar(orientation_);
  }
};
FLATBUFFERS_STRUCT_END(ToolSetOffset, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolSetNumber FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t tool_;

 public:
  ToolSetNumber()
      : tool_(0) {
  }
  ToolSetNumber(int32_t _tool)
      : tool_(flatbuffers::EndianScalar(_tool)) {
  }
  int32_t tool() const {
    return flatbuffers::EndianScalar(tool_);
  }
};
FLATBUFFERS_STRUCT_END(ToolSetNumber, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) AuxInputWait FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t input_type_;
  int32_t wait_type_;
  int32_t padding0__;
  double timeout_;

 public:
  AuxInputWait()
      : index_(0),
        input_type_(0),
        wait_type_(0),
        padding0__(0),
        timeout_(0) {
    (void)padding0__;
  }
  AuxInputWait(int32_t _index, int32_t _input_type, int32_t _wait_type, double _timeout)
      : index_(flatbuffers::EndianScalar(_index)),
        input_type_(flatbuffers::EndianScalar(_input_type)),
        wait_type_(flatbuffers::EndianScalar(_wait_type)),
        padding0__(0),
        timeout_(flatbuffers::EndianScalar(_timeout)) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  int32_t input_type() const {
    return flatbuffers::EndianScalar(input_type_);
  }
  int32_t wait_type() const {
    return flatbuffers::EndianScalar(wait_type_);
  }
  double timeout() const {
    return flatbuffers::EndianScalar(timeout_);
  }
};
FLATBUFFERS_STRUCT_END(AuxInputWait, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleSpeed FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;
  double factor_;
  double xoffset_;

 public:
  SpindleSpeed()
      : spindle_(0),
        padding0__(0),
        speed_(0),
        factor_(0),
        xoffset_(0) {
    (void)padding0__;
  }
  SpindleSpeed(int32_t _spindle, double _speed, double _factor, double _xoffset)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)),
        factor_(flatbuffers::EndianScalar(_factor)),
        xoffset_(flatbuffers::EndianScalar(_xoffset)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  double factor() const {
    return flatbuffers::EndianScalar(factor_);
  }
  double xoffset() const {
    return flatbuffers::EndianScalar(xoffset_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleSpeed, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleOrient FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double orientation_;
  int32_t mode_;
  int32_t padding1__;

 public:
  SpindleOrient()
      : spindle_(0),
        padding0__(0),
        orientation_(0),
        mode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SpindleOrient(int32_t _spindle, double _orientation, int32_t _mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        orientation_(flatbuffers::EndianScalar(_orientation)),
        mode_(flatbuffers::EndianScalar(_mode)),
        padding1__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double orientation() const {
    return flatbuffers::EndianScalar(orientation_);
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOrient, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleWaitOrient FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double timeout_;

 public:
  SpindleWaitOrient()
      : spindle_(0),
        padding0__(0),
        timeout_(0) {
    (void)padding0__;
  }
  SpindleWaitOrient(int32_t _spindle, double _timeout)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        timeout_(flatbuffers::EndianScalar(_timeout)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double timeout() const {
    return flatbuffers::EndianScalar(timeout_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleWaitOrient, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;
  double factor_;
  double xoffset_;
  int32_t wait_for_spindle_at_speed_;
  int32_t padding1__;

 public:
  SpindleOn()
      : spindle_(0),
        padding0__(0),
        speed_(0),
        factor_(0),
        xoffset_(0),
        wait_for_spindle_at_speed_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SpindleOn(int32_t _spindle, double _speed, double _factor, double _xoffset, int32_t _wait_for_spindle_at_speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)),
        factor_(flatbuffers::EndianScalar(_factor)),
        xoffset_(flatbuffers::EndianScalar(_xoffset)),
        wait_for_spindle_at_speed_(flatbuffers::EndianScalar(_wait_for_spindle_at_speed)),
        padding1__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  double factor() const {
    return flatbuffers::EndianScalar(factor_);
  }
  double xoffset() const {
    return flatbuffers::EndianScalar(xoffset_);
  }
  int32_t wait_for_spindle_at_speed() const {
    return flatbuffers::EndianScalar(wait_for_spindle_at_speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOn, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleOff()
      : spindle_(0) {
  }
  SpindleOff(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOff, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleIncrease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleIncrease()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleIncrease(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleIncrease, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleDecrease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleDecrease()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleDecrease(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleDecrease, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleConstant FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleConstant()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleConstant(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleConstant, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleBrakeRelease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleBrakeRelease()
      : spindle_(0) {
  }
  SpindleBrakeRelease(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleBrakeRelease, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleBrakeEngage FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleBrakeEngage()
      : spindle_(0) {
  }
  SpindleBrakeEngage(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleBrakeEngage, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantMistOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantMistOn()
      : dummy_(0) {
  }
  CoolantMistOn(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantMistOn, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantMistOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantMistOff()
      : dummy_(0) {
  }
  CoolantMistOff(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantMistOff, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantFloodOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantFloodOn()
      : dummy_(0) {
  }
  CoolantFloodOn(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantFloodOn, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantFloodOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantFloodOff()
      : dummy_(0) {
  }
  CoolantFloodOff(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantFloodOff, 4);

struct JoinLoadComp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinLoadCompBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct JoinLoadCompBuilder {
  typedef JoinLoadComp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(JoinLoadComp::VT_FILE, file);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(JoinLoadComp::VT_TYPE, type, 0);
  }
  explicit JoinLoadCompBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<JoinLoadComp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JoinLoadComp>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinLoadComp> CreateJoinLoadComp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    int32_t type = 0) {
  JoinLoadCompBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<JoinLoadComp> CreateJoinLoadCompDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr,
    int32_t type = 0) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateJoinLoadComp(
      _fbb,
      file__,
      type);
}

struct TrajCircularMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrajCircularMoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_END = 4,
    VT_CENTER = 6,
    VT_NORMAL = 8,
    VT_TURN = 10,
    VT_TYPE = 12,
    VT_VEL = 14,
    VT_INI_MAXVEL = 16,
    VT_ACC = 18,
    VT_FEED_MODE = 20
  };
  const EMC::Pose *end() const {
    return GetStruct<const EMC::Pose *>(VT_END);
  }
  const EMC::Cartesian *center() const {
    return GetStruct<const EMC::Cartesian *>(VT_CENTER);
  }
  const EMC::Cartesian *normal() const {
    return GetStruct<const EMC::Cartesian *>(VT_NORMAL);
  }
  int32_t turn() const {
    return GetField<int32_t>(VT_TURN, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  double vel() const {
    return GetField<double>(VT_VEL, 0.0);
  }
  double ini_maxvel() const {
    return GetField<double>(VT_INI_MAXVEL, 0.0);
  }
  double acc() const {
    return GetField<double>(VT_ACC, 0.0);
  }
  int32_t feed_mode() const {
    return GetField<int32_t>(VT_FEED_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EMC::Pose>(verifier, VT_END) &&
           VerifyField<EMC::Cartesian>(verifier, VT_CENTER) &&
           VerifyField<EMC::Cartesian>(verifier, VT_NORMAL) &&
           VerifyField<int32_t>(verifier, VT_TURN) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<double>(verifier, VT_VEL) &&
           VerifyField<double>(verifier, VT_INI_MAXVEL) &&
           VerifyField<double>(verifier, VT_ACC) &&
           VerifyField<int32_t>(verifier, VT_FEED_MODE) &&
           verifier.EndTable();
  }
};

struct TrajCircularMoveBuilder {
  typedef TrajCircularMove Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_end(const EMC::Pose *end) {
    fbb_.AddStruct(TrajCircularMove::VT_END, end);
  }
  void add_center(const EMC::Cartesian *center) {
    fbb_.AddStruct(TrajCircularMove::VT_CENTER, center);
  }
  void add_normal(const EMC::Cartesian *normal) {
    fbb_.AddStruct(TrajCircularMove::VT_NORMAL, normal);
  }
  void add_turn(int32_t turn) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_TURN, turn, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_TYPE, type, 0);
  }
  void add_vel(double vel) {
    fbb_.AddElement<double>(TrajCircularMove::VT_VEL, vel, 0.0);
  }
  void add_ini_maxvel(double ini_maxvel) {
    fbb_.AddElement<double>(TrajCircularMove::VT_INI_MAXVEL, ini_maxvel, 0.0);
  }
  void add_acc(double acc) {
    fbb_.AddElement<double>(TrajCircularMove::VT_ACC, acc, 0.0);
  }
  void add_feed_mode(int32_t feed_mode) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_FEED_MODE, feed_mode, 0);
  }
  explicit TrajCircularMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrajCircularMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrajCircularMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrajCircularMove> CreateTrajCircularMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EMC::Pose *end = 0,
    const EMC::Cartesian *center = 0,
    const EMC::Cartesian *normal = 0,
    int32_t turn = 0,
    int32_t type = 0,
    double vel = 0.0,
    double ini_maxvel = 0.0,
    double acc = 0.0,
    int32_t feed_mode = 0) {
  TrajCircularMoveBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_ini_maxvel(ini_maxvel);
  builder_.add_vel(vel);
  builder_.add_feed_mode(feed_mode);
  builder_.add_type(type);
  builder_.add_turn(turn);
  builder_.add_normal(normal);
  builder_.add_center(center);
  builder_.add_end(end);
  return builder_.Finish();
}

struct TaskPlanOpen FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskPlanOpenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           verifier.EndTable();
  }
};

struct TaskPlanOpenBuilder {
  typedef TaskPlanOpen Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(TaskPlanOpen::VT_FILE, file);
  }
  explicit TaskPlanOpenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TaskPlanOpen> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskPlanOpen>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpen(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0) {
  TaskPlanOpenBuilder builder_(_fbb);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpenDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateTaskPlanOpen(
      _fbb,
      file__);
}

struct TaskPlanExecute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskPlanExecuteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4
  };
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           verifier.EndTable();
  }
};

struct TaskPlanExecuteBuilder {
  typedef TaskPlanExecute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(TaskPlanExecute::VT_COMMAND, command);
  }
  explicit TaskPlanExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TaskPlanExecute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskPlanExecute>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> command = 0) {
  TaskPlanExecuteBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return EMC::CreateTaskPlanExecute(
      _fbb,
      command__);
}

struct ToolLoadToolTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ToolLoadToolTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           verifier.EndTable();
  }
};

struct ToolLoadToolTableBuilder {
  typedef ToolLoadToolTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(ToolLoadToolTable::VT_FILE, file);
  }
  explicit ToolLoadToolTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ToolLoadToolTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToolLoadToolTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0) {
  ToolLoadToolTableBuilder builder_(_fbb);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateToolLoadToolTable(
      _fbb,
      file__);
}

struct CmdChannelMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CmdChannelMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  EMC::Command command_type() const {
    return static_cast<EMC::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const EMC::SetDebug *command_as_set_debug() const {
    return command_type() == EMC::Command_set_debug ? static_cast<const EMC::SetDebug *>(command()) : nullptr;
  }
  const EMC::JogCmd *command_as_jog_cmd() const {
    return command_type() == EMC::Command_jog_cmd ? static_cast<const EMC::JogCmd *>(command()) : nullptr;
  }
  const EMC::JointSetBacklash *command_as_join_set_backlash() const {
    return command_type() == EMC::Command_join_set_backlash ? static_cast<const EMC::JointSetBacklash *>(command()) : nullptr;
  }
  const EMC::JointSetMinPositionLimit *command_as_joint_set_min_position_limit() const {
    return command_type() == EMC::Command_joint_set_min_position_limit ? static_cast<const EMC::JointSetMinPositionLimit *>(command()) : nullptr;
  }
  const EMC::JointSetMaxPositionLimit *command_as_joint_set_max_position_limit() const {
    return command_type() == EMC::Command_joint_set_max_position_limit ? static_cast<const EMC::JointSetMaxPositionLimit *>(command()) : nullptr;
  }
  const EMC::JointSetFerror *command_as_joint_set_ferror() const {
    return command_type() == EMC::Command_joint_set_ferror ? static_cast<const EMC::JointSetFerror *>(command()) : nullptr;
  }
  const EMC::JointSetMinFerror *command_as_joint_set_min_ferror() const {
    return command_type() == EMC::Command_joint_set_min_ferror ? static_cast<const EMC::JointSetMinFerror *>(command()) : nullptr;
  }
  const EMC::JointSetHomingParams *command_as_joint_set_homing_params() const {
    return command_type() == EMC::Command_joint_set_homing_params ? static_cast<const EMC::JointSetHomingParams *>(command()) : nullptr;
  }
  const EMC::JointHome *command_as_joint_home() const {
    return command_type() == EMC::Command_joint_home ? static_cast<const EMC::JointHome *>(command()) : nullptr;
  }
  const EMC::JointUnhome *command_as_joint_unhome() const {
    return command_type() == EMC::Command_joint_unhome ? static_cast<const EMC::JointUnhome *>(command()) : nullptr;
  }
  const EMC::JointHalt *command_as_joint_halt() const {
    return command_type() == EMC::Command_joint_halt ? static_cast<const EMC::JointHalt *>(command()) : nullptr;
  }
  const EMC::JogCont *command_as_jog_cont() const {
    return command_type() == EMC::Command_jog_cont ? static_cast<const EMC::JogCont *>(command()) : nullptr;
  }
  const EMC::JogIncr *command_as_jog_incr() const {
    return command_type() == EMC::Command_jog_incr ? static_cast<const EMC::JogIncr *>(command()) : nullptr;
  }
  const EMC::JogAbs *command_as_jog_abs() const {
    return command_type() == EMC::Command_jog_abs ? static_cast<const EMC::JogAbs *>(command()) : nullptr;
  }
  const EMC::JogStop *command_as_jog_stop() const {
    return command_type() == EMC::Command_jog_stop ? static_cast<const EMC::JogStop *>(command()) : nullptr;
  }
  const EMC::JoinOverrideLimits *command_as_join_override_limits() const {
    return command_type() == EMC::Command_join_override_limits ? static_cast<const EMC::JoinOverrideLimits *>(command()) : nullptr;
  }
  const EMC::JoinLoadComp *command_as_join_load_comp() const {
    return command_type() == EMC::Command_join_load_comp ? static_cast<const EMC::JoinLoadComp *>(command()) : nullptr;
  }
  const EMC::TrajSetMode *command_as_traj_set_mode() const {
    return command_type() == EMC::Command_traj_set_mode ? static_cast<const EMC::TrajSetMode *>(command()) : nullptr;
  }
  const EMC::TrajSetVelocity *command_as_traj_set_velocity() const {
    return command_type() == EMC::Command_traj_set_velocity ? static_cast<const EMC::TrajSetVelocity *>(command()) : nullptr;
  }
  const EMC::TrajSetAcceleration *command_as_tral_set_acceleration() const {
    return command_type() == EMC::Command_tral_set_acceleration ? static_cast<const EMC::TrajSetAcceleration *>(command()) : nullptr;
  }
  const EMC::TrajSetMaxVelocity *command_as_traj_set_max_velocity() const {
    return command_type() == EMC::Command_traj_set_max_velocity ? static_cast<const EMC::TrajSetMaxVelocity *>(command()) : nullptr;
  }
  const EMC::TrajSetScale *command_as_traj_set_scale() const {
    return command_type() == EMC::Command_traj_set_scale ? static_cast<const EMC::TrajSetScale *>(command()) : nullptr;
  }
  const EMC::TrajSetRapidScale *command_as_traj_set_rapid_scale() const {
    return command_type() == EMC::Command_traj_set_rapid_scale ? static_cast<const EMC::TrajSetRapidScale *>(command()) : nullptr;
  }
  const EMC::TrajSetSpindleScale *command_as_traj_set_spindl_scale() const {
    return command_type() == EMC::Command_traj_set_spindl_scale ? static_cast<const EMC::TrajSetSpindleScale *>(command()) : nullptr;
  }
  const EMC::TrajSetFOEnable *command_as_traj_set_fo_enable() const {
    return command_type() == EMC::Command_traj_set_fo_enable ? static_cast<const EMC::TrajSetFOEnable *>(command()) : nullptr;
  }
  const EMC::TrajSetSOEnable *command_as_traj_set_so_enable() const {
    return command_type() == EMC::Command_traj_set_so_enable ? static_cast<const EMC::TrajSetSOEnable *>(command()) : nullptr;
  }
  const EMC::TrajSetFHEnable *command_as_traj_set_fh_enable() const {
    return command_type() == EMC::Command_traj_set_fh_enable ? static_cast<const EMC::TrajSetFHEnable *>(command()) : nullptr;
  }
  const EMC::TrajAbort *command_as_traj_abort() const {
    return command_type() == EMC::Command_traj_abort ? static_cast<const EMC::TrajAbort *>(command()) : nullptr;
  }
  const EMC::TrajPause *command_as_traj_pause() const {
    return command_type() == EMC::Command_traj_pause ? static_cast<const EMC::TrajPause *>(command()) : nullptr;
  }
  const EMC::TrajResume *command_as_traj_resume() const {
    return command_type() == EMC::Command_traj_resume ? static_cast<const EMC::TrajResume *>(command()) : nullptr;
  }
  const EMC::TrajDelay *command_as_traj_delay() const {
    return command_type() == EMC::Command_traj_delay ? static_cast<const EMC::TrajDelay *>(command()) : nullptr;
  }
  const EMC::TrajLinearMove *command_as_traj_linear_move() const {
    return command_type() == EMC::Command_traj_linear_move ? static_cast<const EMC::TrajLinearMove *>(command()) : nullptr;
  }
  const EMC::TrajCircularMove *command_as_traj_circular_move() const {
    return command_type() == EMC::Command_traj_circular_move ? static_cast<const EMC::TrajCircularMove *>(command()) : nullptr;
  }
  const EMC::TrajSetTermCond *command_as_traj_set_term_cond() const {
    return command_type() == EMC::Command_traj_set_term_cond ? static_cast<const EMC::TrajSetTermCond *>(command()) : nullptr;
  }
  const EMC::TrajSetSpindleSync *command_as_traj_set_spindle_sync() const {
    return command_type() == EMC::Command_traj_set_spindle_sync ? static_cast<const EMC::TrajSetSpindleSync *>(command()) : nullptr;
  }
  const EMC::TrajSetOffset *command_as_traj_set_offset() const {
    return command_type() == EMC::Command_traj_set_offset ? static_cast<const EMC::TrajSetOffset *>(command()) : nullptr;
  }
  const EMC::TrajSetG5x *command_as_traj_set_g5x() const {
    return command_type() == EMC::Command_traj_set_g5x ? static_cast<const EMC::TrajSetG5x *>(command()) : nullptr;
  }
  const EMC::TrajSetG92 *command_as_traj_set_g92() const {
    return command_type() == EMC::Command_traj_set_g92 ? static_cast<const EMC::TrajSetG92 *>(command()) : nullptr;
  }
  const EMC::TrajSetRotation *command_as_traj_set_rotation() const {
    return command_type() == EMC::Command_traj_set_rotation ? static_cast<const EMC::TrajSetRotation *>(command()) : nullptr;
  }
  const EMC::TrajClearProbeTrippedFlag *command_as_traj_clear_probe_tripped_flag() const {
    return command_type() == EMC::Command_traj_clear_probe_tripped_flag ? static_cast<const EMC::TrajClearProbeTrippedFlag *>(command()) : nullptr;
  }
  const EMC::TrajSetTeleopEnable *command_as_traj_set_teleop_enable() const {
    return command_type() == EMC::Command_traj_set_teleop_enable ? static_cast<const EMC::TrajSetTeleopEnable *>(command()) : nullptr;
  }
  const EMC::TrajProbe *command_as_traj_probe() const {
    return command_type() == EMC::Command_traj_probe ? static_cast<const EMC::TrajProbe *>(command()) : nullptr;
  }
  const EMC::TrajRigidTap *command_as_traj_rigid_tap() const {
    return command_type() == EMC::Command_traj_rigid_tap ? static_cast<const EMC::TrajRigidTap *>(command()) : nullptr;
  }
  const EMC::MotionSetAOut *command_as_motion_set_aout() const {
    return command_type() == EMC::Command_motion_set_aout ? static_cast<const EMC::MotionSetAOut *>(command()) : nullptr;
  }
  const EMC::MotionSetDOut *command_as_motion_set_dout() const {
    return command_type() == EMC::Command_motion_set_dout ? static_cast<const EMC::MotionSetDOut *>(command()) : nullptr;
  }
  const EMC::MotionAdaptive *command_as_motion_adaptive() const {
    return command_type() == EMC::Command_motion_adaptive ? static_cast<const EMC::MotionAdaptive *>(command()) : nullptr;
  }
  const EMC::TaskAbort *command_as_task_abort() const {
    return command_type() == EMC::Command_task_abort ? static_cast<const EMC::TaskAbort *>(command()) : nullptr;
  }
  const EMC::TaskSetMode *command_as_task_set_mode() const {
    return command_type() == EMC::Command_task_set_mode ? static_cast<const EMC::TaskSetMode *>(command()) : nullptr;
  }
  const EMC::TaskSetState *command_as_task_set_state() const {
    return command_type() == EMC::Command_task_set_state ? static_cast<const EMC::TaskSetState *>(command()) : nullptr;
  }
  const EMC::TaskPlanOpen *command_as_task_plan_open() const {
    return command_type() == EMC::Command_task_plan_open ? static_cast<const EMC::TaskPlanOpen *>(command()) : nullptr;
  }
  const EMC::TaskPlanRun *command_as_task_plan_run() const {
    return command_type() == EMC::Command_task_plan_run ? static_cast<const EMC::TaskPlanRun *>(command()) : nullptr;
  }
  const EMC::TaskPlanExecute *command_as_task_plan_execute() const {
    return command_type() == EMC::Command_task_plan_execute ? static_cast<const EMC::TaskPlanExecute *>(command()) : nullptr;
  }
  const EMC::TaskPlanReverse *command_as_task_plan_reverse() const {
    return command_type() == EMC::Command_task_plan_reverse ? static_cast<const EMC::TaskPlanReverse *>(command()) : nullptr;
  }
  const EMC::TaskPlanForward *command_as_task_plan_forward() const {
    return command_type() == EMC::Command_task_plan_forward ? static_cast<const EMC::TaskPlanForward *>(command()) : nullptr;
  }
  const EMC::TaskPlanStep *command_as_task_plan_step() const {
    return command_type() == EMC::Command_task_plan_step ? static_cast<const EMC::TaskPlanStep *>(command()) : nullptr;
  }
  const EMC::TaskPlanResume *command_as_task_plan_resume() const {
    return command_type() == EMC::Command_task_plan_resume ? static_cast<const EMC::TaskPlanResume *>(command()) : nullptr;
  }
  const EMC::TaskPlanEnd *command_as_task_plan_end() const {
    return command_type() == EMC::Command_task_plan_end ? static_cast<const EMC::TaskPlanEnd *>(command()) : nullptr;
  }
  const EMC::TaskPlanClose *command_as_task_plan_close() const {
    return command_type() == EMC::Command_task_plan_close ? static_cast<const EMC::TaskPlanClose *>(command()) : nullptr;
  }
  const EMC::TaskPlanInit *command_as_task_plan_init() const {
    return command_type() == EMC::Command_task_plan_init ? static_cast<const EMC::TaskPlanInit *>(command()) : nullptr;
  }
  const EMC::TaskPlanSynch *command_as_task_plan_synch() const {
    return command_type() == EMC::Command_task_plan_synch ? static_cast<const EMC::TaskPlanSynch *>(command()) : nullptr;
  }
  const EMC::TaskPlanSetOptionalStop *command_as_task_plan_set_optional_stop() const {
    return command_type() == EMC::Command_task_plan_set_optional_stop ? static_cast<const EMC::TaskPlanSetOptionalStop *>(command()) : nullptr;
  }
  const EMC::TaskPlanSetBlockDelete *command_as_task_plan_set_block_delete() const {
    return command_type() == EMC::Command_task_plan_set_block_delete ? static_cast<const EMC::TaskPlanSetBlockDelete *>(command()) : nullptr;
  }
  const EMC::TaskPlanOptionalStop *command_as_task_plan_optional_stop() const {
    return command_type() == EMC::Command_task_plan_optional_stop ? static_cast<const EMC::TaskPlanOptionalStop *>(command()) : nullptr;
  }
  const EMC::ToolCmd *command_as_tool_cmd() const {
    return command_type() == EMC::Command_tool_cmd ? static_cast<const EMC::ToolCmd *>(command()) : nullptr;
  }
  const EMC::ToolHalt *command_as_tool_halt() const {
    return command_type() == EMC::Command_tool_halt ? static_cast<const EMC::ToolHalt *>(command()) : nullptr;
  }
  const EMC::ToolAbort *command_as_tool_abort() const {
    return command_type() == EMC::Command_tool_abort ? static_cast<const EMC::ToolAbort *>(command()) : nullptr;
  }
  const EMC::ToolPrepare *command_as_tool_prepare() const {
    return command_type() == EMC::Command_tool_prepare ? static_cast<const EMC::ToolPrepare *>(command()) : nullptr;
  }
  const EMC::ToolLoad *command_as_tool_load() const {
    return command_type() == EMC::Command_tool_load ? static_cast<const EMC::ToolLoad *>(command()) : nullptr;
  }
  const EMC::ToolLoadToolTable *command_as_tool_load_tool_table() const {
    return command_type() == EMC::Command_tool_load_tool_table ? static_cast<const EMC::ToolLoadToolTable *>(command()) : nullptr;
  }
  const EMC::ToolSetOffset *command_as_tool_set_offset() const {
    return command_type() == EMC::Command_tool_set_offset ? static_cast<const EMC::ToolSetOffset *>(command()) : nullptr;
  }
  const EMC::ToolSetNumber *command_as_tool_set_number() const {
    return command_type() == EMC::Command_tool_set_number ? static_cast<const EMC::ToolSetNumber *>(command()) : nullptr;
  }
  const EMC::AuxInputWait *command_as_aux_input_wait() const {
    return command_type() == EMC::Command_aux_input_wait ? static_cast<const EMC::AuxInputWait *>(command()) : nullptr;
  }
  const EMC::SpindleSpeed *command_as_spindle_speed() const {
    return command_type() == EMC::Command_spindle_speed ? static_cast<const EMC::SpindleSpeed *>(command()) : nullptr;
  }
  const EMC::SpindleOrient *command_as_spindle_orient() const {
    return command_type() == EMC::Command_spindle_orient ? static_cast<const EMC::SpindleOrient *>(command()) : nullptr;
  }
  const EMC::SpindleWaitOrient *command_as_spindle_wait_orient() const {
    return command_type() == EMC::Command_spindle_wait_orient ? static_cast<const EMC::SpindleWaitOrient *>(command()) : nullptr;
  }
  const EMC::SpindleOn *command_as_spindle_on() const {
    return command_type() == EMC::Command_spindle_on ? static_cast<const EMC::SpindleOn *>(command()) : nullptr;
  }
  const EMC::SpindleOff *command_as_spindle_off() const {
    return command_type() == EMC::Command_spindle_off ? static_cast<const EMC::SpindleOff *>(command()) : nullptr;
  }
  const EMC::SpindleIncrease *command_as_spindle_increase() const {
    return command_type() == EMC::Command_spindle_increase ? static_cast<const EMC::SpindleIncrease *>(command()) : nullptr;
  }
  const EMC::SpindleDecrease *command_as_spindle_decrease() const {
    return command_type() == EMC::Command_spindle_decrease ? static_cast<const EMC::SpindleDecrease *>(command()) : nullptr;
  }
  const EMC::SpindleConstant *command_as_spindle_constant() const {
    return command_type() == EMC::Command_spindle_constant ? static_cast<const EMC::SpindleConstant *>(command()) : nullptr;
  }
  const EMC::SpindleBrakeRelease *command_as_spindle_brake_release() const {
    return command_type() == EMC::Command_spindle_brake_release ? static_cast<const EMC::SpindleBrakeRelease *>(command()) : nullptr;
  }
  const EMC::SpindleBrakeEngage *command_as_spindle_brake_engage() const {
    return command_type() == EMC::Command_spindle_brake_engage ? static_cast<const EMC::SpindleBrakeEngage *>(command()) : nullptr;
  }
  const EMC::CoolantMistOn *command_as_coolant_mist_on() const {
    return command_type() == EMC::Command_coolant_mist_on ? static_cast<const EMC::CoolantMistOn *>(command()) : nullptr;
  }
  const EMC::CoolantMistOff *command_as_coolant_mist_off() const {
    return command_type() == EMC::Command_coolant_mist_off ? static_cast<const EMC::CoolantMistOff *>(command()) : nullptr;
  }
  const EMC::CoolantFloodOn *command_as_coolant_flood_on() const {
    return command_type() == EMC::Command_coolant_flood_on ? static_cast<const EMC::CoolantFloodOn *>(command()) : nullptr;
  }
  const EMC::CoolantFloodOff *command_as_coolant_flood_off() const {
    return command_type() == EMC::Command_coolant_flood_off ? static_cast<const EMC::CoolantFloodOff *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const EMC::SetDebug *CmdChannelMsg::command_as<EMC::SetDebug>() const {
  return command_as_set_debug();
}

template<> inline const EMC::JogCmd *CmdChannelMsg::command_as<EMC::JogCmd>() const {
  return command_as_jog_cmd();
}

template<> inline const EMC::JointSetBacklash *CmdChannelMsg::command_as<EMC::JointSetBacklash>() const {
  return command_as_join_set_backlash();
}

template<> inline const EMC::JointSetMinPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMinPositionLimit>() const {
  return command_as_joint_set_min_position_limit();
}

template<> inline const EMC::JointSetMaxPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMaxPositionLimit>() const {
  return command_as_joint_set_max_position_limit();
}

template<> inline const EMC::JointSetFerror *CmdChannelMsg::command_as<EMC::JointSetFerror>() const {
  return command_as_joint_set_ferror();
}

template<> inline const EMC::JointSetMinFerror *CmdChannelMsg::command_as<EMC::JointSetMinFerror>() const {
  return command_as_joint_set_min_ferror();
}

template<> inline const EMC::JointSetHomingParams *CmdChannelMsg::command_as<EMC::JointSetHomingParams>() const {
  return command_as_joint_set_homing_params();
}

template<> inline const EMC::JointHome *CmdChannelMsg::command_as<EMC::JointHome>() const {
  return command_as_joint_home();
}

template<> inline const EMC::JointUnhome *CmdChannelMsg::command_as<EMC::JointUnhome>() const {
  return command_as_joint_unhome();
}

template<> inline const EMC::JointHalt *CmdChannelMsg::command_as<EMC::JointHalt>() const {
  return command_as_joint_halt();
}

template<> inline const EMC::JogCont *CmdChannelMsg::command_as<EMC::JogCont>() const {
  return command_as_jog_cont();
}

template<> inline const EMC::JogIncr *CmdChannelMsg::command_as<EMC::JogIncr>() const {
  return command_as_jog_incr();
}

template<> inline const EMC::JogAbs *CmdChannelMsg::command_as<EMC::JogAbs>() const {
  return command_as_jog_abs();
}

template<> inline const EMC::JogStop *CmdChannelMsg::command_as<EMC::JogStop>() const {
  return command_as_jog_stop();
}

template<> inline const EMC::JoinOverrideLimits *CmdChannelMsg::command_as<EMC::JoinOverrideLimits>() const {
  return command_as_join_override_limits();
}

template<> inline const EMC::JoinLoadComp *CmdChannelMsg::command_as<EMC::JoinLoadComp>() const {
  return command_as_join_load_comp();
}

template<> inline const EMC::TrajSetMode *CmdChannelMsg::command_as<EMC::TrajSetMode>() const {
  return command_as_traj_set_mode();
}

template<> inline const EMC::TrajSetVelocity *CmdChannelMsg::command_as<EMC::TrajSetVelocity>() const {
  return command_as_traj_set_velocity();
}

template<> inline const EMC::TrajSetAcceleration *CmdChannelMsg::command_as<EMC::TrajSetAcceleration>() const {
  return command_as_tral_set_acceleration();
}

template<> inline const EMC::TrajSetMaxVelocity *CmdChannelMsg::command_as<EMC::TrajSetMaxVelocity>() const {
  return command_as_traj_set_max_velocity();
}

template<> inline const EMC::TrajSetScale *CmdChannelMsg::command_as<EMC::TrajSetScale>() const {
  return command_as_traj_set_scale();
}

template<> inline const EMC::TrajSetRapidScale *CmdChannelMsg::command_as<EMC::TrajSetRapidScale>() const {
  return command_as_traj_set_rapid_scale();
}

template<> inline const EMC::TrajSetSpindleScale *CmdChannelMsg::command_as<EMC::TrajSetSpindleScale>() const {
  return command_as_traj_set_spindl_scale();
}

template<> inline const EMC::TrajSetFOEnable *CmdChannelMsg::command_as<EMC::TrajSetFOEnable>() const {
  return command_as_traj_set_fo_enable();
}

template<> inline const EMC::TrajSetSOEnable *CmdChannelMsg::command_as<EMC::TrajSetSOEnable>() const {
  return command_as_traj_set_so_enable();
}

template<> inline const EMC::TrajSetFHEnable *CmdChannelMsg::command_as<EMC::TrajSetFHEnable>() const {
  return command_as_traj_set_fh_enable();
}

template<> inline const EMC::TrajAbort *CmdChannelMsg::command_as<EMC::TrajAbort>() const {
  return command_as_traj_abort();
}

template<> inline const EMC::TrajPause *CmdChannelMsg::command_as<EMC::TrajPause>() const {
  return command_as_traj_pause();
}

template<> inline const EMC::TrajResume *CmdChannelMsg::command_as<EMC::TrajResume>() const {
  return command_as_traj_resume();
}

template<> inline const EMC::TrajDelay *CmdChannelMsg::command_as<EMC::TrajDelay>() const {
  return command_as_traj_delay();
}

template<> inline const EMC::TrajLinearMove *CmdChannelMsg::command_as<EMC::TrajLinearMove>() const {
  return command_as_traj_linear_move();
}

template<> inline const EMC::TrajCircularMove *CmdChannelMsg::command_as<EMC::TrajCircularMove>() const {
  return command_as_traj_circular_move();
}

template<> inline const EMC::TrajSetTermCond *CmdChannelMsg::command_as<EMC::TrajSetTermCond>() const {
  return command_as_traj_set_term_cond();
}

template<> inline const EMC::TrajSetSpindleSync *CmdChannelMsg::command_as<EMC::TrajSetSpindleSync>() const {
  return command_as_traj_set_spindle_sync();
}

template<> inline const EMC::TrajSetOffset *CmdChannelMsg::command_as<EMC::TrajSetOffset>() const {
  return command_as_traj_set_offset();
}

template<> inline const EMC::TrajSetG5x *CmdChannelMsg::command_as<EMC::TrajSetG5x>() const {
  return command_as_traj_set_g5x();
}

template<> inline const EMC::TrajSetG92 *CmdChannelMsg::command_as<EMC::TrajSetG92>() const {
  return command_as_traj_set_g92();
}

template<> inline const EMC::TrajSetRotation *CmdChannelMsg::command_as<EMC::TrajSetRotation>() const {
  return command_as_traj_set_rotation();
}

template<> inline const EMC::TrajClearProbeTrippedFlag *CmdChannelMsg::command_as<EMC::TrajClearProbeTrippedFlag>() const {
  return command_as_traj_clear_probe_tripped_flag();
}

template<> inline const EMC::TrajSetTeleopEnable *CmdChannelMsg::command_as<EMC::TrajSetTeleopEnable>() const {
  return command_as_traj_set_teleop_enable();
}

template<> inline const EMC::TrajProbe *CmdChannelMsg::command_as<EMC::TrajProbe>() const {
  return command_as_traj_probe();
}

template<> inline const EMC::TrajRigidTap *CmdChannelMsg::command_as<EMC::TrajRigidTap>() const {
  return command_as_traj_rigid_tap();
}

template<> inline const EMC::MotionSetAOut *CmdChannelMsg::command_as<EMC::MotionSetAOut>() const {
  return command_as_motion_set_aout();
}

template<> inline const EMC::MotionSetDOut *CmdChannelMsg::command_as<EMC::MotionSetDOut>() const {
  return command_as_motion_set_dout();
}

template<> inline const EMC::MotionAdaptive *CmdChannelMsg::command_as<EMC::MotionAdaptive>() const {
  return command_as_motion_adaptive();
}

template<> inline const EMC::TaskAbort *CmdChannelMsg::command_as<EMC::TaskAbort>() const {
  return command_as_task_abort();
}

template<> inline const EMC::TaskSetMode *CmdChannelMsg::command_as<EMC::TaskSetMode>() const {
  return command_as_task_set_mode();
}

template<> inline const EMC::TaskSetState *CmdChannelMsg::command_as<EMC::TaskSetState>() const {
  return command_as_task_set_state();
}

template<> inline const EMC::TaskPlanOpen *CmdChannelMsg::command_as<EMC::TaskPlanOpen>() const {
  return command_as_task_plan_open();
}

template<> inline const EMC::TaskPlanRun *CmdChannelMsg::command_as<EMC::TaskPlanRun>() const {
  return command_as_task_plan_run();
}

template<> inline const EMC::TaskPlanExecute *CmdChannelMsg::command_as<EMC::TaskPlanExecute>() const {
  return command_as_task_plan_execute();
}

template<> inline const EMC::TaskPlanReverse *CmdChannelMsg::command_as<EMC::TaskPlanReverse>() const {
  return command_as_task_plan_reverse();
}

template<> inline const EMC::TaskPlanForward *CmdChannelMsg::command_as<EMC::TaskPlanForward>() const {
  return command_as_task_plan_forward();
}

template<> inline const EMC::TaskPlanStep *CmdChannelMsg::command_as<EMC::TaskPlanStep>() const {
  return command_as_task_plan_step();
}

template<> inline const EMC::TaskPlanResume *CmdChannelMsg::command_as<EMC::TaskPlanResume>() const {
  return command_as_task_plan_resume();
}

template<> inline const EMC::TaskPlanEnd *CmdChannelMsg::command_as<EMC::TaskPlanEnd>() const {
  return command_as_task_plan_end();
}

template<> inline const EMC::TaskPlanClose *CmdChannelMsg::command_as<EMC::TaskPlanClose>() const {
  return command_as_task_plan_close();
}

template<> inline const EMC::TaskPlanInit *CmdChannelMsg::command_as<EMC::TaskPlanInit>() const {
  return command_as_task_plan_init();
}

template<> inline const EMC::TaskPlanSynch *CmdChannelMsg::command_as<EMC::TaskPlanSynch>() const {
  return command_as_task_plan_synch();
}

template<> inline const EMC::TaskPlanSetOptionalStop *CmdChannelMsg::command_as<EMC::TaskPlanSetOptionalStop>() const {
  return command_as_task_plan_set_optional_stop();
}

template<> inline const EMC::TaskPlanSetBlockDelete *CmdChannelMsg::command_as<EMC::TaskPlanSetBlockDelete>() const {
  return command_as_task_plan_set_block_delete();
}

template<> inline const EMC::TaskPlanOptionalStop *CmdChannelMsg::command_as<EMC::TaskPlanOptionalStop>() const {
  return command_as_task_plan_optional_stop();
}

template<> inline const EMC::ToolCmd *CmdChannelMsg::command_as<EMC::ToolCmd>() const {
  return command_as_tool_cmd();
}

template<> inline const EMC::ToolHalt *CmdChannelMsg::command_as<EMC::ToolHalt>() const {
  return command_as_tool_halt();
}

template<> inline const EMC::ToolAbort *CmdChannelMsg::command_as<EMC::ToolAbort>() const {
  return command_as_tool_abort();
}

template<> inline const EMC::ToolPrepare *CmdChannelMsg::command_as<EMC::ToolPrepare>() const {
  return command_as_tool_prepare();
}

template<> inline const EMC::ToolLoad *CmdChannelMsg::command_as<EMC::ToolLoad>() const {
  return command_as_tool_load();
}

template<> inline const EMC::ToolLoadToolTable *CmdChannelMsg::command_as<EMC::ToolLoadToolTable>() const {
  return command_as_tool_load_tool_table();
}

template<> inline const EMC::ToolSetOffset *CmdChannelMsg::command_as<EMC::ToolSetOffset>() const {
  return command_as_tool_set_offset();
}

template<> inline const EMC::ToolSetNumber *CmdChannelMsg::command_as<EMC::ToolSetNumber>() const {
  return command_as_tool_set_number();
}

template<> inline const EMC::AuxInputWait *CmdChannelMsg::command_as<EMC::AuxInputWait>() const {
  return command_as_aux_input_wait();
}

template<> inline const EMC::SpindleSpeed *CmdChannelMsg::command_as<EMC::SpindleSpeed>() const {
  return command_as_spindle_speed();
}

template<> inline const EMC::SpindleOrient *CmdChannelMsg::command_as<EMC::SpindleOrient>() const {
  return command_as_spindle_orient();
}

template<> inline const EMC::SpindleWaitOrient *CmdChannelMsg::command_as<EMC::SpindleWaitOrient>() const {
  return command_as_spindle_wait_orient();
}

template<> inline const EMC::SpindleOn *CmdChannelMsg::command_as<EMC::SpindleOn>() const {
  return command_as_spindle_on();
}

template<> inline const EMC::SpindleOff *CmdChannelMsg::command_as<EMC::SpindleOff>() const {
  return command_as_spindle_off();
}

template<> inline const EMC::SpindleIncrease *CmdChannelMsg::command_as<EMC::SpindleIncrease>() const {
  return command_as_spindle_increase();
}

template<> inline const EMC::SpindleDecrease *CmdChannelMsg::command_as<EMC::SpindleDecrease>() const {
  return command_as_spindle_decrease();
}

template<> inline const EMC::SpindleConstant *CmdChannelMsg::command_as<EMC::SpindleConstant>() const {
  return command_as_spindle_constant();
}

template<> inline const EMC::SpindleBrakeRelease *CmdChannelMsg::command_as<EMC::SpindleBrakeRelease>() const {
  return command_as_spindle_brake_release();
}

template<> inline const EMC::SpindleBrakeEngage *CmdChannelMsg::command_as<EMC::SpindleBrakeEngage>() const {
  return command_as_spindle_brake_engage();
}

template<> inline const EMC::CoolantMistOn *CmdChannelMsg::command_as<EMC::CoolantMistOn>() const {
  return command_as_coolant_mist_on();
}

template<> inline const EMC::CoolantMistOff *CmdChannelMsg::command_as<EMC::CoolantMistOff>() const {
  return command_as_coolant_mist_off();
}

template<> inline const EMC::CoolantFloodOn *CmdChannelMsg::command_as<EMC::CoolantFloodOn>() const {
  return command_as_coolant_flood_on();
}

template<> inline const EMC::CoolantFloodOff *CmdChannelMsg::command_as<EMC::CoolantFloodOff>() const {
  return command_as_coolant_flood_off();
}

struct CmdChannelMsgBuilder {
  typedef CmdChannelMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command_type(EMC::Command command_type) {
    fbb_.AddElement<uint8_t>(CmdChannelMsg::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(CmdChannelMsg::VT_COMMAND, command);
  }
  explicit CmdChannelMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CmdChannelMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CmdChannelMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    EMC::Command command_type = EMC::Command_NONE,
    flatbuffers::Offset<void> command = 0) {
  CmdChannelMsgBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct DebugLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG_LEVEL = 4
  };
  int32_t debug_level() const {
    return GetField<int32_t>(VT_DEBUG_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEBUG_LEVEL) &&
           verifier.EndTable();
  }
};

struct DebugLevelBuilder {
  typedef DebugLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug_level(int32_t debug_level) {
    fbb_.AddElement<int32_t>(DebugLevel::VT_DEBUG_LEVEL, debug_level, 0);
  }
  explicit DebugLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DebugLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugLevel>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugLevel> CreateDebugLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t debug_level = 0) {
  DebugLevelBuilder builder_(_fbb);
  builder_.add_debug_level(debug_level);
  return builder_.Finish();
}

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct ResultBuilder {
  typedef Result Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(Result::VT_RESULT, result, 0);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_set_debug: {
      return verifier.Verify<EMC::SetDebug>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_cmd: {
      return verifier.Verify<EMC::JogCmd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_join_set_backlash: {
      return verifier.Verify<EMC::JointSetBacklash>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_min_position_limit: {
      return verifier.Verify<EMC::JointSetMinPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_max_position_limit: {
      return verifier.Verify<EMC::JointSetMaxPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_ferror: {
      return verifier.Verify<EMC::JointSetFerror>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_min_ferror: {
      return verifier.Verify<EMC::JointSetMinFerror>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_homing_params: {
      return verifier.Verify<EMC::JointSetHomingParams>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_home: {
      return verifier.Verify<EMC::JointHome>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_unhome: {
      return verifier.Verify<EMC::JointUnhome>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_halt: {
      return verifier.Verify<EMC::JointHalt>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_cont: {
      return verifier.Verify<EMC::JogCont>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_incr: {
      return verifier.Verify<EMC::JogIncr>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_abs: {
      return verifier.Verify<EMC::JogAbs>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_stop: {
      return verifier.Verify<EMC::JogStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_join_override_limits: {
      return verifier.Verify<EMC::JoinOverrideLimits>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_join_load_comp: {
      auto ptr = reinterpret_cast<const EMC::JoinLoadComp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_traj_set_mode: {
      return verifier.Verify<EMC::TrajSetMode>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_velocity: {
      return verifier.Verify<EMC::TrajSetVelocity>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tral_set_acceleration: {
      return verifier.Verify<EMC::TrajSetAcceleration>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_max_velocity: {
      return verifier.Verify<EMC::TrajSetMaxVelocity>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_scale: {
      return verifier.Verify<EMC::TrajSetScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_rapid_scale: {
      return verifier.Verify<EMC::TrajSetRapidScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_spindl_scale: {
      return verifier.Verify<EMC::TrajSetSpindleScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_fo_enable: {
      return verifier.Verify<EMC::TrajSetFOEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_so_enable: {
      return verifier.Verify<EMC::TrajSetSOEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_fh_enable: {
      return verifier.Verify<EMC::TrajSetFHEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_abort: {
      return verifier.Verify<EMC::TrajAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_pause: {
      return verifier.Verify<EMC::TrajPause>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_resume: {
      return verifier.Verify<EMC::TrajResume>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_delay: {
      return verifier.Verify<EMC::TrajDelay>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_linear_move: {
      return verifier.Verify<EMC::TrajLinearMove>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_circular_move: {
      auto ptr = reinterpret_cast<const EMC::TrajCircularMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_traj_set_term_cond: {
      return verifier.Verify<EMC::TrajSetTermCond>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_spindle_sync: {
      return verifier.Verify<EMC::TrajSetSpindleSync>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_offset: {
      return verifier.Verify<EMC::TrajSetOffset>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_g5x: {
      return verifier.Verify<EMC::TrajSetG5x>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_g92: {
      return verifier.Verify<EMC::TrajSetG92>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_rotation: {
      return verifier.Verify<EMC::TrajSetRotation>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_clear_probe_tripped_flag: {
      return verifier.Verify<EMC::TrajClearProbeTrippedFlag>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_teleop_enable: {
      return verifier.Verify<EMC::TrajSetTeleopEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_probe: {
      return verifier.Verify<EMC::TrajProbe>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_rigid_tap: {
      return verifier.Verify<EMC::TrajRigidTap>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_set_aout: {
      return verifier.Verify<EMC::MotionSetAOut>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_set_dout: {
      return verifier.Verify<EMC::MotionSetDOut>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_adaptive: {
      return verifier.Verify<EMC::MotionAdaptive>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_abort: {
      return verifier.Verify<EMC::TaskAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_set_mode: {
      return verifier.Verify<EMC::TaskSetMode>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_set_state: {
      return verifier.Verify<EMC::TaskSetState>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_open: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOpen *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_task_plan_run: {
      return verifier.Verify<EMC::TaskPlanRun>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_execute: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanExecute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_task_plan_reverse: {
      return verifier.Verify<EMC::TaskPlanReverse>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_forward: {
      return verifier.Verify<EMC::TaskPlanForward>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_step: {
      return verifier.Verify<EMC::TaskPlanStep>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_resume: {
      return verifier.Verify<EMC::TaskPlanResume>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_end: {
      return verifier.Verify<EMC::TaskPlanEnd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_close: {
      return verifier.Verify<EMC::TaskPlanClose>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_init: {
      return verifier.Verify<EMC::TaskPlanInit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_synch: {
      return verifier.Verify<EMC::TaskPlanSynch>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_set_optional_stop: {
      return verifier.Verify<EMC::TaskPlanSetOptionalStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_set_block_delete: {
      return verifier.Verify<EMC::TaskPlanSetBlockDelete>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_optional_stop: {
      return verifier.Verify<EMC::TaskPlanOptionalStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_cmd: {
      return verifier.Verify<EMC::ToolCmd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_halt: {
      return verifier.Verify<EMC::ToolHalt>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_abort: {
      return verifier.Verify<EMC::ToolAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_prepare: {
      return verifier.Verify<EMC::ToolPrepare>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_load: {
      return verifier.Verify<EMC::ToolLoad>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_load_tool_table: {
      auto ptr = reinterpret_cast<const EMC::ToolLoadToolTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_tool_set_offset: {
      return verifier.Verify<EMC::ToolSetOffset>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_set_number: {
      return verifier.Verify<EMC::ToolSetNumber>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_aux_input_wait: {
      return verifier.Verify<EMC::AuxInputWait>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_speed: {
      return verifier.Verify<EMC::SpindleSpeed>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_orient: {
      return verifier.Verify<EMC::SpindleOrient>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_wait_orient: {
      return verifier.Verify<EMC::SpindleWaitOrient>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_on: {
      return verifier.Verify<EMC::SpindleOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_off: {
      return verifier.Verify<EMC::SpindleOff>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_increase: {
      return verifier.Verify<EMC::SpindleIncrease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_decrease: {
      return verifier.Verify<EMC::SpindleDecrease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_constant: {
      return verifier.Verify<EMC::SpindleConstant>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_brake_release: {
      return verifier.Verify<EMC::SpindleBrakeRelease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_brake_engage: {
      return verifier.Verify<EMC::SpindleBrakeEngage>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_mist_on: {
      return verifier.Verify<EMC::CoolantMistOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_mist_off: {
      return verifier.Verify<EMC::CoolantMistOff>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_flood_on: {
      return verifier.Verify<EMC::CoolantFloodOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_flood_off: {
      return verifier.Verify<EMC::CoolantFloodOff>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline const EMC::CmdChannelMsg *GetCmdChannelMsg(const void *buf) {
  return flatbuffers::GetRoot<EMC::CmdChannelMsg>(buf);
}

inline const EMC::CmdChannelMsg *GetSizePrefixedCmdChannelMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EMC::CmdChannelMsg>(buf);
}

inline bool VerifyCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline bool VerifySizePrefixedCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline void FinishCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
