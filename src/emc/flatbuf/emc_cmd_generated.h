// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
#define FLATBUFFERS_GENERATED_EMCCMD_EMC_H_

#include "flatbuffers/flatbuffers.h"

#include "emc_common_generated.h"

namespace EMC {

struct SetDebug;

struct JogCmd;

struct JointSetBacklash;

struct JointSetMinPositionLimit;

struct JointSetMaxPositionLimit;

struct CmdChannelMsg;
struct CmdChannelMsgBuilder;
struct CmdChannelMsgT;

enum Command {
  Command_NONE = 0,
  Command_set_debug = 1,
  Command_jog_cmd = 2,
  Command_join_set_backlash = 3,
  Command_joint_set_min_position_limit = 4,
  Command_joint_set_max_position_limit = 5,
  Command_MIN = Command_NONE,
  Command_MAX = Command_joint_set_max_position_limit
};

inline const Command (&EnumValuesCommand())[6] {
  static const Command values[] = {
    Command_NONE,
    Command_set_debug,
    Command_jog_cmd,
    Command_join_set_backlash,
    Command_joint_set_min_position_limit,
    Command_joint_set_max_position_limit
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[7] = {
    "NONE",
    "set_debug",
    "jog_cmd",
    "join_set_backlash",
    "joint_set_min_position_limit",
    "joint_set_max_position_limit",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (flatbuffers::IsOutRange(e, Command_NONE, Command_joint_set_max_position_limit)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<EMC::SetDebug> {
  static const Command enum_value = Command_set_debug;
};

template<> struct CommandTraits<EMC::JogCmd> {
  static const Command enum_value = Command_jog_cmd;
};

template<> struct CommandTraits<EMC::JointSetBacklash> {
  static const Command enum_value = Command_join_set_backlash;
};

template<> struct CommandTraits<EMC::JointSetMinPositionLimit> {
  static const Command enum_value = Command_joint_set_min_position_limit;
};

template<> struct CommandTraits<EMC::JointSetMaxPositionLimit> {
  static const Command enum_value = Command_joint_set_max_position_limit;
};

struct CommandUnion {
  Command type;
  void *value;

  CommandUnion() : type(Command_NONE), value(nullptr) {}
  CommandUnion(CommandUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Command_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CommandUnion(const CommandUnion &);
  CommandUnion &operator=(const CommandUnion &u)
    { CommandUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CommandUnion &operator=(CommandUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CommandUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = CommandTraits<typename RT::TableType>::enum_value;
    if (type != Command_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  EMC::SetDebug *Asset_debug() {
    return type == Command_set_debug ?
      reinterpret_cast<EMC::SetDebug *>(value) : nullptr;
  }
  const EMC::SetDebug *Asset_debug() const {
    return type == Command_set_debug ?
      reinterpret_cast<const EMC::SetDebug *>(value) : nullptr;
  }
  EMC::JogCmd *Asjog_cmd() {
    return type == Command_jog_cmd ?
      reinterpret_cast<EMC::JogCmd *>(value) : nullptr;
  }
  const EMC::JogCmd *Asjog_cmd() const {
    return type == Command_jog_cmd ?
      reinterpret_cast<const EMC::JogCmd *>(value) : nullptr;
  }
  EMC::JointSetBacklash *Asjoin_set_backlash() {
    return type == Command_join_set_backlash ?
      reinterpret_cast<EMC::JointSetBacklash *>(value) : nullptr;
  }
  const EMC::JointSetBacklash *Asjoin_set_backlash() const {
    return type == Command_join_set_backlash ?
      reinterpret_cast<const EMC::JointSetBacklash *>(value) : nullptr;
  }
  EMC::JointSetMinPositionLimit *Asjoint_set_min_position_limit() {
    return type == Command_joint_set_min_position_limit ?
      reinterpret_cast<EMC::JointSetMinPositionLimit *>(value) : nullptr;
  }
  const EMC::JointSetMinPositionLimit *Asjoint_set_min_position_limit() const {
    return type == Command_joint_set_min_position_limit ?
      reinterpret_cast<const EMC::JointSetMinPositionLimit *>(value) : nullptr;
  }
  EMC::JointSetMaxPositionLimit *Asjoint_set_max_position_limit() {
    return type == Command_joint_set_max_position_limit ?
      reinterpret_cast<EMC::JointSetMaxPositionLimit *>(value) : nullptr;
  }
  const EMC::JointSetMaxPositionLimit *Asjoint_set_max_position_limit() const {
    return type == Command_joint_set_max_position_limit ?
      reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(value) : nullptr;
  }
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetDebug FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t debug_level_;

 public:
  SetDebug()
      : debug_level_(0) {
  }
  SetDebug(int32_t _debug_level)
      : debug_level_(flatbuffers::EndianScalar(_debug_level)) {
  }
  int32_t debug_level() const {
    return flatbuffers::EndianScalar(debug_level_);
  }
};
FLATBUFFERS_STRUCT_END(SetDebug, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JogCmd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_or_axis_;

 public:
  JogCmd()
      : joint_or_axis_(0) {
  }
  JogCmd(int32_t _joint_or_axis)
      : joint_or_axis_(flatbuffers::EndianScalar(_joint_or_axis)) {
  }
  int32_t joint_or_axis() const {
    return flatbuffers::EndianScalar(joint_or_axis_);
  }
};
FLATBUFFERS_STRUCT_END(JogCmd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetBacklash FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double backlash_;

 public:
  JointSetBacklash()
      : joint_(0),
        padding0__(0),
        backlash_(0) {
    (void)padding0__;
  }
  JointSetBacklash(int32_t _joint, double _backlash)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        backlash_(flatbuffers::EndianScalar(_backlash)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double backlash() const {
    return flatbuffers::EndianScalar(backlash_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetBacklash, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMinPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMinPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMinPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMinPositionLimit, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMaxPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMaxPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMaxPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMaxPositionLimit, 16);

struct CmdChannelMsgT : public flatbuffers::NativeTable {
  typedef CmdChannelMsg TableType;
  EMC::CommandUnion command;
  CmdChannelMsgT() {
  }
};

struct CmdChannelMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CmdChannelMsgT NativeTableType;
  typedef CmdChannelMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  EMC::Command command_type() const {
    return static_cast<EMC::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const EMC::SetDebug *command_as_set_debug() const {
    return command_type() == EMC::Command_set_debug ? static_cast<const EMC::SetDebug *>(command()) : nullptr;
  }
  const EMC::JogCmd *command_as_jog_cmd() const {
    return command_type() == EMC::Command_jog_cmd ? static_cast<const EMC::JogCmd *>(command()) : nullptr;
  }
  const EMC::JointSetBacklash *command_as_join_set_backlash() const {
    return command_type() == EMC::Command_join_set_backlash ? static_cast<const EMC::JointSetBacklash *>(command()) : nullptr;
  }
  const EMC::JointSetMinPositionLimit *command_as_joint_set_min_position_limit() const {
    return command_type() == EMC::Command_joint_set_min_position_limit ? static_cast<const EMC::JointSetMinPositionLimit *>(command()) : nullptr;
  }
  const EMC::JointSetMaxPositionLimit *command_as_joint_set_max_position_limit() const {
    return command_type() == EMC::Command_joint_set_max_position_limit ? static_cast<const EMC::JointSetMaxPositionLimit *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  CmdChannelMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CmdChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CmdChannelMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const EMC::SetDebug *CmdChannelMsg::command_as<EMC::SetDebug>() const {
  return command_as_set_debug();
}

template<> inline const EMC::JogCmd *CmdChannelMsg::command_as<EMC::JogCmd>() const {
  return command_as_jog_cmd();
}

template<> inline const EMC::JointSetBacklash *CmdChannelMsg::command_as<EMC::JointSetBacklash>() const {
  return command_as_join_set_backlash();
}

template<> inline const EMC::JointSetMinPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMinPositionLimit>() const {
  return command_as_joint_set_min_position_limit();
}

template<> inline const EMC::JointSetMaxPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMaxPositionLimit>() const {
  return command_as_joint_set_max_position_limit();
}

struct CmdChannelMsgBuilder {
  typedef CmdChannelMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command_type(EMC::Command command_type) {
    fbb_.AddElement<uint8_t>(CmdChannelMsg::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(CmdChannelMsg::VT_COMMAND, command);
  }
  explicit CmdChannelMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CmdChannelMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CmdChannelMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    EMC::Command command_type = EMC::Command_NONE,
    flatbuffers::Offset<void> command = 0) {
  CmdChannelMsgBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CmdChannelMsgT *CmdChannelMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::CmdChannelMsgT> _o = std::unique_ptr<EMC::CmdChannelMsgT>(new CmdChannelMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CmdChannelMsg::UnPackTo(CmdChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = EMC::CommandUnion::UnPack(_e, command_type(), _resolver); }
}

inline flatbuffers::Offset<CmdChannelMsg> CmdChannelMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCmdChannelMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CmdChannelMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return EMC::CreateCmdChannelMsg(
      _fbb,
      _command_type,
      _command);
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_set_debug: {
      return verifier.Verify<EMC::SetDebug>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_cmd: {
      return verifier.Verify<EMC::JogCmd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_join_set_backlash: {
      return verifier.Verify<EMC::JointSetBacklash>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_min_position_limit: {
      return verifier.Verify<EMC::JointSetMinPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_max_position_limit: {
      return verifier.Verify<EMC::JointSetMaxPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CommandUnion::UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<const EMC::SetDebug *>(obj);
      return new EMC::SetDebug(*ptr);
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<const EMC::JogCmd *>(obj);
      return new EMC::JogCmd(*ptr);
    }
    case Command_join_set_backlash: {
      auto ptr = reinterpret_cast<const EMC::JointSetBacklash *>(obj);
      return new EMC::JointSetBacklash(*ptr);
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinPositionLimit *>(obj);
      return new EMC::JointSetMinPositionLimit(*ptr);
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(obj);
      return new EMC::JointSetMaxPositionLimit(*ptr);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CommandUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<const EMC::SetDebug *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<const EMC::JogCmd *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_join_set_backlash: {
      auto ptr = reinterpret_cast<const EMC::JointSetBacklash *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinPositionLimit *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    default: return 0;
  }
}

inline CommandUnion::CommandUnion(const CommandUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Command_set_debug: {
      value = new EMC::SetDebug(*reinterpret_cast<EMC::SetDebug *>(u.value));
      break;
    }
    case Command_jog_cmd: {
      value = new EMC::JogCmd(*reinterpret_cast<EMC::JogCmd *>(u.value));
      break;
    }
    case Command_join_set_backlash: {
      value = new EMC::JointSetBacklash(*reinterpret_cast<EMC::JointSetBacklash *>(u.value));
      break;
    }
    case Command_joint_set_min_position_limit: {
      value = new EMC::JointSetMinPositionLimit(*reinterpret_cast<EMC::JointSetMinPositionLimit *>(u.value));
      break;
    }
    case Command_joint_set_max_position_limit: {
      value = new EMC::JointSetMaxPositionLimit(*reinterpret_cast<EMC::JointSetMaxPositionLimit *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CommandUnion::Reset() {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<EMC::SetDebug *>(value);
      delete ptr;
      break;
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<EMC::JogCmd *>(value);
      delete ptr;
      break;
    }
    case Command_join_set_backlash: {
      auto ptr = reinterpret_cast<EMC::JointSetBacklash *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<EMC::JointSetMinPositionLimit *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<EMC::JointSetMaxPositionLimit *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Command_NONE;
}

inline const EMC::CmdChannelMsg *GetCmdChannelMsg(const void *buf) {
  return flatbuffers::GetRoot<EMC::CmdChannelMsg>(buf);
}

inline const EMC::CmdChannelMsg *GetSizePrefixedCmdChannelMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EMC::CmdChannelMsg>(buf);
}

inline bool VerifyCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline bool VerifySizePrefixedCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline void FinishCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<EMC::CmdChannelMsgT> UnPackCmdChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::CmdChannelMsgT>(GetCmdChannelMsg(buf)->UnPack(res));
}

inline std::unique_ptr<EMC::CmdChannelMsgT> UnPackSizePrefixedCmdChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::CmdChannelMsgT>(GetSizePrefixedCmdChannelMsg(buf)->UnPack(res));
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
