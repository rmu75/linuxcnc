// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
#define FLATBUFFERS_GENERATED_EMCCMD_EMC_H_

#include "flatbuffers/flatbuffers.h"

#include "emc_common_generated.h"

namespace EMC {

struct SetDebug;

struct JogCmd;

struct JointSetBacklash;

struct JointSetMinPositionLimit;

struct JointSetMaxPositionLimit;

struct JointSetFerror;

struct JointSetMinFerror;

struct JointSetHomingParams;

struct JointHalt;

struct JointHome;

struct JointUnhome;

struct JogCont;

struct JogIncr;

struct JogAbs;

struct JogStop;

struct JointOverrideLimits;

struct JointLoadComp;
struct JointLoadCompBuilder;
struct JointLoadCompT;

struct TrajSetMode;

struct TrajSetVelocity;

struct TrajSetAcceleration;

struct TrajSetMaxVelocity;

struct TrajSetScale;

struct TrajSetRapidScale;

struct TrajSetSpindleScale;

struct TrajSetFOEnable;

struct TrajSetSOEnable;

struct TrajSetFHEnable;

struct TrajAbort;

struct TrajPause;

struct TrajResume;

struct TrajDelay;

struct TrajLinearMove;

struct TrajCircularMove;
struct TrajCircularMoveBuilder;
struct TrajCircularMoveT;

struct TrajSetTermCond;

struct TrajSetSpindleSync;

struct TrajSetOffset;

struct TrajSetG5x;

struct TrajSetG92;

struct TrajSetRotation;

struct TrajClearProbeTrippedFlag;

struct TrajSetTeleopEnable;

struct TrajProbe;

struct TrajRigidTap;

struct MotionSetAOut;

struct MotionSetDOut;

struct MotionAdaptive;

struct TaskAbort;

struct TaskSetMode;

struct TaskSetState;

struct TaskPlanOpen;
struct TaskPlanOpenBuilder;
struct TaskPlanOpenT;

struct TaskPlanRun;

struct TaskPlanExecute;
struct TaskPlanExecuteBuilder;
struct TaskPlanExecuteT;

struct TaskPlanReverse;

struct TaskPlanForward;

struct TaskPlanStep;

struct TaskPlanResume;

struct TaskPlanEnd;

struct TaskPlanClose;

struct TaskPlanInit;

struct TaskPlanSynch;

struct TaskPlanSetOptionalStop;

struct TaskPlanSetBlockDelete;

struct TaskPlanOptionalStop;

struct ToolCmd;

struct ToolHalt;

struct ToolAbort;

struct ToolPrepare;

struct ToolLoad;

struct ToolLoadToolTable;
struct ToolLoadToolTableBuilder;
struct ToolLoadToolTableT;

struct ToolSetOffset;

struct ToolSetNumber;

struct AuxInputWait;

struct SpindleSpeed;

struct SpindleOrient;

struct SpindleWaitOrient;

struct SpindleOn;

struct SpindleOff;

struct SpindleIncrease;

struct SpindleDecrease;

struct SpindleConstant;

struct SpindleBrakeRelease;

struct SpindleBrakeEngage;

struct CoolantMistOn;

struct CoolantMistOff;

struct CoolantFloodOn;

struct CoolantFloodOff;

struct CmdChannelMsg;
struct CmdChannelMsgBuilder;
struct CmdChannelMsgT;

struct DebugLevel;
struct DebugLevelBuilder;
struct DebugLevelT;

struct Result;
struct ResultBuilder;
struct ResultT;

enum Command {
  Command_NONE = 0,
  Command_set_debug = 1,
  Command_jog_cmd = 2,
  Command_joint_set_backlash = 3,
  Command_joint_set_min_position_limit = 4,
  Command_joint_set_max_position_limit = 5,
  Command_joint_set_ferror = 6,
  Command_joint_set_min_ferror = 7,
  Command_joint_set_homing_params = 8,
  Command_joint_home = 9,
  Command_joint_unhome = 10,
  Command_joint_halt = 11,
  Command_jog_cont = 12,
  Command_jog_incr = 13,
  Command_jog_abs = 14,
  Command_jog_stop = 15,
  Command_joint_override_limits = 16,
  Command_joint_load_comp = 17,
  Command_traj_set_mode = 18,
  Command_traj_set_velocity = 19,
  Command_tral_set_acceleration = 20,
  Command_traj_set_max_velocity = 21,
  Command_traj_set_scale = 22,
  Command_traj_set_rapid_scale = 23,
  Command_traj_set_spindl_scale = 24,
  Command_traj_set_fo_enable = 25,
  Command_traj_set_so_enable = 26,
  Command_traj_set_fh_enable = 27,
  Command_traj_abort = 28,
  Command_traj_pause = 29,
  Command_traj_resume = 30,
  Command_traj_delay = 31,
  Command_traj_linear_move = 32,
  Command_traj_circular_move = 33,
  Command_traj_set_term_cond = 34,
  Command_traj_set_spindle_sync = 35,
  Command_traj_set_offset = 36,
  Command_traj_set_g5x = 37,
  Command_traj_set_g92 = 38,
  Command_traj_set_rotation = 39,
  Command_traj_clear_probe_tripped_flag = 40,
  Command_traj_set_teleop_enable = 41,
  Command_traj_probe = 42,
  Command_traj_rigid_tap = 43,
  Command_motion_set_aout = 44,
  Command_motion_set_dout = 45,
  Command_motion_adaptive = 46,
  Command_task_abort = 47,
  Command_task_set_mode = 48,
  Command_task_set_state = 49,
  Command_task_plan_open = 50,
  Command_task_plan_run = 51,
  Command_task_plan_execute = 52,
  Command_task_plan_reverse = 53,
  Command_task_plan_forward = 54,
  Command_task_plan_step = 55,
  Command_task_plan_resume = 56,
  Command_task_plan_end = 57,
  Command_task_plan_close = 58,
  Command_task_plan_init = 59,
  Command_task_plan_synch = 60,
  Command_task_plan_set_optional_stop = 61,
  Command_task_plan_set_block_delete = 62,
  Command_task_plan_optional_stop = 63,
  Command_tool_cmd = 64,
  Command_tool_halt = 65,
  Command_tool_abort = 66,
  Command_tool_prepare = 67,
  Command_tool_load = 68,
  Command_tool_load_tool_table = 69,
  Command_tool_set_offset = 70,
  Command_tool_set_number = 71,
  Command_aux_input_wait = 72,
  Command_spindle_speed = 73,
  Command_spindle_orient = 74,
  Command_spindle_wait_orient = 75,
  Command_spindle_on = 76,
  Command_spindle_off = 77,
  Command_spindle_increase = 78,
  Command_spindle_decrease = 79,
  Command_spindle_constant = 80,
  Command_spindle_brake_release = 81,
  Command_spindle_brake_engage = 82,
  Command_coolant_mist_on = 83,
  Command_coolant_mist_off = 84,
  Command_coolant_flood_on = 85,
  Command_coolant_flood_off = 86,
  Command_MIN = Command_NONE,
  Command_MAX = Command_coolant_flood_off
};

inline const Command (&EnumValuesCommand())[87] {
  static const Command values[] = {
    Command_NONE,
    Command_set_debug,
    Command_jog_cmd,
    Command_joint_set_backlash,
    Command_joint_set_min_position_limit,
    Command_joint_set_max_position_limit,
    Command_joint_set_ferror,
    Command_joint_set_min_ferror,
    Command_joint_set_homing_params,
    Command_joint_home,
    Command_joint_unhome,
    Command_joint_halt,
    Command_jog_cont,
    Command_jog_incr,
    Command_jog_abs,
    Command_jog_stop,
    Command_joint_override_limits,
    Command_joint_load_comp,
    Command_traj_set_mode,
    Command_traj_set_velocity,
    Command_tral_set_acceleration,
    Command_traj_set_max_velocity,
    Command_traj_set_scale,
    Command_traj_set_rapid_scale,
    Command_traj_set_spindl_scale,
    Command_traj_set_fo_enable,
    Command_traj_set_so_enable,
    Command_traj_set_fh_enable,
    Command_traj_abort,
    Command_traj_pause,
    Command_traj_resume,
    Command_traj_delay,
    Command_traj_linear_move,
    Command_traj_circular_move,
    Command_traj_set_term_cond,
    Command_traj_set_spindle_sync,
    Command_traj_set_offset,
    Command_traj_set_g5x,
    Command_traj_set_g92,
    Command_traj_set_rotation,
    Command_traj_clear_probe_tripped_flag,
    Command_traj_set_teleop_enable,
    Command_traj_probe,
    Command_traj_rigid_tap,
    Command_motion_set_aout,
    Command_motion_set_dout,
    Command_motion_adaptive,
    Command_task_abort,
    Command_task_set_mode,
    Command_task_set_state,
    Command_task_plan_open,
    Command_task_plan_run,
    Command_task_plan_execute,
    Command_task_plan_reverse,
    Command_task_plan_forward,
    Command_task_plan_step,
    Command_task_plan_resume,
    Command_task_plan_end,
    Command_task_plan_close,
    Command_task_plan_init,
    Command_task_plan_synch,
    Command_task_plan_set_optional_stop,
    Command_task_plan_set_block_delete,
    Command_task_plan_optional_stop,
    Command_tool_cmd,
    Command_tool_halt,
    Command_tool_abort,
    Command_tool_prepare,
    Command_tool_load,
    Command_tool_load_tool_table,
    Command_tool_set_offset,
    Command_tool_set_number,
    Command_aux_input_wait,
    Command_spindle_speed,
    Command_spindle_orient,
    Command_spindle_wait_orient,
    Command_spindle_on,
    Command_spindle_off,
    Command_spindle_increase,
    Command_spindle_decrease,
    Command_spindle_constant,
    Command_spindle_brake_release,
    Command_spindle_brake_engage,
    Command_coolant_mist_on,
    Command_coolant_mist_off,
    Command_coolant_flood_on,
    Command_coolant_flood_off
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[88] = {
    "NONE",
    "set_debug",
    "jog_cmd",
    "joint_set_backlash",
    "joint_set_min_position_limit",
    "joint_set_max_position_limit",
    "joint_set_ferror",
    "joint_set_min_ferror",
    "joint_set_homing_params",
    "joint_home",
    "joint_unhome",
    "joint_halt",
    "jog_cont",
    "jog_incr",
    "jog_abs",
    "jog_stop",
    "joint_override_limits",
    "joint_load_comp",
    "traj_set_mode",
    "traj_set_velocity",
    "tral_set_acceleration",
    "traj_set_max_velocity",
    "traj_set_scale",
    "traj_set_rapid_scale",
    "traj_set_spindl_scale",
    "traj_set_fo_enable",
    "traj_set_so_enable",
    "traj_set_fh_enable",
    "traj_abort",
    "traj_pause",
    "traj_resume",
    "traj_delay",
    "traj_linear_move",
    "traj_circular_move",
    "traj_set_term_cond",
    "traj_set_spindle_sync",
    "traj_set_offset",
    "traj_set_g5x",
    "traj_set_g92",
    "traj_set_rotation",
    "traj_clear_probe_tripped_flag",
    "traj_set_teleop_enable",
    "traj_probe",
    "traj_rigid_tap",
    "motion_set_aout",
    "motion_set_dout",
    "motion_adaptive",
    "task_abort",
    "task_set_mode",
    "task_set_state",
    "task_plan_open",
    "task_plan_run",
    "task_plan_execute",
    "task_plan_reverse",
    "task_plan_forward",
    "task_plan_step",
    "task_plan_resume",
    "task_plan_end",
    "task_plan_close",
    "task_plan_init",
    "task_plan_synch",
    "task_plan_set_optional_stop",
    "task_plan_set_block_delete",
    "task_plan_optional_stop",
    "tool_cmd",
    "tool_halt",
    "tool_abort",
    "tool_prepare",
    "tool_load",
    "tool_load_tool_table",
    "tool_set_offset",
    "tool_set_number",
    "aux_input_wait",
    "spindle_speed",
    "spindle_orient",
    "spindle_wait_orient",
    "spindle_on",
    "spindle_off",
    "spindle_increase",
    "spindle_decrease",
    "spindle_constant",
    "spindle_brake_release",
    "spindle_brake_engage",
    "coolant_mist_on",
    "coolant_mist_off",
    "coolant_flood_on",
    "coolant_flood_off",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (flatbuffers::IsOutRange(e, Command_NONE, Command_coolant_flood_off)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<EMC::SetDebug> {
  static const Command enum_value = Command_set_debug;
};

template<> struct CommandTraits<EMC::JogCmd> {
  static const Command enum_value = Command_jog_cmd;
};

template<> struct CommandTraits<EMC::JointSetBacklash> {
  static const Command enum_value = Command_joint_set_backlash;
};

template<> struct CommandTraits<EMC::JointSetMinPositionLimit> {
  static const Command enum_value = Command_joint_set_min_position_limit;
};

template<> struct CommandTraits<EMC::JointSetMaxPositionLimit> {
  static const Command enum_value = Command_joint_set_max_position_limit;
};

template<> struct CommandTraits<EMC::JointSetFerror> {
  static const Command enum_value = Command_joint_set_ferror;
};

template<> struct CommandTraits<EMC::JointSetMinFerror> {
  static const Command enum_value = Command_joint_set_min_ferror;
};

template<> struct CommandTraits<EMC::JointSetHomingParams> {
  static const Command enum_value = Command_joint_set_homing_params;
};

template<> struct CommandTraits<EMC::JointHome> {
  static const Command enum_value = Command_joint_home;
};

template<> struct CommandTraits<EMC::JointUnhome> {
  static const Command enum_value = Command_joint_unhome;
};

template<> struct CommandTraits<EMC::JointHalt> {
  static const Command enum_value = Command_joint_halt;
};

template<> struct CommandTraits<EMC::JogCont> {
  static const Command enum_value = Command_jog_cont;
};

template<> struct CommandTraits<EMC::JogIncr> {
  static const Command enum_value = Command_jog_incr;
};

template<> struct CommandTraits<EMC::JogAbs> {
  static const Command enum_value = Command_jog_abs;
};

template<> struct CommandTraits<EMC::JogStop> {
  static const Command enum_value = Command_jog_stop;
};

template<> struct CommandTraits<EMC::JointOverrideLimits> {
  static const Command enum_value = Command_joint_override_limits;
};

template<> struct CommandTraits<EMC::JointLoadComp> {
  static const Command enum_value = Command_joint_load_comp;
};

template<> struct CommandTraits<EMC::TrajSetMode> {
  static const Command enum_value = Command_traj_set_mode;
};

template<> struct CommandTraits<EMC::TrajSetVelocity> {
  static const Command enum_value = Command_traj_set_velocity;
};

template<> struct CommandTraits<EMC::TrajSetAcceleration> {
  static const Command enum_value = Command_tral_set_acceleration;
};

template<> struct CommandTraits<EMC::TrajSetMaxVelocity> {
  static const Command enum_value = Command_traj_set_max_velocity;
};

template<> struct CommandTraits<EMC::TrajSetScale> {
  static const Command enum_value = Command_traj_set_scale;
};

template<> struct CommandTraits<EMC::TrajSetRapidScale> {
  static const Command enum_value = Command_traj_set_rapid_scale;
};

template<> struct CommandTraits<EMC::TrajSetSpindleScale> {
  static const Command enum_value = Command_traj_set_spindl_scale;
};

template<> struct CommandTraits<EMC::TrajSetFOEnable> {
  static const Command enum_value = Command_traj_set_fo_enable;
};

template<> struct CommandTraits<EMC::TrajSetSOEnable> {
  static const Command enum_value = Command_traj_set_so_enable;
};

template<> struct CommandTraits<EMC::TrajSetFHEnable> {
  static const Command enum_value = Command_traj_set_fh_enable;
};

template<> struct CommandTraits<EMC::TrajAbort> {
  static const Command enum_value = Command_traj_abort;
};

template<> struct CommandTraits<EMC::TrajPause> {
  static const Command enum_value = Command_traj_pause;
};

template<> struct CommandTraits<EMC::TrajResume> {
  static const Command enum_value = Command_traj_resume;
};

template<> struct CommandTraits<EMC::TrajDelay> {
  static const Command enum_value = Command_traj_delay;
};

template<> struct CommandTraits<EMC::TrajLinearMove> {
  static const Command enum_value = Command_traj_linear_move;
};

template<> struct CommandTraits<EMC::TrajCircularMove> {
  static const Command enum_value = Command_traj_circular_move;
};

template<> struct CommandTraits<EMC::TrajSetTermCond> {
  static const Command enum_value = Command_traj_set_term_cond;
};

template<> struct CommandTraits<EMC::TrajSetSpindleSync> {
  static const Command enum_value = Command_traj_set_spindle_sync;
};

template<> struct CommandTraits<EMC::TrajSetOffset> {
  static const Command enum_value = Command_traj_set_offset;
};

template<> struct CommandTraits<EMC::TrajSetG5x> {
  static const Command enum_value = Command_traj_set_g5x;
};

template<> struct CommandTraits<EMC::TrajSetG92> {
  static const Command enum_value = Command_traj_set_g92;
};

template<> struct CommandTraits<EMC::TrajSetRotation> {
  static const Command enum_value = Command_traj_set_rotation;
};

template<> struct CommandTraits<EMC::TrajClearProbeTrippedFlag> {
  static const Command enum_value = Command_traj_clear_probe_tripped_flag;
};

template<> struct CommandTraits<EMC::TrajSetTeleopEnable> {
  static const Command enum_value = Command_traj_set_teleop_enable;
};

template<> struct CommandTraits<EMC::TrajProbe> {
  static const Command enum_value = Command_traj_probe;
};

template<> struct CommandTraits<EMC::TrajRigidTap> {
  static const Command enum_value = Command_traj_rigid_tap;
};

template<> struct CommandTraits<EMC::MotionSetAOut> {
  static const Command enum_value = Command_motion_set_aout;
};

template<> struct CommandTraits<EMC::MotionSetDOut> {
  static const Command enum_value = Command_motion_set_dout;
};

template<> struct CommandTraits<EMC::MotionAdaptive> {
  static const Command enum_value = Command_motion_adaptive;
};

template<> struct CommandTraits<EMC::TaskAbort> {
  static const Command enum_value = Command_task_abort;
};

template<> struct CommandTraits<EMC::TaskSetMode> {
  static const Command enum_value = Command_task_set_mode;
};

template<> struct CommandTraits<EMC::TaskSetState> {
  static const Command enum_value = Command_task_set_state;
};

template<> struct CommandTraits<EMC::TaskPlanOpen> {
  static const Command enum_value = Command_task_plan_open;
};

template<> struct CommandTraits<EMC::TaskPlanRun> {
  static const Command enum_value = Command_task_plan_run;
};

template<> struct CommandTraits<EMC::TaskPlanExecute> {
  static const Command enum_value = Command_task_plan_execute;
};

template<> struct CommandTraits<EMC::TaskPlanReverse> {
  static const Command enum_value = Command_task_plan_reverse;
};

template<> struct CommandTraits<EMC::TaskPlanForward> {
  static const Command enum_value = Command_task_plan_forward;
};

template<> struct CommandTraits<EMC::TaskPlanStep> {
  static const Command enum_value = Command_task_plan_step;
};

template<> struct CommandTraits<EMC::TaskPlanResume> {
  static const Command enum_value = Command_task_plan_resume;
};

template<> struct CommandTraits<EMC::TaskPlanEnd> {
  static const Command enum_value = Command_task_plan_end;
};

template<> struct CommandTraits<EMC::TaskPlanClose> {
  static const Command enum_value = Command_task_plan_close;
};

template<> struct CommandTraits<EMC::TaskPlanInit> {
  static const Command enum_value = Command_task_plan_init;
};

template<> struct CommandTraits<EMC::TaskPlanSynch> {
  static const Command enum_value = Command_task_plan_synch;
};

template<> struct CommandTraits<EMC::TaskPlanSetOptionalStop> {
  static const Command enum_value = Command_task_plan_set_optional_stop;
};

template<> struct CommandTraits<EMC::TaskPlanSetBlockDelete> {
  static const Command enum_value = Command_task_plan_set_block_delete;
};

template<> struct CommandTraits<EMC::TaskPlanOptionalStop> {
  static const Command enum_value = Command_task_plan_optional_stop;
};

template<> struct CommandTraits<EMC::ToolCmd> {
  static const Command enum_value = Command_tool_cmd;
};

template<> struct CommandTraits<EMC::ToolHalt> {
  static const Command enum_value = Command_tool_halt;
};

template<> struct CommandTraits<EMC::ToolAbort> {
  static const Command enum_value = Command_tool_abort;
};

template<> struct CommandTraits<EMC::ToolPrepare> {
  static const Command enum_value = Command_tool_prepare;
};

template<> struct CommandTraits<EMC::ToolLoad> {
  static const Command enum_value = Command_tool_load;
};

template<> struct CommandTraits<EMC::ToolLoadToolTable> {
  static const Command enum_value = Command_tool_load_tool_table;
};

template<> struct CommandTraits<EMC::ToolSetOffset> {
  static const Command enum_value = Command_tool_set_offset;
};

template<> struct CommandTraits<EMC::ToolSetNumber> {
  static const Command enum_value = Command_tool_set_number;
};

template<> struct CommandTraits<EMC::AuxInputWait> {
  static const Command enum_value = Command_aux_input_wait;
};

template<> struct CommandTraits<EMC::SpindleSpeed> {
  static const Command enum_value = Command_spindle_speed;
};

template<> struct CommandTraits<EMC::SpindleOrient> {
  static const Command enum_value = Command_spindle_orient;
};

template<> struct CommandTraits<EMC::SpindleWaitOrient> {
  static const Command enum_value = Command_spindle_wait_orient;
};

template<> struct CommandTraits<EMC::SpindleOn> {
  static const Command enum_value = Command_spindle_on;
};

template<> struct CommandTraits<EMC::SpindleOff> {
  static const Command enum_value = Command_spindle_off;
};

template<> struct CommandTraits<EMC::SpindleIncrease> {
  static const Command enum_value = Command_spindle_increase;
};

template<> struct CommandTraits<EMC::SpindleDecrease> {
  static const Command enum_value = Command_spindle_decrease;
};

template<> struct CommandTraits<EMC::SpindleConstant> {
  static const Command enum_value = Command_spindle_constant;
};

template<> struct CommandTraits<EMC::SpindleBrakeRelease> {
  static const Command enum_value = Command_spindle_brake_release;
};

template<> struct CommandTraits<EMC::SpindleBrakeEngage> {
  static const Command enum_value = Command_spindle_brake_engage;
};

template<> struct CommandTraits<EMC::CoolantMistOn> {
  static const Command enum_value = Command_coolant_mist_on;
};

template<> struct CommandTraits<EMC::CoolantMistOff> {
  static const Command enum_value = Command_coolant_mist_off;
};

template<> struct CommandTraits<EMC::CoolantFloodOn> {
  static const Command enum_value = Command_coolant_flood_on;
};

template<> struct CommandTraits<EMC::CoolantFloodOff> {
  static const Command enum_value = Command_coolant_flood_off;
};

struct CommandUnion {
  Command type;
  void *value;

  CommandUnion() : type(Command_NONE), value(nullptr) {}
  CommandUnion(CommandUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Command_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  CommandUnion(const CommandUnion &);
  CommandUnion &operator=(const CommandUnion &u)
    { CommandUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  CommandUnion &operator=(CommandUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~CommandUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = CommandTraits<typename RT::TableType>::enum_value;
    if (type != Command_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  EMC::SetDebug *Asset_debug() {
    return type == Command_set_debug ?
      reinterpret_cast<EMC::SetDebug *>(value) : nullptr;
  }
  const EMC::SetDebug *Asset_debug() const {
    return type == Command_set_debug ?
      reinterpret_cast<const EMC::SetDebug *>(value) : nullptr;
  }
  EMC::JogCmd *Asjog_cmd() {
    return type == Command_jog_cmd ?
      reinterpret_cast<EMC::JogCmd *>(value) : nullptr;
  }
  const EMC::JogCmd *Asjog_cmd() const {
    return type == Command_jog_cmd ?
      reinterpret_cast<const EMC::JogCmd *>(value) : nullptr;
  }
  EMC::JointSetBacklash *Asjoint_set_backlash() {
    return type == Command_joint_set_backlash ?
      reinterpret_cast<EMC::JointSetBacklash *>(value) : nullptr;
  }
  const EMC::JointSetBacklash *Asjoint_set_backlash() const {
    return type == Command_joint_set_backlash ?
      reinterpret_cast<const EMC::JointSetBacklash *>(value) : nullptr;
  }
  EMC::JointSetMinPositionLimit *Asjoint_set_min_position_limit() {
    return type == Command_joint_set_min_position_limit ?
      reinterpret_cast<EMC::JointSetMinPositionLimit *>(value) : nullptr;
  }
  const EMC::JointSetMinPositionLimit *Asjoint_set_min_position_limit() const {
    return type == Command_joint_set_min_position_limit ?
      reinterpret_cast<const EMC::JointSetMinPositionLimit *>(value) : nullptr;
  }
  EMC::JointSetMaxPositionLimit *Asjoint_set_max_position_limit() {
    return type == Command_joint_set_max_position_limit ?
      reinterpret_cast<EMC::JointSetMaxPositionLimit *>(value) : nullptr;
  }
  const EMC::JointSetMaxPositionLimit *Asjoint_set_max_position_limit() const {
    return type == Command_joint_set_max_position_limit ?
      reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(value) : nullptr;
  }
  EMC::JointSetFerror *Asjoint_set_ferror() {
    return type == Command_joint_set_ferror ?
      reinterpret_cast<EMC::JointSetFerror *>(value) : nullptr;
  }
  const EMC::JointSetFerror *Asjoint_set_ferror() const {
    return type == Command_joint_set_ferror ?
      reinterpret_cast<const EMC::JointSetFerror *>(value) : nullptr;
  }
  EMC::JointSetMinFerror *Asjoint_set_min_ferror() {
    return type == Command_joint_set_min_ferror ?
      reinterpret_cast<EMC::JointSetMinFerror *>(value) : nullptr;
  }
  const EMC::JointSetMinFerror *Asjoint_set_min_ferror() const {
    return type == Command_joint_set_min_ferror ?
      reinterpret_cast<const EMC::JointSetMinFerror *>(value) : nullptr;
  }
  EMC::JointSetHomingParams *Asjoint_set_homing_params() {
    return type == Command_joint_set_homing_params ?
      reinterpret_cast<EMC::JointSetHomingParams *>(value) : nullptr;
  }
  const EMC::JointSetHomingParams *Asjoint_set_homing_params() const {
    return type == Command_joint_set_homing_params ?
      reinterpret_cast<const EMC::JointSetHomingParams *>(value) : nullptr;
  }
  EMC::JointHome *Asjoint_home() {
    return type == Command_joint_home ?
      reinterpret_cast<EMC::JointHome *>(value) : nullptr;
  }
  const EMC::JointHome *Asjoint_home() const {
    return type == Command_joint_home ?
      reinterpret_cast<const EMC::JointHome *>(value) : nullptr;
  }
  EMC::JointUnhome *Asjoint_unhome() {
    return type == Command_joint_unhome ?
      reinterpret_cast<EMC::JointUnhome *>(value) : nullptr;
  }
  const EMC::JointUnhome *Asjoint_unhome() const {
    return type == Command_joint_unhome ?
      reinterpret_cast<const EMC::JointUnhome *>(value) : nullptr;
  }
  EMC::JointHalt *Asjoint_halt() {
    return type == Command_joint_halt ?
      reinterpret_cast<EMC::JointHalt *>(value) : nullptr;
  }
  const EMC::JointHalt *Asjoint_halt() const {
    return type == Command_joint_halt ?
      reinterpret_cast<const EMC::JointHalt *>(value) : nullptr;
  }
  EMC::JogCont *Asjog_cont() {
    return type == Command_jog_cont ?
      reinterpret_cast<EMC::JogCont *>(value) : nullptr;
  }
  const EMC::JogCont *Asjog_cont() const {
    return type == Command_jog_cont ?
      reinterpret_cast<const EMC::JogCont *>(value) : nullptr;
  }
  EMC::JogIncr *Asjog_incr() {
    return type == Command_jog_incr ?
      reinterpret_cast<EMC::JogIncr *>(value) : nullptr;
  }
  const EMC::JogIncr *Asjog_incr() const {
    return type == Command_jog_incr ?
      reinterpret_cast<const EMC::JogIncr *>(value) : nullptr;
  }
  EMC::JogAbs *Asjog_abs() {
    return type == Command_jog_abs ?
      reinterpret_cast<EMC::JogAbs *>(value) : nullptr;
  }
  const EMC::JogAbs *Asjog_abs() const {
    return type == Command_jog_abs ?
      reinterpret_cast<const EMC::JogAbs *>(value) : nullptr;
  }
  EMC::JogStop *Asjog_stop() {
    return type == Command_jog_stop ?
      reinterpret_cast<EMC::JogStop *>(value) : nullptr;
  }
  const EMC::JogStop *Asjog_stop() const {
    return type == Command_jog_stop ?
      reinterpret_cast<const EMC::JogStop *>(value) : nullptr;
  }
  EMC::JointOverrideLimits *Asjoint_override_limits() {
    return type == Command_joint_override_limits ?
      reinterpret_cast<EMC::JointOverrideLimits *>(value) : nullptr;
  }
  const EMC::JointOverrideLimits *Asjoint_override_limits() const {
    return type == Command_joint_override_limits ?
      reinterpret_cast<const EMC::JointOverrideLimits *>(value) : nullptr;
  }
  EMC::JointLoadCompT *Asjoint_load_comp() {
    return type == Command_joint_load_comp ?
      reinterpret_cast<EMC::JointLoadCompT *>(value) : nullptr;
  }
  const EMC::JointLoadCompT *Asjoint_load_comp() const {
    return type == Command_joint_load_comp ?
      reinterpret_cast<const EMC::JointLoadCompT *>(value) : nullptr;
  }
  EMC::TrajSetMode *Astraj_set_mode() {
    return type == Command_traj_set_mode ?
      reinterpret_cast<EMC::TrajSetMode *>(value) : nullptr;
  }
  const EMC::TrajSetMode *Astraj_set_mode() const {
    return type == Command_traj_set_mode ?
      reinterpret_cast<const EMC::TrajSetMode *>(value) : nullptr;
  }
  EMC::TrajSetVelocity *Astraj_set_velocity() {
    return type == Command_traj_set_velocity ?
      reinterpret_cast<EMC::TrajSetVelocity *>(value) : nullptr;
  }
  const EMC::TrajSetVelocity *Astraj_set_velocity() const {
    return type == Command_traj_set_velocity ?
      reinterpret_cast<const EMC::TrajSetVelocity *>(value) : nullptr;
  }
  EMC::TrajSetAcceleration *Astral_set_acceleration() {
    return type == Command_tral_set_acceleration ?
      reinterpret_cast<EMC::TrajSetAcceleration *>(value) : nullptr;
  }
  const EMC::TrajSetAcceleration *Astral_set_acceleration() const {
    return type == Command_tral_set_acceleration ?
      reinterpret_cast<const EMC::TrajSetAcceleration *>(value) : nullptr;
  }
  EMC::TrajSetMaxVelocity *Astraj_set_max_velocity() {
    return type == Command_traj_set_max_velocity ?
      reinterpret_cast<EMC::TrajSetMaxVelocity *>(value) : nullptr;
  }
  const EMC::TrajSetMaxVelocity *Astraj_set_max_velocity() const {
    return type == Command_traj_set_max_velocity ?
      reinterpret_cast<const EMC::TrajSetMaxVelocity *>(value) : nullptr;
  }
  EMC::TrajSetScale *Astraj_set_scale() {
    return type == Command_traj_set_scale ?
      reinterpret_cast<EMC::TrajSetScale *>(value) : nullptr;
  }
  const EMC::TrajSetScale *Astraj_set_scale() const {
    return type == Command_traj_set_scale ?
      reinterpret_cast<const EMC::TrajSetScale *>(value) : nullptr;
  }
  EMC::TrajSetRapidScale *Astraj_set_rapid_scale() {
    return type == Command_traj_set_rapid_scale ?
      reinterpret_cast<EMC::TrajSetRapidScale *>(value) : nullptr;
  }
  const EMC::TrajSetRapidScale *Astraj_set_rapid_scale() const {
    return type == Command_traj_set_rapid_scale ?
      reinterpret_cast<const EMC::TrajSetRapidScale *>(value) : nullptr;
  }
  EMC::TrajSetSpindleScale *Astraj_set_spindl_scale() {
    return type == Command_traj_set_spindl_scale ?
      reinterpret_cast<EMC::TrajSetSpindleScale *>(value) : nullptr;
  }
  const EMC::TrajSetSpindleScale *Astraj_set_spindl_scale() const {
    return type == Command_traj_set_spindl_scale ?
      reinterpret_cast<const EMC::TrajSetSpindleScale *>(value) : nullptr;
  }
  EMC::TrajSetFOEnable *Astraj_set_fo_enable() {
    return type == Command_traj_set_fo_enable ?
      reinterpret_cast<EMC::TrajSetFOEnable *>(value) : nullptr;
  }
  const EMC::TrajSetFOEnable *Astraj_set_fo_enable() const {
    return type == Command_traj_set_fo_enable ?
      reinterpret_cast<const EMC::TrajSetFOEnable *>(value) : nullptr;
  }
  EMC::TrajSetSOEnable *Astraj_set_so_enable() {
    return type == Command_traj_set_so_enable ?
      reinterpret_cast<EMC::TrajSetSOEnable *>(value) : nullptr;
  }
  const EMC::TrajSetSOEnable *Astraj_set_so_enable() const {
    return type == Command_traj_set_so_enable ?
      reinterpret_cast<const EMC::TrajSetSOEnable *>(value) : nullptr;
  }
  EMC::TrajSetFHEnable *Astraj_set_fh_enable() {
    return type == Command_traj_set_fh_enable ?
      reinterpret_cast<EMC::TrajSetFHEnable *>(value) : nullptr;
  }
  const EMC::TrajSetFHEnable *Astraj_set_fh_enable() const {
    return type == Command_traj_set_fh_enable ?
      reinterpret_cast<const EMC::TrajSetFHEnable *>(value) : nullptr;
  }
  EMC::TrajAbort *Astraj_abort() {
    return type == Command_traj_abort ?
      reinterpret_cast<EMC::TrajAbort *>(value) : nullptr;
  }
  const EMC::TrajAbort *Astraj_abort() const {
    return type == Command_traj_abort ?
      reinterpret_cast<const EMC::TrajAbort *>(value) : nullptr;
  }
  EMC::TrajPause *Astraj_pause() {
    return type == Command_traj_pause ?
      reinterpret_cast<EMC::TrajPause *>(value) : nullptr;
  }
  const EMC::TrajPause *Astraj_pause() const {
    return type == Command_traj_pause ?
      reinterpret_cast<const EMC::TrajPause *>(value) : nullptr;
  }
  EMC::TrajResume *Astraj_resume() {
    return type == Command_traj_resume ?
      reinterpret_cast<EMC::TrajResume *>(value) : nullptr;
  }
  const EMC::TrajResume *Astraj_resume() const {
    return type == Command_traj_resume ?
      reinterpret_cast<const EMC::TrajResume *>(value) : nullptr;
  }
  EMC::TrajDelay *Astraj_delay() {
    return type == Command_traj_delay ?
      reinterpret_cast<EMC::TrajDelay *>(value) : nullptr;
  }
  const EMC::TrajDelay *Astraj_delay() const {
    return type == Command_traj_delay ?
      reinterpret_cast<const EMC::TrajDelay *>(value) : nullptr;
  }
  EMC::TrajLinearMove *Astraj_linear_move() {
    return type == Command_traj_linear_move ?
      reinterpret_cast<EMC::TrajLinearMove *>(value) : nullptr;
  }
  const EMC::TrajLinearMove *Astraj_linear_move() const {
    return type == Command_traj_linear_move ?
      reinterpret_cast<const EMC::TrajLinearMove *>(value) : nullptr;
  }
  EMC::TrajCircularMoveT *Astraj_circular_move() {
    return type == Command_traj_circular_move ?
      reinterpret_cast<EMC::TrajCircularMoveT *>(value) : nullptr;
  }
  const EMC::TrajCircularMoveT *Astraj_circular_move() const {
    return type == Command_traj_circular_move ?
      reinterpret_cast<const EMC::TrajCircularMoveT *>(value) : nullptr;
  }
  EMC::TrajSetTermCond *Astraj_set_term_cond() {
    return type == Command_traj_set_term_cond ?
      reinterpret_cast<EMC::TrajSetTermCond *>(value) : nullptr;
  }
  const EMC::TrajSetTermCond *Astraj_set_term_cond() const {
    return type == Command_traj_set_term_cond ?
      reinterpret_cast<const EMC::TrajSetTermCond *>(value) : nullptr;
  }
  EMC::TrajSetSpindleSync *Astraj_set_spindle_sync() {
    return type == Command_traj_set_spindle_sync ?
      reinterpret_cast<EMC::TrajSetSpindleSync *>(value) : nullptr;
  }
  const EMC::TrajSetSpindleSync *Astraj_set_spindle_sync() const {
    return type == Command_traj_set_spindle_sync ?
      reinterpret_cast<const EMC::TrajSetSpindleSync *>(value) : nullptr;
  }
  EMC::TrajSetOffset *Astraj_set_offset() {
    return type == Command_traj_set_offset ?
      reinterpret_cast<EMC::TrajSetOffset *>(value) : nullptr;
  }
  const EMC::TrajSetOffset *Astraj_set_offset() const {
    return type == Command_traj_set_offset ?
      reinterpret_cast<const EMC::TrajSetOffset *>(value) : nullptr;
  }
  EMC::TrajSetG5x *Astraj_set_g5x() {
    return type == Command_traj_set_g5x ?
      reinterpret_cast<EMC::TrajSetG5x *>(value) : nullptr;
  }
  const EMC::TrajSetG5x *Astraj_set_g5x() const {
    return type == Command_traj_set_g5x ?
      reinterpret_cast<const EMC::TrajSetG5x *>(value) : nullptr;
  }
  EMC::TrajSetG92 *Astraj_set_g92() {
    return type == Command_traj_set_g92 ?
      reinterpret_cast<EMC::TrajSetG92 *>(value) : nullptr;
  }
  const EMC::TrajSetG92 *Astraj_set_g92() const {
    return type == Command_traj_set_g92 ?
      reinterpret_cast<const EMC::TrajSetG92 *>(value) : nullptr;
  }
  EMC::TrajSetRotation *Astraj_set_rotation() {
    return type == Command_traj_set_rotation ?
      reinterpret_cast<EMC::TrajSetRotation *>(value) : nullptr;
  }
  const EMC::TrajSetRotation *Astraj_set_rotation() const {
    return type == Command_traj_set_rotation ?
      reinterpret_cast<const EMC::TrajSetRotation *>(value) : nullptr;
  }
  EMC::TrajClearProbeTrippedFlag *Astraj_clear_probe_tripped_flag() {
    return type == Command_traj_clear_probe_tripped_flag ?
      reinterpret_cast<EMC::TrajClearProbeTrippedFlag *>(value) : nullptr;
  }
  const EMC::TrajClearProbeTrippedFlag *Astraj_clear_probe_tripped_flag() const {
    return type == Command_traj_clear_probe_tripped_flag ?
      reinterpret_cast<const EMC::TrajClearProbeTrippedFlag *>(value) : nullptr;
  }
  EMC::TrajSetTeleopEnable *Astraj_set_teleop_enable() {
    return type == Command_traj_set_teleop_enable ?
      reinterpret_cast<EMC::TrajSetTeleopEnable *>(value) : nullptr;
  }
  const EMC::TrajSetTeleopEnable *Astraj_set_teleop_enable() const {
    return type == Command_traj_set_teleop_enable ?
      reinterpret_cast<const EMC::TrajSetTeleopEnable *>(value) : nullptr;
  }
  EMC::TrajProbe *Astraj_probe() {
    return type == Command_traj_probe ?
      reinterpret_cast<EMC::TrajProbe *>(value) : nullptr;
  }
  const EMC::TrajProbe *Astraj_probe() const {
    return type == Command_traj_probe ?
      reinterpret_cast<const EMC::TrajProbe *>(value) : nullptr;
  }
  EMC::TrajRigidTap *Astraj_rigid_tap() {
    return type == Command_traj_rigid_tap ?
      reinterpret_cast<EMC::TrajRigidTap *>(value) : nullptr;
  }
  const EMC::TrajRigidTap *Astraj_rigid_tap() const {
    return type == Command_traj_rigid_tap ?
      reinterpret_cast<const EMC::TrajRigidTap *>(value) : nullptr;
  }
  EMC::MotionSetAOut *Asmotion_set_aout() {
    return type == Command_motion_set_aout ?
      reinterpret_cast<EMC::MotionSetAOut *>(value) : nullptr;
  }
  const EMC::MotionSetAOut *Asmotion_set_aout() const {
    return type == Command_motion_set_aout ?
      reinterpret_cast<const EMC::MotionSetAOut *>(value) : nullptr;
  }
  EMC::MotionSetDOut *Asmotion_set_dout() {
    return type == Command_motion_set_dout ?
      reinterpret_cast<EMC::MotionSetDOut *>(value) : nullptr;
  }
  const EMC::MotionSetDOut *Asmotion_set_dout() const {
    return type == Command_motion_set_dout ?
      reinterpret_cast<const EMC::MotionSetDOut *>(value) : nullptr;
  }
  EMC::MotionAdaptive *Asmotion_adaptive() {
    return type == Command_motion_adaptive ?
      reinterpret_cast<EMC::MotionAdaptive *>(value) : nullptr;
  }
  const EMC::MotionAdaptive *Asmotion_adaptive() const {
    return type == Command_motion_adaptive ?
      reinterpret_cast<const EMC::MotionAdaptive *>(value) : nullptr;
  }
  EMC::TaskAbort *Astask_abort() {
    return type == Command_task_abort ?
      reinterpret_cast<EMC::TaskAbort *>(value) : nullptr;
  }
  const EMC::TaskAbort *Astask_abort() const {
    return type == Command_task_abort ?
      reinterpret_cast<const EMC::TaskAbort *>(value) : nullptr;
  }
  EMC::TaskSetMode *Astask_set_mode() {
    return type == Command_task_set_mode ?
      reinterpret_cast<EMC::TaskSetMode *>(value) : nullptr;
  }
  const EMC::TaskSetMode *Astask_set_mode() const {
    return type == Command_task_set_mode ?
      reinterpret_cast<const EMC::TaskSetMode *>(value) : nullptr;
  }
  EMC::TaskSetState *Astask_set_state() {
    return type == Command_task_set_state ?
      reinterpret_cast<EMC::TaskSetState *>(value) : nullptr;
  }
  const EMC::TaskSetState *Astask_set_state() const {
    return type == Command_task_set_state ?
      reinterpret_cast<const EMC::TaskSetState *>(value) : nullptr;
  }
  EMC::TaskPlanOpenT *Astask_plan_open() {
    return type == Command_task_plan_open ?
      reinterpret_cast<EMC::TaskPlanOpenT *>(value) : nullptr;
  }
  const EMC::TaskPlanOpenT *Astask_plan_open() const {
    return type == Command_task_plan_open ?
      reinterpret_cast<const EMC::TaskPlanOpenT *>(value) : nullptr;
  }
  EMC::TaskPlanRun *Astask_plan_run() {
    return type == Command_task_plan_run ?
      reinterpret_cast<EMC::TaskPlanRun *>(value) : nullptr;
  }
  const EMC::TaskPlanRun *Astask_plan_run() const {
    return type == Command_task_plan_run ?
      reinterpret_cast<const EMC::TaskPlanRun *>(value) : nullptr;
  }
  EMC::TaskPlanExecuteT *Astask_plan_execute() {
    return type == Command_task_plan_execute ?
      reinterpret_cast<EMC::TaskPlanExecuteT *>(value) : nullptr;
  }
  const EMC::TaskPlanExecuteT *Astask_plan_execute() const {
    return type == Command_task_plan_execute ?
      reinterpret_cast<const EMC::TaskPlanExecuteT *>(value) : nullptr;
  }
  EMC::TaskPlanReverse *Astask_plan_reverse() {
    return type == Command_task_plan_reverse ?
      reinterpret_cast<EMC::TaskPlanReverse *>(value) : nullptr;
  }
  const EMC::TaskPlanReverse *Astask_plan_reverse() const {
    return type == Command_task_plan_reverse ?
      reinterpret_cast<const EMC::TaskPlanReverse *>(value) : nullptr;
  }
  EMC::TaskPlanForward *Astask_plan_forward() {
    return type == Command_task_plan_forward ?
      reinterpret_cast<EMC::TaskPlanForward *>(value) : nullptr;
  }
  const EMC::TaskPlanForward *Astask_plan_forward() const {
    return type == Command_task_plan_forward ?
      reinterpret_cast<const EMC::TaskPlanForward *>(value) : nullptr;
  }
  EMC::TaskPlanStep *Astask_plan_step() {
    return type == Command_task_plan_step ?
      reinterpret_cast<EMC::TaskPlanStep *>(value) : nullptr;
  }
  const EMC::TaskPlanStep *Astask_plan_step() const {
    return type == Command_task_plan_step ?
      reinterpret_cast<const EMC::TaskPlanStep *>(value) : nullptr;
  }
  EMC::TaskPlanResume *Astask_plan_resume() {
    return type == Command_task_plan_resume ?
      reinterpret_cast<EMC::TaskPlanResume *>(value) : nullptr;
  }
  const EMC::TaskPlanResume *Astask_plan_resume() const {
    return type == Command_task_plan_resume ?
      reinterpret_cast<const EMC::TaskPlanResume *>(value) : nullptr;
  }
  EMC::TaskPlanEnd *Astask_plan_end() {
    return type == Command_task_plan_end ?
      reinterpret_cast<EMC::TaskPlanEnd *>(value) : nullptr;
  }
  const EMC::TaskPlanEnd *Astask_plan_end() const {
    return type == Command_task_plan_end ?
      reinterpret_cast<const EMC::TaskPlanEnd *>(value) : nullptr;
  }
  EMC::TaskPlanClose *Astask_plan_close() {
    return type == Command_task_plan_close ?
      reinterpret_cast<EMC::TaskPlanClose *>(value) : nullptr;
  }
  const EMC::TaskPlanClose *Astask_plan_close() const {
    return type == Command_task_plan_close ?
      reinterpret_cast<const EMC::TaskPlanClose *>(value) : nullptr;
  }
  EMC::TaskPlanInit *Astask_plan_init() {
    return type == Command_task_plan_init ?
      reinterpret_cast<EMC::TaskPlanInit *>(value) : nullptr;
  }
  const EMC::TaskPlanInit *Astask_plan_init() const {
    return type == Command_task_plan_init ?
      reinterpret_cast<const EMC::TaskPlanInit *>(value) : nullptr;
  }
  EMC::TaskPlanSynch *Astask_plan_synch() {
    return type == Command_task_plan_synch ?
      reinterpret_cast<EMC::TaskPlanSynch *>(value) : nullptr;
  }
  const EMC::TaskPlanSynch *Astask_plan_synch() const {
    return type == Command_task_plan_synch ?
      reinterpret_cast<const EMC::TaskPlanSynch *>(value) : nullptr;
  }
  EMC::TaskPlanSetOptionalStop *Astask_plan_set_optional_stop() {
    return type == Command_task_plan_set_optional_stop ?
      reinterpret_cast<EMC::TaskPlanSetOptionalStop *>(value) : nullptr;
  }
  const EMC::TaskPlanSetOptionalStop *Astask_plan_set_optional_stop() const {
    return type == Command_task_plan_set_optional_stop ?
      reinterpret_cast<const EMC::TaskPlanSetOptionalStop *>(value) : nullptr;
  }
  EMC::TaskPlanSetBlockDelete *Astask_plan_set_block_delete() {
    return type == Command_task_plan_set_block_delete ?
      reinterpret_cast<EMC::TaskPlanSetBlockDelete *>(value) : nullptr;
  }
  const EMC::TaskPlanSetBlockDelete *Astask_plan_set_block_delete() const {
    return type == Command_task_plan_set_block_delete ?
      reinterpret_cast<const EMC::TaskPlanSetBlockDelete *>(value) : nullptr;
  }
  EMC::TaskPlanOptionalStop *Astask_plan_optional_stop() {
    return type == Command_task_plan_optional_stop ?
      reinterpret_cast<EMC::TaskPlanOptionalStop *>(value) : nullptr;
  }
  const EMC::TaskPlanOptionalStop *Astask_plan_optional_stop() const {
    return type == Command_task_plan_optional_stop ?
      reinterpret_cast<const EMC::TaskPlanOptionalStop *>(value) : nullptr;
  }
  EMC::ToolCmd *Astool_cmd() {
    return type == Command_tool_cmd ?
      reinterpret_cast<EMC::ToolCmd *>(value) : nullptr;
  }
  const EMC::ToolCmd *Astool_cmd() const {
    return type == Command_tool_cmd ?
      reinterpret_cast<const EMC::ToolCmd *>(value) : nullptr;
  }
  EMC::ToolHalt *Astool_halt() {
    return type == Command_tool_halt ?
      reinterpret_cast<EMC::ToolHalt *>(value) : nullptr;
  }
  const EMC::ToolHalt *Astool_halt() const {
    return type == Command_tool_halt ?
      reinterpret_cast<const EMC::ToolHalt *>(value) : nullptr;
  }
  EMC::ToolAbort *Astool_abort() {
    return type == Command_tool_abort ?
      reinterpret_cast<EMC::ToolAbort *>(value) : nullptr;
  }
  const EMC::ToolAbort *Astool_abort() const {
    return type == Command_tool_abort ?
      reinterpret_cast<const EMC::ToolAbort *>(value) : nullptr;
  }
  EMC::ToolPrepare *Astool_prepare() {
    return type == Command_tool_prepare ?
      reinterpret_cast<EMC::ToolPrepare *>(value) : nullptr;
  }
  const EMC::ToolPrepare *Astool_prepare() const {
    return type == Command_tool_prepare ?
      reinterpret_cast<const EMC::ToolPrepare *>(value) : nullptr;
  }
  EMC::ToolLoad *Astool_load() {
    return type == Command_tool_load ?
      reinterpret_cast<EMC::ToolLoad *>(value) : nullptr;
  }
  const EMC::ToolLoad *Astool_load() const {
    return type == Command_tool_load ?
      reinterpret_cast<const EMC::ToolLoad *>(value) : nullptr;
  }
  EMC::ToolLoadToolTableT *Astool_load_tool_table() {
    return type == Command_tool_load_tool_table ?
      reinterpret_cast<EMC::ToolLoadToolTableT *>(value) : nullptr;
  }
  const EMC::ToolLoadToolTableT *Astool_load_tool_table() const {
    return type == Command_tool_load_tool_table ?
      reinterpret_cast<const EMC::ToolLoadToolTableT *>(value) : nullptr;
  }
  EMC::ToolSetOffset *Astool_set_offset() {
    return type == Command_tool_set_offset ?
      reinterpret_cast<EMC::ToolSetOffset *>(value) : nullptr;
  }
  const EMC::ToolSetOffset *Astool_set_offset() const {
    return type == Command_tool_set_offset ?
      reinterpret_cast<const EMC::ToolSetOffset *>(value) : nullptr;
  }
  EMC::ToolSetNumber *Astool_set_number() {
    return type == Command_tool_set_number ?
      reinterpret_cast<EMC::ToolSetNumber *>(value) : nullptr;
  }
  const EMC::ToolSetNumber *Astool_set_number() const {
    return type == Command_tool_set_number ?
      reinterpret_cast<const EMC::ToolSetNumber *>(value) : nullptr;
  }
  EMC::AuxInputWait *Asaux_input_wait() {
    return type == Command_aux_input_wait ?
      reinterpret_cast<EMC::AuxInputWait *>(value) : nullptr;
  }
  const EMC::AuxInputWait *Asaux_input_wait() const {
    return type == Command_aux_input_wait ?
      reinterpret_cast<const EMC::AuxInputWait *>(value) : nullptr;
  }
  EMC::SpindleSpeed *Asspindle_speed() {
    return type == Command_spindle_speed ?
      reinterpret_cast<EMC::SpindleSpeed *>(value) : nullptr;
  }
  const EMC::SpindleSpeed *Asspindle_speed() const {
    return type == Command_spindle_speed ?
      reinterpret_cast<const EMC::SpindleSpeed *>(value) : nullptr;
  }
  EMC::SpindleOrient *Asspindle_orient() {
    return type == Command_spindle_orient ?
      reinterpret_cast<EMC::SpindleOrient *>(value) : nullptr;
  }
  const EMC::SpindleOrient *Asspindle_orient() const {
    return type == Command_spindle_orient ?
      reinterpret_cast<const EMC::SpindleOrient *>(value) : nullptr;
  }
  EMC::SpindleWaitOrient *Asspindle_wait_orient() {
    return type == Command_spindle_wait_orient ?
      reinterpret_cast<EMC::SpindleWaitOrient *>(value) : nullptr;
  }
  const EMC::SpindleWaitOrient *Asspindle_wait_orient() const {
    return type == Command_spindle_wait_orient ?
      reinterpret_cast<const EMC::SpindleWaitOrient *>(value) : nullptr;
  }
  EMC::SpindleOn *Asspindle_on() {
    return type == Command_spindle_on ?
      reinterpret_cast<EMC::SpindleOn *>(value) : nullptr;
  }
  const EMC::SpindleOn *Asspindle_on() const {
    return type == Command_spindle_on ?
      reinterpret_cast<const EMC::SpindleOn *>(value) : nullptr;
  }
  EMC::SpindleOff *Asspindle_off() {
    return type == Command_spindle_off ?
      reinterpret_cast<EMC::SpindleOff *>(value) : nullptr;
  }
  const EMC::SpindleOff *Asspindle_off() const {
    return type == Command_spindle_off ?
      reinterpret_cast<const EMC::SpindleOff *>(value) : nullptr;
  }
  EMC::SpindleIncrease *Asspindle_increase() {
    return type == Command_spindle_increase ?
      reinterpret_cast<EMC::SpindleIncrease *>(value) : nullptr;
  }
  const EMC::SpindleIncrease *Asspindle_increase() const {
    return type == Command_spindle_increase ?
      reinterpret_cast<const EMC::SpindleIncrease *>(value) : nullptr;
  }
  EMC::SpindleDecrease *Asspindle_decrease() {
    return type == Command_spindle_decrease ?
      reinterpret_cast<EMC::SpindleDecrease *>(value) : nullptr;
  }
  const EMC::SpindleDecrease *Asspindle_decrease() const {
    return type == Command_spindle_decrease ?
      reinterpret_cast<const EMC::SpindleDecrease *>(value) : nullptr;
  }
  EMC::SpindleConstant *Asspindle_constant() {
    return type == Command_spindle_constant ?
      reinterpret_cast<EMC::SpindleConstant *>(value) : nullptr;
  }
  const EMC::SpindleConstant *Asspindle_constant() const {
    return type == Command_spindle_constant ?
      reinterpret_cast<const EMC::SpindleConstant *>(value) : nullptr;
  }
  EMC::SpindleBrakeRelease *Asspindle_brake_release() {
    return type == Command_spindle_brake_release ?
      reinterpret_cast<EMC::SpindleBrakeRelease *>(value) : nullptr;
  }
  const EMC::SpindleBrakeRelease *Asspindle_brake_release() const {
    return type == Command_spindle_brake_release ?
      reinterpret_cast<const EMC::SpindleBrakeRelease *>(value) : nullptr;
  }
  EMC::SpindleBrakeEngage *Asspindle_brake_engage() {
    return type == Command_spindle_brake_engage ?
      reinterpret_cast<EMC::SpindleBrakeEngage *>(value) : nullptr;
  }
  const EMC::SpindleBrakeEngage *Asspindle_brake_engage() const {
    return type == Command_spindle_brake_engage ?
      reinterpret_cast<const EMC::SpindleBrakeEngage *>(value) : nullptr;
  }
  EMC::CoolantMistOn *Ascoolant_mist_on() {
    return type == Command_coolant_mist_on ?
      reinterpret_cast<EMC::CoolantMistOn *>(value) : nullptr;
  }
  const EMC::CoolantMistOn *Ascoolant_mist_on() const {
    return type == Command_coolant_mist_on ?
      reinterpret_cast<const EMC::CoolantMistOn *>(value) : nullptr;
  }
  EMC::CoolantMistOff *Ascoolant_mist_off() {
    return type == Command_coolant_mist_off ?
      reinterpret_cast<EMC::CoolantMistOff *>(value) : nullptr;
  }
  const EMC::CoolantMistOff *Ascoolant_mist_off() const {
    return type == Command_coolant_mist_off ?
      reinterpret_cast<const EMC::CoolantMistOff *>(value) : nullptr;
  }
  EMC::CoolantFloodOn *Ascoolant_flood_on() {
    return type == Command_coolant_flood_on ?
      reinterpret_cast<EMC::CoolantFloodOn *>(value) : nullptr;
  }
  const EMC::CoolantFloodOn *Ascoolant_flood_on() const {
    return type == Command_coolant_flood_on ?
      reinterpret_cast<const EMC::CoolantFloodOn *>(value) : nullptr;
  }
  EMC::CoolantFloodOff *Ascoolant_flood_off() {
    return type == Command_coolant_flood_off ?
      reinterpret_cast<EMC::CoolantFloodOff *>(value) : nullptr;
  }
  const EMC::CoolantFloodOff *Ascoolant_flood_off() const {
    return type == Command_coolant_flood_off ?
      reinterpret_cast<const EMC::CoolantFloodOff *>(value) : nullptr;
  }
};

bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetDebug FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t debug_level_;

 public:
  SetDebug()
      : debug_level_(0) {
  }
  SetDebug(int32_t _debug_level)
      : debug_level_(flatbuffers::EndianScalar(_debug_level)) {
  }
  int32_t debug_level() const {
    return flatbuffers::EndianScalar(debug_level_);
  }
};
FLATBUFFERS_STRUCT_END(SetDebug, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JogCmd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_or_axis_;

 public:
  JogCmd()
      : joint_or_axis_(0) {
  }
  JogCmd(int32_t _joint_or_axis)
      : joint_or_axis_(flatbuffers::EndianScalar(_joint_or_axis)) {
  }
  int32_t joint_or_axis() const {
    return flatbuffers::EndianScalar(joint_or_axis_);
  }
};
FLATBUFFERS_STRUCT_END(JogCmd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetBacklash FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double backlash_;

 public:
  JointSetBacklash()
      : joint_(0),
        padding0__(0),
        backlash_(0) {
    (void)padding0__;
  }
  JointSetBacklash(int32_t _joint, double _backlash)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        backlash_(flatbuffers::EndianScalar(_backlash)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double backlash() const {
    return flatbuffers::EndianScalar(backlash_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetBacklash, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMinPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMinPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMinPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMinPositionLimit, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMaxPositionLimit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double limit_;

 public:
  JointSetMaxPositionLimit()
      : joint_(0),
        padding0__(0),
        limit_(0) {
    (void)padding0__;
  }
  JointSetMaxPositionLimit(int32_t _joint, double _limit)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        limit_(flatbuffers::EndianScalar(_limit)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double limit() const {
    return flatbuffers::EndianScalar(limit_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMaxPositionLimit, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetFerror FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double ferror_;

 public:
  JointSetFerror()
      : joint_(0),
        padding0__(0),
        ferror_(0) {
    (void)padding0__;
  }
  JointSetFerror(int32_t _joint, double _ferror)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        ferror_(flatbuffers::EndianScalar(_ferror)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double ferror() const {
    return flatbuffers::EndianScalar(ferror_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetFerror, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetMinFerror FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double ferror_;

 public:
  JointSetMinFerror()
      : joint_(0),
        padding0__(0),
        ferror_(0) {
    (void)padding0__;
  }
  JointSetMinFerror(int32_t _joint, double _ferror)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        ferror_(flatbuffers::EndianScalar(_ferror)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double ferror() const {
    return flatbuffers::EndianScalar(ferror_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetMinFerror, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JointSetHomingParams FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double home_;
  double offset_;
  double home_final_vel_;
  double search_vel_;
  double latch_vel_;
  int32_t use_index_;
  int32_t encoder_does_not_reset_;
  int32_t ignore_limits_;
  int32_t home_sequence_;
  int32_t volatile_home_;
  int32_t locking_indexer_;
  int32_t absolute_encoder_;
  int32_t padding1__;

 public:
  JointSetHomingParams()
      : joint_(0),
        padding0__(0),
        home_(0),
        offset_(0),
        home_final_vel_(0),
        search_vel_(0),
        latch_vel_(0),
        use_index_(0),
        encoder_does_not_reset_(0),
        ignore_limits_(0),
        home_sequence_(0),
        volatile_home_(0),
        locking_indexer_(0),
        absolute_encoder_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JointSetHomingParams(int32_t _joint, double _home, double _offset, double _home_final_vel, double _search_vel, double _latch_vel, int32_t _use_index, int32_t _encoder_does_not_reset, int32_t _ignore_limits, int32_t _home_sequence, int32_t _volatile_home, int32_t _locking_indexer, int32_t _absolute_encoder)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        home_(flatbuffers::EndianScalar(_home)),
        offset_(flatbuffers::EndianScalar(_offset)),
        home_final_vel_(flatbuffers::EndianScalar(_home_final_vel)),
        search_vel_(flatbuffers::EndianScalar(_search_vel)),
        latch_vel_(flatbuffers::EndianScalar(_latch_vel)),
        use_index_(flatbuffers::EndianScalar(_use_index)),
        encoder_does_not_reset_(flatbuffers::EndianScalar(_encoder_does_not_reset)),
        ignore_limits_(flatbuffers::EndianScalar(_ignore_limits)),
        home_sequence_(flatbuffers::EndianScalar(_home_sequence)),
        volatile_home_(flatbuffers::EndianScalar(_volatile_home)),
        locking_indexer_(flatbuffers::EndianScalar(_locking_indexer)),
        absolute_encoder_(flatbuffers::EndianScalar(_absolute_encoder)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double home() const {
    return flatbuffers::EndianScalar(home_);
  }
  double offset() const {
    return flatbuffers::EndianScalar(offset_);
  }
  double home_final_vel() const {
    return flatbuffers::EndianScalar(home_final_vel_);
  }
  double search_vel() const {
    return flatbuffers::EndianScalar(search_vel_);
  }
  double latch_vel() const {
    return flatbuffers::EndianScalar(latch_vel_);
  }
  int32_t use_index() const {
    return flatbuffers::EndianScalar(use_index_);
  }
  int32_t encoder_does_not_reset() const {
    return flatbuffers::EndianScalar(encoder_does_not_reset_);
  }
  int32_t ignore_limits() const {
    return flatbuffers::EndianScalar(ignore_limits_);
  }
  int32_t home_sequence() const {
    return flatbuffers::EndianScalar(home_sequence_);
  }
  int32_t volatile_home() const {
    return flatbuffers::EndianScalar(volatile_home_);
  }
  int32_t locking_indexer() const {
    return flatbuffers::EndianScalar(locking_indexer_);
  }
  int32_t absolute_encoder() const {
    return flatbuffers::EndianScalar(absolute_encoder_);
  }
};
FLATBUFFERS_STRUCT_END(JointSetHomingParams, 80);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointHalt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointHalt()
      : joint_(0) {
  }
  JointHalt(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointHalt, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointHome FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointHome()
      : joint_(0) {
  }
  JointHome(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointHome, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointUnhome FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointUnhome()
      : joint_(0) {
  }
  JointUnhome(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointUnhome, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogCont FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogCont()
      : joint_(0),
        padding0__(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogCont(int32_t _joint, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogCont, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogIncr FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double incr_;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogIncr()
      : joint_(0),
        padding0__(0),
        incr_(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogIncr(int32_t _joint, double _incr, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        incr_(flatbuffers::EndianScalar(_incr)),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double incr() const {
    return flatbuffers::EndianScalar(incr_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogIncr, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) JogAbs FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t padding0__;
  double pos_;
  double vel_;
  int32_t jjogmode_;
  int32_t padding1__;

 public:
  JogAbs()
      : joint_(0),
        padding0__(0),
        pos_(0),
        vel_(0),
        jjogmode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  JogAbs(int32_t _joint, double _pos, double _vel, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        padding0__(0),
        pos_(flatbuffers::EndianScalar(_pos)),
        vel_(flatbuffers::EndianScalar(_vel)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)),
        padding1__(0) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  double pos() const {
    return flatbuffers::EndianScalar(pos_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogAbs, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JogStop FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;
  int32_t jjogmode_;

 public:
  JogStop()
      : joint_(0),
        jjogmode_(0) {
  }
  JogStop(int32_t _joint, int32_t _jjogmode)
      : joint_(flatbuffers::EndianScalar(_joint)),
        jjogmode_(flatbuffers::EndianScalar(_jjogmode)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
  int32_t jjogmode() const {
    return flatbuffers::EndianScalar(jjogmode_);
  }
};
FLATBUFFERS_STRUCT_END(JogStop, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) JointOverrideLimits FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t joint_;

 public:
  JointOverrideLimits()
      : joint_(0) {
  }
  JointOverrideLimits(int32_t _joint)
      : joint_(flatbuffers::EndianScalar(_joint)) {
  }
  int32_t joint() const {
    return flatbuffers::EndianScalar(joint_);
  }
};
FLATBUFFERS_STRUCT_END(JointOverrideLimits, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetMode FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetMode()
      : mode_(0) {
  }
  TrajSetMode(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetMode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetVelocity FLATBUFFERS_FINAL_CLASS {
 private:
  double velocity_;
  double ini_maxvel_;

 public:
  TrajSetVelocity()
      : velocity_(0),
        ini_maxvel_(0) {
  }
  TrajSetVelocity(double _velocity, double _ini_maxvel)
      : velocity_(flatbuffers::EndianScalar(_velocity)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)) {
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetVelocity, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetAcceleration FLATBUFFERS_FINAL_CLASS {
 private:
  double acceleration_;

 public:
  TrajSetAcceleration()
      : acceleration_(0) {
  }
  TrajSetAcceleration(double _acceleration)
      : acceleration_(flatbuffers::EndianScalar(_acceleration)) {
  }
  double acceleration() const {
    return flatbuffers::EndianScalar(acceleration_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetAcceleration, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetMaxVelocity FLATBUFFERS_FINAL_CLASS {
 private:
  double velocity_;

 public:
  TrajSetMaxVelocity()
      : velocity_(0) {
  }
  TrajSetMaxVelocity(double _velocity)
      : velocity_(flatbuffers::EndianScalar(_velocity)) {
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetMaxVelocity, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetScale FLATBUFFERS_FINAL_CLASS {
 private:
  double scale_;

 public:
  TrajSetScale()
      : scale_(0) {
  }
  TrajSetScale(double _scale)
      : scale_(flatbuffers::EndianScalar(_scale)) {
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetScale, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetRapidScale FLATBUFFERS_FINAL_CLASS {
 private:
  double scale_;

 public:
  TrajSetRapidScale()
      : scale_(0) {
  }
  TrajSetRapidScale(double _scale)
      : scale_(flatbuffers::EndianScalar(_scale)) {
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetRapidScale, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetSpindleScale FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double scale_;

 public:
  TrajSetSpindleScale()
      : spindle_(0),
        padding0__(0),
        scale_(0) {
    (void)padding0__;
  }
  TrajSetSpindleScale(int32_t _spindle, double _scale)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        scale_(flatbuffers::EndianScalar(_scale)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSpindleScale, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetFOEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetFOEnable()
      : mode_(0) {
  }
  TrajSetFOEnable(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetFOEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetSOEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t mode_;

 public:
  TrajSetSOEnable()
      : spindle_(0),
        mode_(0) {
  }
  TrajSetSOEnable(int32_t _spindle, int32_t _mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSOEnable, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetFHEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TrajSetFHEnable()
      : mode_(0) {
  }
  TrajSetFHEnable(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetFHEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajAbort()
      : dummy_(0) {
  }
  TrajAbort(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajPause FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajPause()
      : dummy_(0) {
  }
  TrajPause(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajPause, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajResume FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajResume()
      : dummy_(0) {
  }
  TrajResume(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajResume, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajDelay FLATBUFFERS_FINAL_CLASS {
 private:
  double delay_;

 public:
  TrajDelay()
      : delay_(0) {
  }
  TrajDelay(double _delay)
      : delay_(flatbuffers::EndianScalar(_delay)) {
  }
  double delay() const {
    return flatbuffers::EndianScalar(delay_);
  }
};
FLATBUFFERS_STRUCT_END(TrajDelay, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajLinearMove FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t type_;
  int32_t padding0__;
  EMC::Pose end_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  int32_t feed_mode_;
  int32_t indexer_jnum_;

 public:
  TrajLinearMove()
      : type_(0),
        padding0__(0),
        end_(),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        feed_mode_(0),
        indexer_jnum_(0) {
    (void)padding0__;
  }
  TrajLinearMove(int32_t _type, const EMC::Pose &_end, double _vel, double _ini_maxvel, double _acc, int32_t _feed_mode, int32_t _indexer_jnum)
      : type_(flatbuffers::EndianScalar(_type)),
        padding0__(0),
        end_(_end),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        feed_mode_(flatbuffers::EndianScalar(_feed_mode)),
        indexer_jnum_(flatbuffers::EndianScalar(_indexer_jnum)) {
  }
  int32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  const EMC::Pose &end() const {
    return end_;
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  int32_t feed_mode() const {
    return flatbuffers::EndianScalar(feed_mode_);
  }
  int32_t indexer_jnum() const {
    return flatbuffers::EndianScalar(indexer_jnum_);
  }
};
FLATBUFFERS_STRUCT_END(TrajLinearMove, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetTermCond FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t cond_;
  int32_t padding0__;
  double tolerance_;

 public:
  TrajSetTermCond()
      : cond_(0),
        padding0__(0),
        tolerance_(0) {
    (void)padding0__;
  }
  TrajSetTermCond(int32_t _cond, double _tolerance)
      : cond_(flatbuffers::EndianScalar(_cond)),
        padding0__(0),
        tolerance_(flatbuffers::EndianScalar(_tolerance)) {
  }
  int32_t cond() const {
    return flatbuffers::EndianScalar(cond_);
  }
  double tolerance() const {
    return flatbuffers::EndianScalar(tolerance_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetTermCond, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetSpindleSync FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double feed_per_revolution_;
  uint8_t velocity_mode_;
  int8_t padding1__;  int16_t padding2__;  int32_t padding3__;

 public:
  TrajSetSpindleSync()
      : spindle_(0),
        padding0__(0),
        feed_per_revolution_(0),
        velocity_mode_(0),
        padding1__(0),
        padding2__(0),
        padding3__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
    (void)padding3__;
  }
  TrajSetSpindleSync(int32_t _spindle, double _feed_per_revolution, bool _velocity_mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        feed_per_revolution_(flatbuffers::EndianScalar(_feed_per_revolution)),
        velocity_mode_(flatbuffers::EndianScalar(static_cast<uint8_t>(_velocity_mode))),
        padding1__(0),
        padding2__(0),
        padding3__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double feed_per_revolution() const {
    return flatbuffers::EndianScalar(feed_per_revolution_);
  }
  bool velocity_mode() const {
    return flatbuffers::EndianScalar(velocity_mode_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetSpindleSync, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetOffset FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose offset_;

 public:
  TrajSetOffset()
      : offset_() {
  }
  TrajSetOffset(const EMC::Pose &_offset)
      : offset_(_offset) {
  }
  const EMC::Pose &offset() const {
    return offset_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetOffset, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetG5x FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t g5x_index_;
  int32_t padding0__;
  EMC::Pose origin_;

 public:
  TrajSetG5x()
      : g5x_index_(0),
        padding0__(0),
        origin_() {
    (void)padding0__;
  }
  TrajSetG5x(int32_t _g5x_index, const EMC::Pose &_origin)
      : g5x_index_(flatbuffers::EndianScalar(_g5x_index)),
        padding0__(0),
        origin_(_origin) {
  }
  int32_t g5x_index() const {
    return flatbuffers::EndianScalar(g5x_index_);
  }
  const EMC::Pose &origin() const {
    return origin_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetG5x, 80);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetG92 FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose origin_;

 public:
  TrajSetG92()
      : origin_() {
  }
  TrajSetG92(const EMC::Pose &_origin)
      : origin_(_origin) {
  }
  const EMC::Pose &origin() const {
    return origin_;
  }
};
FLATBUFFERS_STRUCT_END(TrajSetG92, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajSetRotation FLATBUFFERS_FINAL_CLASS {
 private:
  double rotation_;

 public:
  TrajSetRotation()
      : rotation_(0) {
  }
  TrajSetRotation(double _rotation)
      : rotation_(flatbuffers::EndianScalar(_rotation)) {
  }
  double rotation() const {
    return flatbuffers::EndianScalar(rotation_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetRotation, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajClearProbeTrippedFlag FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TrajClearProbeTrippedFlag()
      : dummy_(0) {
  }
  TrajClearProbeTrippedFlag(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TrajClearProbeTrippedFlag, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TrajSetTeleopEnable FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t enable_;

 public:
  TrajSetTeleopEnable()
      : enable_(0) {
  }
  TrajSetTeleopEnable(int32_t _enable)
      : enable_(flatbuffers::EndianScalar(_enable)) {
  }
  int32_t enable() const {
    return flatbuffers::EndianScalar(enable_);
  }
};
FLATBUFFERS_STRUCT_END(TrajSetTeleopEnable, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajProbe FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose pos_;
  int32_t type_;
  int32_t padding0__;
  double vel_;
  double ini_maxvel_;
  double acc_;
  int32_t probe_type_;
  int32_t padding1__;

 public:
  TrajProbe()
      : pos_(),
        type_(0),
        padding0__(0),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        probe_type_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  TrajProbe(const EMC::Pose &_pos, int32_t _type, double _vel, double _ini_maxvel, double _acc, int32_t _probe_type)
      : pos_(_pos),
        type_(flatbuffers::EndianScalar(_type)),
        padding0__(0),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        probe_type_(flatbuffers::EndianScalar(_probe_type)),
        padding1__(0) {
  }
  const EMC::Pose &pos() const {
    return pos_;
  }
  int32_t type() const {
    return flatbuffers::EndianScalar(type_);
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  int32_t probe_type() const {
    return flatbuffers::EndianScalar(probe_type_);
  }
};
FLATBUFFERS_STRUCT_END(TrajProbe, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TrajRigidTap FLATBUFFERS_FINAL_CLASS {
 private:
  EMC::Pose pos_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  double scale_;

 public:
  TrajRigidTap()
      : pos_(),
        vel_(0),
        ini_maxvel_(0),
        acc_(0),
        scale_(0) {
  }
  TrajRigidTap(const EMC::Pose &_pos, double _vel, double _ini_maxvel, double _acc, double _scale)
      : pos_(_pos),
        vel_(flatbuffers::EndianScalar(_vel)),
        ini_maxvel_(flatbuffers::EndianScalar(_ini_maxvel)),
        acc_(flatbuffers::EndianScalar(_acc)),
        scale_(flatbuffers::EndianScalar(_scale)) {
  }
  const EMC::Pose &pos() const {
    return pos_;
  }
  double vel() const {
    return flatbuffers::EndianScalar(vel_);
  }
  double ini_maxvel() const {
    return flatbuffers::EndianScalar(ini_maxvel_);
  }
  double acc() const {
    return flatbuffers::EndianScalar(acc_);
  }
  double scale() const {
    return flatbuffers::EndianScalar(scale_);
  }
};
FLATBUFFERS_STRUCT_END(TrajRigidTap, 104);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MotionSetAOut FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t padding0__;
  double start_;
  double end_;
  int32_t now_;
  int32_t padding1__;

 public:
  MotionSetAOut()
      : index_(0),
        padding0__(0),
        start_(0),
        end_(0),
        now_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  MotionSetAOut(int32_t _index, double _start, double _end, int32_t _now)
      : index_(flatbuffers::EndianScalar(_index)),
        padding0__(0),
        start_(flatbuffers::EndianScalar(_start)),
        end_(flatbuffers::EndianScalar(_end)),
        now_(flatbuffers::EndianScalar(_now)),
        padding1__(0) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  double start() const {
    return flatbuffers::EndianScalar(start_);
  }
  double end() const {
    return flatbuffers::EndianScalar(end_);
  }
  int32_t now() const {
    return flatbuffers::EndianScalar(now_);
  }
};
FLATBUFFERS_STRUCT_END(MotionSetAOut, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotionSetDOut FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t start_;
  int32_t end_;
  int32_t now_;

 public:
  MotionSetDOut()
      : index_(0),
        start_(0),
        end_(0),
        now_(0) {
  }
  MotionSetDOut(int32_t _index, int32_t _start, int32_t _end, int32_t _now)
      : index_(flatbuffers::EndianScalar(_index)),
        start_(flatbuffers::EndianScalar(_start)),
        end_(flatbuffers::EndianScalar(_end)),
        now_(flatbuffers::EndianScalar(_now)) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  int32_t start() const {
    return flatbuffers::EndianScalar(start_);
  }
  int32_t end() const {
    return flatbuffers::EndianScalar(end_);
  }
  int32_t now() const {
    return flatbuffers::EndianScalar(now_);
  }
};
FLATBUFFERS_STRUCT_END(MotionSetDOut, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MotionAdaptive FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t status_;

 public:
  MotionAdaptive()
      : status_(0) {
  }
  MotionAdaptive(int32_t _status)
      : status_(flatbuffers::EndianScalar(_status)) {
  }
  int32_t status() const {
    return flatbuffers::EndianScalar(status_);
  }
};
FLATBUFFERS_STRUCT_END(MotionAdaptive, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskAbort()
      : dummy_(0) {
  }
  TaskAbort(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskSetMode FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t mode_;

 public:
  TaskSetMode()
      : mode_(0) {
  }
  TaskSetMode(int32_t _mode)
      : mode_(flatbuffers::EndianScalar(_mode)) {
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(TaskSetMode, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskSetState FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t state_;

 public:
  TaskSetState()
      : state_(0) {
  }
  TaskSetState(int32_t _state)
      : state_(flatbuffers::EndianScalar(_state)) {
  }
  int32_t state() const {
    return flatbuffers::EndianScalar(state_);
  }
};
FLATBUFFERS_STRUCT_END(TaskSetState, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanRun FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t line_;

 public:
  TaskPlanRun()
      : line_(0) {
  }
  TaskPlanRun(int32_t _line)
      : line_(flatbuffers::EndianScalar(_line)) {
  }
  int32_t line() const {
    return flatbuffers::EndianScalar(line_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanRun, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanReverse FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanReverse()
      : dummy_(0) {
  }
  TaskPlanReverse(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanReverse, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanForward FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanForward()
      : dummy_(0) {
  }
  TaskPlanForward(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanForward, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanStep FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanStep()
      : dummy_(0) {
  }
  TaskPlanStep(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanStep, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanResume FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanResume()
      : dummy_(0) {
  }
  TaskPlanResume(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanResume, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanEnd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanEnd()
      : dummy_(0) {
  }
  TaskPlanEnd(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanEnd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanClose FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanClose()
      : dummy_(0) {
  }
  TaskPlanClose(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanClose, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanInit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanInit()
      : dummy_(0) {
  }
  TaskPlanInit(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanInit, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanSynch FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanSynch()
      : dummy_(0) {
  }
  TaskPlanSynch(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSynch, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TaskPlanSetOptionalStop FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t state_;

 public:
  TaskPlanSetOptionalStop()
      : state_(0) {
  }
  TaskPlanSetOptionalStop(bool _state)
      : state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))) {
  }
  bool state() const {
    return flatbuffers::EndianScalar(state_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSetOptionalStop, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TaskPlanSetBlockDelete FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t state_;

 public:
  TaskPlanSetBlockDelete()
      : state_(0) {
  }
  TaskPlanSetBlockDelete(bool _state)
      : state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))) {
  }
  bool state() const {
    return flatbuffers::EndianScalar(state_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanSetBlockDelete, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskPlanOptionalStop FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  TaskPlanOptionalStop()
      : dummy_(0) {
  }
  TaskPlanOptionalStop(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(TaskPlanOptionalStop, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolCmd FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolCmd()
      : dummy_(0) {
  }
  ToolCmd(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolCmd, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolHalt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolHalt()
      : dummy_(0) {
  }
  ToolHalt(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolHalt, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolAbort FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t reason_;

 public:
  ToolAbort()
      : reason_(0) {
  }
  ToolAbort(int32_t _reason)
      : reason_(flatbuffers::EndianScalar(_reason)) {
  }
  int32_t reason() const {
    return flatbuffers::EndianScalar(reason_);
  }
};
FLATBUFFERS_STRUCT_END(ToolAbort, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolPrepare FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t tool_;

 public:
  ToolPrepare()
      : tool_(0) {
  }
  ToolPrepare(int32_t _tool)
      : tool_(flatbuffers::EndianScalar(_tool)) {
  }
  int32_t tool() const {
    return flatbuffers::EndianScalar(tool_);
  }
};
FLATBUFFERS_STRUCT_END(ToolPrepare, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolLoad FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  ToolLoad()
      : dummy_(0) {
  }
  ToolLoad(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(ToolLoad, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ToolSetOffset FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t pocket_;
  int32_t toolno_;
  EMC::Pose offset_;
  double diameter_;
  double frontangle_;
  double backangle_;
  int32_t orientation_;
  int32_t padding0__;

 public:
  ToolSetOffset()
      : pocket_(0),
        toolno_(0),
        offset_(),
        diameter_(0),
        frontangle_(0),
        backangle_(0),
        orientation_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ToolSetOffset(int32_t _pocket, int32_t _toolno, const EMC::Pose &_offset, double _diameter, double _frontangle, double _backangle, int32_t _orientation)
      : pocket_(flatbuffers::EndianScalar(_pocket)),
        toolno_(flatbuffers::EndianScalar(_toolno)),
        offset_(_offset),
        diameter_(flatbuffers::EndianScalar(_diameter)),
        frontangle_(flatbuffers::EndianScalar(_frontangle)),
        backangle_(flatbuffers::EndianScalar(_backangle)),
        orientation_(flatbuffers::EndianScalar(_orientation)),
        padding0__(0) {
  }
  int32_t pocket() const {
    return flatbuffers::EndianScalar(pocket_);
  }
  int32_t toolno() const {
    return flatbuffers::EndianScalar(toolno_);
  }
  const EMC::Pose &offset() const {
    return offset_;
  }
  double diameter() const {
    return flatbuffers::EndianScalar(diameter_);
  }
  double frontangle() const {
    return flatbuffers::EndianScalar(frontangle_);
  }
  double backangle() const {
    return flatbuffers::EndianScalar(backangle_);
  }
  int32_t orientation() const {
    return flatbuffers::EndianScalar(orientation_);
  }
};
FLATBUFFERS_STRUCT_END(ToolSetOffset, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ToolSetNumber FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t tool_;

 public:
  ToolSetNumber()
      : tool_(0) {
  }
  ToolSetNumber(int32_t _tool)
      : tool_(flatbuffers::EndianScalar(_tool)) {
  }
  int32_t tool() const {
    return flatbuffers::EndianScalar(tool_);
  }
};
FLATBUFFERS_STRUCT_END(ToolSetNumber, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) AuxInputWait FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_;
  int32_t input_type_;
  int32_t wait_type_;
  int32_t padding0__;
  double timeout_;

 public:
  AuxInputWait()
      : index_(0),
        input_type_(0),
        wait_type_(0),
        padding0__(0),
        timeout_(0) {
    (void)padding0__;
  }
  AuxInputWait(int32_t _index, int32_t _input_type, int32_t _wait_type, double _timeout)
      : index_(flatbuffers::EndianScalar(_index)),
        input_type_(flatbuffers::EndianScalar(_input_type)),
        wait_type_(flatbuffers::EndianScalar(_wait_type)),
        padding0__(0),
        timeout_(flatbuffers::EndianScalar(_timeout)) {
  }
  int32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  int32_t input_type() const {
    return flatbuffers::EndianScalar(input_type_);
  }
  int32_t wait_type() const {
    return flatbuffers::EndianScalar(wait_type_);
  }
  double timeout() const {
    return flatbuffers::EndianScalar(timeout_);
  }
};
FLATBUFFERS_STRUCT_END(AuxInputWait, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleSpeed FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;
  double factor_;
  double xoffset_;

 public:
  SpindleSpeed()
      : spindle_(0),
        padding0__(0),
        speed_(0),
        factor_(0),
        xoffset_(0) {
    (void)padding0__;
  }
  SpindleSpeed(int32_t _spindle, double _speed, double _factor, double _xoffset)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)),
        factor_(flatbuffers::EndianScalar(_factor)),
        xoffset_(flatbuffers::EndianScalar(_xoffset)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  double factor() const {
    return flatbuffers::EndianScalar(factor_);
  }
  double xoffset() const {
    return flatbuffers::EndianScalar(xoffset_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleSpeed, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleOrient FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double orientation_;
  int32_t mode_;
  int32_t padding1__;

 public:
  SpindleOrient()
      : spindle_(0),
        padding0__(0),
        orientation_(0),
        mode_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SpindleOrient(int32_t _spindle, double _orientation, int32_t _mode)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        orientation_(flatbuffers::EndianScalar(_orientation)),
        mode_(flatbuffers::EndianScalar(_mode)),
        padding1__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double orientation() const {
    return flatbuffers::EndianScalar(orientation_);
  }
  int32_t mode() const {
    return flatbuffers::EndianScalar(mode_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOrient, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleWaitOrient FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double timeout_;

 public:
  SpindleWaitOrient()
      : spindle_(0),
        padding0__(0),
        timeout_(0) {
    (void)padding0__;
  }
  SpindleWaitOrient(int32_t _spindle, double _timeout)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        timeout_(flatbuffers::EndianScalar(_timeout)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double timeout() const {
    return flatbuffers::EndianScalar(timeout_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleWaitOrient, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;
  double factor_;
  double xoffset_;
  int32_t wait_for_spindle_at_speed_;
  int32_t padding1__;

 public:
  SpindleOn()
      : spindle_(0),
        padding0__(0),
        speed_(0),
        factor_(0),
        xoffset_(0),
        wait_for_spindle_at_speed_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SpindleOn(int32_t _spindle, double _speed, double _factor, double _xoffset, int32_t _wait_for_spindle_at_speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)),
        factor_(flatbuffers::EndianScalar(_factor)),
        xoffset_(flatbuffers::EndianScalar(_xoffset)),
        wait_for_spindle_at_speed_(flatbuffers::EndianScalar(_wait_for_spindle_at_speed)),
        padding1__(0) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
  double factor() const {
    return flatbuffers::EndianScalar(factor_);
  }
  double xoffset() const {
    return flatbuffers::EndianScalar(xoffset_);
  }
  int32_t wait_for_spindle_at_speed() const {
    return flatbuffers::EndianScalar(wait_for_spindle_at_speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOn, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleOff()
      : spindle_(0) {
  }
  SpindleOff(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleOff, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleIncrease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleIncrease()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleIncrease(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleIncrease, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleDecrease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleDecrease()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleDecrease(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleDecrease, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SpindleConstant FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;
  int32_t padding0__;
  double speed_;

 public:
  SpindleConstant()
      : spindle_(0),
        padding0__(0),
        speed_(0) {
    (void)padding0__;
  }
  SpindleConstant(int32_t _spindle, double _speed)
      : spindle_(flatbuffers::EndianScalar(_spindle)),
        padding0__(0),
        speed_(flatbuffers::EndianScalar(_speed)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
  double speed() const {
    return flatbuffers::EndianScalar(speed_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleConstant, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleBrakeRelease FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleBrakeRelease()
      : spindle_(0) {
  }
  SpindleBrakeRelease(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleBrakeRelease, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpindleBrakeEngage FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t spindle_;

 public:
  SpindleBrakeEngage()
      : spindle_(0) {
  }
  SpindleBrakeEngage(int32_t _spindle)
      : spindle_(flatbuffers::EndianScalar(_spindle)) {
  }
  int32_t spindle() const {
    return flatbuffers::EndianScalar(spindle_);
  }
};
FLATBUFFERS_STRUCT_END(SpindleBrakeEngage, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantMistOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantMistOn()
      : dummy_(0) {
  }
  CoolantMistOn(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantMistOn, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantMistOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantMistOff()
      : dummy_(0) {
  }
  CoolantMistOff(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantMistOff, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantFloodOn FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantFloodOn()
      : dummy_(0) {
  }
  CoolantFloodOn(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantFloodOn, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CoolantFloodOff FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t dummy_;

 public:
  CoolantFloodOff()
      : dummy_(0) {
  }
  CoolantFloodOff(int32_t _dummy)
      : dummy_(flatbuffers::EndianScalar(_dummy)) {
  }
  int32_t dummy() const {
    return flatbuffers::EndianScalar(dummy_);
  }
};
FLATBUFFERS_STRUCT_END(CoolantFloodOff, 4);

struct JointLoadCompT : public flatbuffers::NativeTable {
  typedef JointLoadComp TableType;
  std::string file;
  int32_t type;
  JointLoadCompT()
      : type(0) {
  }
};

struct JointLoadComp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JointLoadCompT NativeTableType;
  typedef JointLoadCompBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4,
    VT_TYPE = 6
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  JointLoadCompT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JointLoadCompT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JointLoadComp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointLoadCompT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JointLoadCompBuilder {
  typedef JointLoadComp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(JointLoadComp::VT_FILE, file);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(JointLoadComp::VT_TYPE, type, 0);
  }
  explicit JointLoadCompBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<JointLoadComp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JointLoadComp>(end);
    return o;
  }
};

inline flatbuffers::Offset<JointLoadComp> CreateJointLoadComp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    int32_t type = 0) {
  JointLoadCompBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<JointLoadComp> CreateJointLoadCompDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr,
    int32_t type = 0) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateJointLoadComp(
      _fbb,
      file__,
      type);
}

flatbuffers::Offset<JointLoadComp> CreateJointLoadComp(flatbuffers::FlatBufferBuilder &_fbb, const JointLoadCompT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TrajCircularMoveT : public flatbuffers::NativeTable {
  typedef TrajCircularMove TableType;
  std::unique_ptr<EMC::Pose> end;
  std::unique_ptr<EMC::Cartesian> center;
  std::unique_ptr<EMC::Cartesian> normal;
  int32_t turn;
  int32_t type;
  double vel;
  double ini_maxvel;
  double acc;
  int32_t feed_mode;
  TrajCircularMoveT()
      : turn(0),
        type(0),
        vel(0.0),
        ini_maxvel(0.0),
        acc(0.0),
        feed_mode(0) {
  }
};

struct TrajCircularMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrajCircularMoveT NativeTableType;
  typedef TrajCircularMoveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_END = 4,
    VT_CENTER = 6,
    VT_NORMAL = 8,
    VT_TURN = 10,
    VT_TYPE = 12,
    VT_VEL = 14,
    VT_INI_MAXVEL = 16,
    VT_ACC = 18,
    VT_FEED_MODE = 20
  };
  const EMC::Pose *end() const {
    return GetStruct<const EMC::Pose *>(VT_END);
  }
  const EMC::Cartesian *center() const {
    return GetStruct<const EMC::Cartesian *>(VT_CENTER);
  }
  const EMC::Cartesian *normal() const {
    return GetStruct<const EMC::Cartesian *>(VT_NORMAL);
  }
  int32_t turn() const {
    return GetField<int32_t>(VT_TURN, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  double vel() const {
    return GetField<double>(VT_VEL, 0.0);
  }
  double ini_maxvel() const {
    return GetField<double>(VT_INI_MAXVEL, 0.0);
  }
  double acc() const {
    return GetField<double>(VT_ACC, 0.0);
  }
  int32_t feed_mode() const {
    return GetField<int32_t>(VT_FEED_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EMC::Pose>(verifier, VT_END) &&
           VerifyField<EMC::Cartesian>(verifier, VT_CENTER) &&
           VerifyField<EMC::Cartesian>(verifier, VT_NORMAL) &&
           VerifyField<int32_t>(verifier, VT_TURN) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<double>(verifier, VT_VEL) &&
           VerifyField<double>(verifier, VT_INI_MAXVEL) &&
           VerifyField<double>(verifier, VT_ACC) &&
           VerifyField<int32_t>(verifier, VT_FEED_MODE) &&
           verifier.EndTable();
  }
  TrajCircularMoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrajCircularMoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrajCircularMove> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrajCircularMoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrajCircularMoveBuilder {
  typedef TrajCircularMove Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_end(const EMC::Pose *end) {
    fbb_.AddStruct(TrajCircularMove::VT_END, end);
  }
  void add_center(const EMC::Cartesian *center) {
    fbb_.AddStruct(TrajCircularMove::VT_CENTER, center);
  }
  void add_normal(const EMC::Cartesian *normal) {
    fbb_.AddStruct(TrajCircularMove::VT_NORMAL, normal);
  }
  void add_turn(int32_t turn) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_TURN, turn, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_TYPE, type, 0);
  }
  void add_vel(double vel) {
    fbb_.AddElement<double>(TrajCircularMove::VT_VEL, vel, 0.0);
  }
  void add_ini_maxvel(double ini_maxvel) {
    fbb_.AddElement<double>(TrajCircularMove::VT_INI_MAXVEL, ini_maxvel, 0.0);
  }
  void add_acc(double acc) {
    fbb_.AddElement<double>(TrajCircularMove::VT_ACC, acc, 0.0);
  }
  void add_feed_mode(int32_t feed_mode) {
    fbb_.AddElement<int32_t>(TrajCircularMove::VT_FEED_MODE, feed_mode, 0);
  }
  explicit TrajCircularMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrajCircularMove> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrajCircularMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrajCircularMove> CreateTrajCircularMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EMC::Pose *end = 0,
    const EMC::Cartesian *center = 0,
    const EMC::Cartesian *normal = 0,
    int32_t turn = 0,
    int32_t type = 0,
    double vel = 0.0,
    double ini_maxvel = 0.0,
    double acc = 0.0,
    int32_t feed_mode = 0) {
  TrajCircularMoveBuilder builder_(_fbb);
  builder_.add_acc(acc);
  builder_.add_ini_maxvel(ini_maxvel);
  builder_.add_vel(vel);
  builder_.add_feed_mode(feed_mode);
  builder_.add_type(type);
  builder_.add_turn(turn);
  builder_.add_normal(normal);
  builder_.add_center(center);
  builder_.add_end(end);
  return builder_.Finish();
}

flatbuffers::Offset<TrajCircularMove> CreateTrajCircularMove(flatbuffers::FlatBufferBuilder &_fbb, const TrajCircularMoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskPlanOpenT : public flatbuffers::NativeTable {
  typedef TaskPlanOpen TableType;
  std::string file;
  TaskPlanOpenT() {
  }
};

struct TaskPlanOpen FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskPlanOpenT NativeTableType;
  typedef TaskPlanOpenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           verifier.EndTable();
  }
  TaskPlanOpenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskPlanOpenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TaskPlanOpen> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskPlanOpenBuilder {
  typedef TaskPlanOpen Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(TaskPlanOpen::VT_FILE, file);
  }
  explicit TaskPlanOpenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TaskPlanOpen> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskPlanOpen>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpen(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0) {
  TaskPlanOpenBuilder builder_(_fbb);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpenDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateTaskPlanOpen(
      _fbb,
      file__);
}

flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpen(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaskPlanExecuteT : public flatbuffers::NativeTable {
  typedef TaskPlanExecute TableType;
  std::string command;
  TaskPlanExecuteT() {
  }
};

struct TaskPlanExecute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaskPlanExecuteT NativeTableType;
  typedef TaskPlanExecuteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4
  };
  const flatbuffers::String *command() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMAND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(command()) &&
           verifier.EndTable();
  }
  TaskPlanExecuteT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaskPlanExecuteT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TaskPlanExecute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanExecuteT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaskPlanExecuteBuilder {
  typedef TaskPlanExecute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command(flatbuffers::Offset<flatbuffers::String> command) {
    fbb_.AddOffset(TaskPlanExecute::VT_COMMAND, command);
  }
  explicit TaskPlanExecuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TaskPlanExecute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskPlanExecute>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> command = 0) {
  TaskPlanExecuteBuilder builder_(_fbb);
  builder_.add_command(command);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *command = nullptr) {
  auto command__ = command ? _fbb.CreateString(command) : 0;
  return EMC::CreateTaskPlanExecute(
      _fbb,
      command__);
}

flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecute(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanExecuteT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ToolLoadToolTableT : public flatbuffers::NativeTable {
  typedef ToolLoadToolTable TableType;
  std::string file;
  ToolLoadToolTableT() {
  }
};

struct ToolLoadToolTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ToolLoadToolTableT NativeTableType;
  typedef ToolLoadToolTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           verifier.EndTable();
  }
  ToolLoadToolTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ToolLoadToolTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ToolLoadToolTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToolLoadToolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ToolLoadToolTableBuilder {
  typedef ToolLoadToolTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(ToolLoadToolTable::VT_FILE, file);
  }
  explicit ToolLoadToolTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ToolLoadToolTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToolLoadToolTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0) {
  ToolLoadToolTableBuilder builder_(_fbb);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr) {
  auto file__ = file ? _fbb.CreateString(file) : 0;
  return EMC::CreateToolLoadToolTable(
      _fbb,
      file__);
}

flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTable(flatbuffers::FlatBufferBuilder &_fbb, const ToolLoadToolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CmdChannelMsgT : public flatbuffers::NativeTable {
  typedef CmdChannelMsg TableType;
  EMC::CommandUnion command;
  CmdChannelMsgT() {
  }
};

struct CmdChannelMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CmdChannelMsgT NativeTableType;
  typedef CmdChannelMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  EMC::Command command_type() const {
    return static_cast<EMC::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const EMC::SetDebug *command_as_set_debug() const {
    return command_type() == EMC::Command_set_debug ? static_cast<const EMC::SetDebug *>(command()) : nullptr;
  }
  const EMC::JogCmd *command_as_jog_cmd() const {
    return command_type() == EMC::Command_jog_cmd ? static_cast<const EMC::JogCmd *>(command()) : nullptr;
  }
  const EMC::JointSetBacklash *command_as_joint_set_backlash() const {
    return command_type() == EMC::Command_joint_set_backlash ? static_cast<const EMC::JointSetBacklash *>(command()) : nullptr;
  }
  const EMC::JointSetMinPositionLimit *command_as_joint_set_min_position_limit() const {
    return command_type() == EMC::Command_joint_set_min_position_limit ? static_cast<const EMC::JointSetMinPositionLimit *>(command()) : nullptr;
  }
  const EMC::JointSetMaxPositionLimit *command_as_joint_set_max_position_limit() const {
    return command_type() == EMC::Command_joint_set_max_position_limit ? static_cast<const EMC::JointSetMaxPositionLimit *>(command()) : nullptr;
  }
  const EMC::JointSetFerror *command_as_joint_set_ferror() const {
    return command_type() == EMC::Command_joint_set_ferror ? static_cast<const EMC::JointSetFerror *>(command()) : nullptr;
  }
  const EMC::JointSetMinFerror *command_as_joint_set_min_ferror() const {
    return command_type() == EMC::Command_joint_set_min_ferror ? static_cast<const EMC::JointSetMinFerror *>(command()) : nullptr;
  }
  const EMC::JointSetHomingParams *command_as_joint_set_homing_params() const {
    return command_type() == EMC::Command_joint_set_homing_params ? static_cast<const EMC::JointSetHomingParams *>(command()) : nullptr;
  }
  const EMC::JointHome *command_as_joint_home() const {
    return command_type() == EMC::Command_joint_home ? static_cast<const EMC::JointHome *>(command()) : nullptr;
  }
  const EMC::JointUnhome *command_as_joint_unhome() const {
    return command_type() == EMC::Command_joint_unhome ? static_cast<const EMC::JointUnhome *>(command()) : nullptr;
  }
  const EMC::JointHalt *command_as_joint_halt() const {
    return command_type() == EMC::Command_joint_halt ? static_cast<const EMC::JointHalt *>(command()) : nullptr;
  }
  const EMC::JogCont *command_as_jog_cont() const {
    return command_type() == EMC::Command_jog_cont ? static_cast<const EMC::JogCont *>(command()) : nullptr;
  }
  const EMC::JogIncr *command_as_jog_incr() const {
    return command_type() == EMC::Command_jog_incr ? static_cast<const EMC::JogIncr *>(command()) : nullptr;
  }
  const EMC::JogAbs *command_as_jog_abs() const {
    return command_type() == EMC::Command_jog_abs ? static_cast<const EMC::JogAbs *>(command()) : nullptr;
  }
  const EMC::JogStop *command_as_jog_stop() const {
    return command_type() == EMC::Command_jog_stop ? static_cast<const EMC::JogStop *>(command()) : nullptr;
  }
  const EMC::JointOverrideLimits *command_as_joint_override_limits() const {
    return command_type() == EMC::Command_joint_override_limits ? static_cast<const EMC::JointOverrideLimits *>(command()) : nullptr;
  }
  const EMC::JointLoadComp *command_as_joint_load_comp() const {
    return command_type() == EMC::Command_joint_load_comp ? static_cast<const EMC::JointLoadComp *>(command()) : nullptr;
  }
  const EMC::TrajSetMode *command_as_traj_set_mode() const {
    return command_type() == EMC::Command_traj_set_mode ? static_cast<const EMC::TrajSetMode *>(command()) : nullptr;
  }
  const EMC::TrajSetVelocity *command_as_traj_set_velocity() const {
    return command_type() == EMC::Command_traj_set_velocity ? static_cast<const EMC::TrajSetVelocity *>(command()) : nullptr;
  }
  const EMC::TrajSetAcceleration *command_as_tral_set_acceleration() const {
    return command_type() == EMC::Command_tral_set_acceleration ? static_cast<const EMC::TrajSetAcceleration *>(command()) : nullptr;
  }
  const EMC::TrajSetMaxVelocity *command_as_traj_set_max_velocity() const {
    return command_type() == EMC::Command_traj_set_max_velocity ? static_cast<const EMC::TrajSetMaxVelocity *>(command()) : nullptr;
  }
  const EMC::TrajSetScale *command_as_traj_set_scale() const {
    return command_type() == EMC::Command_traj_set_scale ? static_cast<const EMC::TrajSetScale *>(command()) : nullptr;
  }
  const EMC::TrajSetRapidScale *command_as_traj_set_rapid_scale() const {
    return command_type() == EMC::Command_traj_set_rapid_scale ? static_cast<const EMC::TrajSetRapidScale *>(command()) : nullptr;
  }
  const EMC::TrajSetSpindleScale *command_as_traj_set_spindl_scale() const {
    return command_type() == EMC::Command_traj_set_spindl_scale ? static_cast<const EMC::TrajSetSpindleScale *>(command()) : nullptr;
  }
  const EMC::TrajSetFOEnable *command_as_traj_set_fo_enable() const {
    return command_type() == EMC::Command_traj_set_fo_enable ? static_cast<const EMC::TrajSetFOEnable *>(command()) : nullptr;
  }
  const EMC::TrajSetSOEnable *command_as_traj_set_so_enable() const {
    return command_type() == EMC::Command_traj_set_so_enable ? static_cast<const EMC::TrajSetSOEnable *>(command()) : nullptr;
  }
  const EMC::TrajSetFHEnable *command_as_traj_set_fh_enable() const {
    return command_type() == EMC::Command_traj_set_fh_enable ? static_cast<const EMC::TrajSetFHEnable *>(command()) : nullptr;
  }
  const EMC::TrajAbort *command_as_traj_abort() const {
    return command_type() == EMC::Command_traj_abort ? static_cast<const EMC::TrajAbort *>(command()) : nullptr;
  }
  const EMC::TrajPause *command_as_traj_pause() const {
    return command_type() == EMC::Command_traj_pause ? static_cast<const EMC::TrajPause *>(command()) : nullptr;
  }
  const EMC::TrajResume *command_as_traj_resume() const {
    return command_type() == EMC::Command_traj_resume ? static_cast<const EMC::TrajResume *>(command()) : nullptr;
  }
  const EMC::TrajDelay *command_as_traj_delay() const {
    return command_type() == EMC::Command_traj_delay ? static_cast<const EMC::TrajDelay *>(command()) : nullptr;
  }
  const EMC::TrajLinearMove *command_as_traj_linear_move() const {
    return command_type() == EMC::Command_traj_linear_move ? static_cast<const EMC::TrajLinearMove *>(command()) : nullptr;
  }
  const EMC::TrajCircularMove *command_as_traj_circular_move() const {
    return command_type() == EMC::Command_traj_circular_move ? static_cast<const EMC::TrajCircularMove *>(command()) : nullptr;
  }
  const EMC::TrajSetTermCond *command_as_traj_set_term_cond() const {
    return command_type() == EMC::Command_traj_set_term_cond ? static_cast<const EMC::TrajSetTermCond *>(command()) : nullptr;
  }
  const EMC::TrajSetSpindleSync *command_as_traj_set_spindle_sync() const {
    return command_type() == EMC::Command_traj_set_spindle_sync ? static_cast<const EMC::TrajSetSpindleSync *>(command()) : nullptr;
  }
  const EMC::TrajSetOffset *command_as_traj_set_offset() const {
    return command_type() == EMC::Command_traj_set_offset ? static_cast<const EMC::TrajSetOffset *>(command()) : nullptr;
  }
  const EMC::TrajSetG5x *command_as_traj_set_g5x() const {
    return command_type() == EMC::Command_traj_set_g5x ? static_cast<const EMC::TrajSetG5x *>(command()) : nullptr;
  }
  const EMC::TrajSetG92 *command_as_traj_set_g92() const {
    return command_type() == EMC::Command_traj_set_g92 ? static_cast<const EMC::TrajSetG92 *>(command()) : nullptr;
  }
  const EMC::TrajSetRotation *command_as_traj_set_rotation() const {
    return command_type() == EMC::Command_traj_set_rotation ? static_cast<const EMC::TrajSetRotation *>(command()) : nullptr;
  }
  const EMC::TrajClearProbeTrippedFlag *command_as_traj_clear_probe_tripped_flag() const {
    return command_type() == EMC::Command_traj_clear_probe_tripped_flag ? static_cast<const EMC::TrajClearProbeTrippedFlag *>(command()) : nullptr;
  }
  const EMC::TrajSetTeleopEnable *command_as_traj_set_teleop_enable() const {
    return command_type() == EMC::Command_traj_set_teleop_enable ? static_cast<const EMC::TrajSetTeleopEnable *>(command()) : nullptr;
  }
  const EMC::TrajProbe *command_as_traj_probe() const {
    return command_type() == EMC::Command_traj_probe ? static_cast<const EMC::TrajProbe *>(command()) : nullptr;
  }
  const EMC::TrajRigidTap *command_as_traj_rigid_tap() const {
    return command_type() == EMC::Command_traj_rigid_tap ? static_cast<const EMC::TrajRigidTap *>(command()) : nullptr;
  }
  const EMC::MotionSetAOut *command_as_motion_set_aout() const {
    return command_type() == EMC::Command_motion_set_aout ? static_cast<const EMC::MotionSetAOut *>(command()) : nullptr;
  }
  const EMC::MotionSetDOut *command_as_motion_set_dout() const {
    return command_type() == EMC::Command_motion_set_dout ? static_cast<const EMC::MotionSetDOut *>(command()) : nullptr;
  }
  const EMC::MotionAdaptive *command_as_motion_adaptive() const {
    return command_type() == EMC::Command_motion_adaptive ? static_cast<const EMC::MotionAdaptive *>(command()) : nullptr;
  }
  const EMC::TaskAbort *command_as_task_abort() const {
    return command_type() == EMC::Command_task_abort ? static_cast<const EMC::TaskAbort *>(command()) : nullptr;
  }
  const EMC::TaskSetMode *command_as_task_set_mode() const {
    return command_type() == EMC::Command_task_set_mode ? static_cast<const EMC::TaskSetMode *>(command()) : nullptr;
  }
  const EMC::TaskSetState *command_as_task_set_state() const {
    return command_type() == EMC::Command_task_set_state ? static_cast<const EMC::TaskSetState *>(command()) : nullptr;
  }
  const EMC::TaskPlanOpen *command_as_task_plan_open() const {
    return command_type() == EMC::Command_task_plan_open ? static_cast<const EMC::TaskPlanOpen *>(command()) : nullptr;
  }
  const EMC::TaskPlanRun *command_as_task_plan_run() const {
    return command_type() == EMC::Command_task_plan_run ? static_cast<const EMC::TaskPlanRun *>(command()) : nullptr;
  }
  const EMC::TaskPlanExecute *command_as_task_plan_execute() const {
    return command_type() == EMC::Command_task_plan_execute ? static_cast<const EMC::TaskPlanExecute *>(command()) : nullptr;
  }
  const EMC::TaskPlanReverse *command_as_task_plan_reverse() const {
    return command_type() == EMC::Command_task_plan_reverse ? static_cast<const EMC::TaskPlanReverse *>(command()) : nullptr;
  }
  const EMC::TaskPlanForward *command_as_task_plan_forward() const {
    return command_type() == EMC::Command_task_plan_forward ? static_cast<const EMC::TaskPlanForward *>(command()) : nullptr;
  }
  const EMC::TaskPlanStep *command_as_task_plan_step() const {
    return command_type() == EMC::Command_task_plan_step ? static_cast<const EMC::TaskPlanStep *>(command()) : nullptr;
  }
  const EMC::TaskPlanResume *command_as_task_plan_resume() const {
    return command_type() == EMC::Command_task_plan_resume ? static_cast<const EMC::TaskPlanResume *>(command()) : nullptr;
  }
  const EMC::TaskPlanEnd *command_as_task_plan_end() const {
    return command_type() == EMC::Command_task_plan_end ? static_cast<const EMC::TaskPlanEnd *>(command()) : nullptr;
  }
  const EMC::TaskPlanClose *command_as_task_plan_close() const {
    return command_type() == EMC::Command_task_plan_close ? static_cast<const EMC::TaskPlanClose *>(command()) : nullptr;
  }
  const EMC::TaskPlanInit *command_as_task_plan_init() const {
    return command_type() == EMC::Command_task_plan_init ? static_cast<const EMC::TaskPlanInit *>(command()) : nullptr;
  }
  const EMC::TaskPlanSynch *command_as_task_plan_synch() const {
    return command_type() == EMC::Command_task_plan_synch ? static_cast<const EMC::TaskPlanSynch *>(command()) : nullptr;
  }
  const EMC::TaskPlanSetOptionalStop *command_as_task_plan_set_optional_stop() const {
    return command_type() == EMC::Command_task_plan_set_optional_stop ? static_cast<const EMC::TaskPlanSetOptionalStop *>(command()) : nullptr;
  }
  const EMC::TaskPlanSetBlockDelete *command_as_task_plan_set_block_delete() const {
    return command_type() == EMC::Command_task_plan_set_block_delete ? static_cast<const EMC::TaskPlanSetBlockDelete *>(command()) : nullptr;
  }
  const EMC::TaskPlanOptionalStop *command_as_task_plan_optional_stop() const {
    return command_type() == EMC::Command_task_plan_optional_stop ? static_cast<const EMC::TaskPlanOptionalStop *>(command()) : nullptr;
  }
  const EMC::ToolCmd *command_as_tool_cmd() const {
    return command_type() == EMC::Command_tool_cmd ? static_cast<const EMC::ToolCmd *>(command()) : nullptr;
  }
  const EMC::ToolHalt *command_as_tool_halt() const {
    return command_type() == EMC::Command_tool_halt ? static_cast<const EMC::ToolHalt *>(command()) : nullptr;
  }
  const EMC::ToolAbort *command_as_tool_abort() const {
    return command_type() == EMC::Command_tool_abort ? static_cast<const EMC::ToolAbort *>(command()) : nullptr;
  }
  const EMC::ToolPrepare *command_as_tool_prepare() const {
    return command_type() == EMC::Command_tool_prepare ? static_cast<const EMC::ToolPrepare *>(command()) : nullptr;
  }
  const EMC::ToolLoad *command_as_tool_load() const {
    return command_type() == EMC::Command_tool_load ? static_cast<const EMC::ToolLoad *>(command()) : nullptr;
  }
  const EMC::ToolLoadToolTable *command_as_tool_load_tool_table() const {
    return command_type() == EMC::Command_tool_load_tool_table ? static_cast<const EMC::ToolLoadToolTable *>(command()) : nullptr;
  }
  const EMC::ToolSetOffset *command_as_tool_set_offset() const {
    return command_type() == EMC::Command_tool_set_offset ? static_cast<const EMC::ToolSetOffset *>(command()) : nullptr;
  }
  const EMC::ToolSetNumber *command_as_tool_set_number() const {
    return command_type() == EMC::Command_tool_set_number ? static_cast<const EMC::ToolSetNumber *>(command()) : nullptr;
  }
  const EMC::AuxInputWait *command_as_aux_input_wait() const {
    return command_type() == EMC::Command_aux_input_wait ? static_cast<const EMC::AuxInputWait *>(command()) : nullptr;
  }
  const EMC::SpindleSpeed *command_as_spindle_speed() const {
    return command_type() == EMC::Command_spindle_speed ? static_cast<const EMC::SpindleSpeed *>(command()) : nullptr;
  }
  const EMC::SpindleOrient *command_as_spindle_orient() const {
    return command_type() == EMC::Command_spindle_orient ? static_cast<const EMC::SpindleOrient *>(command()) : nullptr;
  }
  const EMC::SpindleWaitOrient *command_as_spindle_wait_orient() const {
    return command_type() == EMC::Command_spindle_wait_orient ? static_cast<const EMC::SpindleWaitOrient *>(command()) : nullptr;
  }
  const EMC::SpindleOn *command_as_spindle_on() const {
    return command_type() == EMC::Command_spindle_on ? static_cast<const EMC::SpindleOn *>(command()) : nullptr;
  }
  const EMC::SpindleOff *command_as_spindle_off() const {
    return command_type() == EMC::Command_spindle_off ? static_cast<const EMC::SpindleOff *>(command()) : nullptr;
  }
  const EMC::SpindleIncrease *command_as_spindle_increase() const {
    return command_type() == EMC::Command_spindle_increase ? static_cast<const EMC::SpindleIncrease *>(command()) : nullptr;
  }
  const EMC::SpindleDecrease *command_as_spindle_decrease() const {
    return command_type() == EMC::Command_spindle_decrease ? static_cast<const EMC::SpindleDecrease *>(command()) : nullptr;
  }
  const EMC::SpindleConstant *command_as_spindle_constant() const {
    return command_type() == EMC::Command_spindle_constant ? static_cast<const EMC::SpindleConstant *>(command()) : nullptr;
  }
  const EMC::SpindleBrakeRelease *command_as_spindle_brake_release() const {
    return command_type() == EMC::Command_spindle_brake_release ? static_cast<const EMC::SpindleBrakeRelease *>(command()) : nullptr;
  }
  const EMC::SpindleBrakeEngage *command_as_spindle_brake_engage() const {
    return command_type() == EMC::Command_spindle_brake_engage ? static_cast<const EMC::SpindleBrakeEngage *>(command()) : nullptr;
  }
  const EMC::CoolantMistOn *command_as_coolant_mist_on() const {
    return command_type() == EMC::Command_coolant_mist_on ? static_cast<const EMC::CoolantMistOn *>(command()) : nullptr;
  }
  const EMC::CoolantMistOff *command_as_coolant_mist_off() const {
    return command_type() == EMC::Command_coolant_mist_off ? static_cast<const EMC::CoolantMistOff *>(command()) : nullptr;
  }
  const EMC::CoolantFloodOn *command_as_coolant_flood_on() const {
    return command_type() == EMC::Command_coolant_flood_on ? static_cast<const EMC::CoolantFloodOn *>(command()) : nullptr;
  }
  const EMC::CoolantFloodOff *command_as_coolant_flood_off() const {
    return command_type() == EMC::Command_coolant_flood_off ? static_cast<const EMC::CoolantFloodOff *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
  CmdChannelMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CmdChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CmdChannelMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const EMC::SetDebug *CmdChannelMsg::command_as<EMC::SetDebug>() const {
  return command_as_set_debug();
}

template<> inline const EMC::JogCmd *CmdChannelMsg::command_as<EMC::JogCmd>() const {
  return command_as_jog_cmd();
}

template<> inline const EMC::JointSetBacklash *CmdChannelMsg::command_as<EMC::JointSetBacklash>() const {
  return command_as_joint_set_backlash();
}

template<> inline const EMC::JointSetMinPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMinPositionLimit>() const {
  return command_as_joint_set_min_position_limit();
}

template<> inline const EMC::JointSetMaxPositionLimit *CmdChannelMsg::command_as<EMC::JointSetMaxPositionLimit>() const {
  return command_as_joint_set_max_position_limit();
}

template<> inline const EMC::JointSetFerror *CmdChannelMsg::command_as<EMC::JointSetFerror>() const {
  return command_as_joint_set_ferror();
}

template<> inline const EMC::JointSetMinFerror *CmdChannelMsg::command_as<EMC::JointSetMinFerror>() const {
  return command_as_joint_set_min_ferror();
}

template<> inline const EMC::JointSetHomingParams *CmdChannelMsg::command_as<EMC::JointSetHomingParams>() const {
  return command_as_joint_set_homing_params();
}

template<> inline const EMC::JointHome *CmdChannelMsg::command_as<EMC::JointHome>() const {
  return command_as_joint_home();
}

template<> inline const EMC::JointUnhome *CmdChannelMsg::command_as<EMC::JointUnhome>() const {
  return command_as_joint_unhome();
}

template<> inline const EMC::JointHalt *CmdChannelMsg::command_as<EMC::JointHalt>() const {
  return command_as_joint_halt();
}

template<> inline const EMC::JogCont *CmdChannelMsg::command_as<EMC::JogCont>() const {
  return command_as_jog_cont();
}

template<> inline const EMC::JogIncr *CmdChannelMsg::command_as<EMC::JogIncr>() const {
  return command_as_jog_incr();
}

template<> inline const EMC::JogAbs *CmdChannelMsg::command_as<EMC::JogAbs>() const {
  return command_as_jog_abs();
}

template<> inline const EMC::JogStop *CmdChannelMsg::command_as<EMC::JogStop>() const {
  return command_as_jog_stop();
}

template<> inline const EMC::JointOverrideLimits *CmdChannelMsg::command_as<EMC::JointOverrideLimits>() const {
  return command_as_joint_override_limits();
}

template<> inline const EMC::JointLoadComp *CmdChannelMsg::command_as<EMC::JointLoadComp>() const {
  return command_as_joint_load_comp();
}

template<> inline const EMC::TrajSetMode *CmdChannelMsg::command_as<EMC::TrajSetMode>() const {
  return command_as_traj_set_mode();
}

template<> inline const EMC::TrajSetVelocity *CmdChannelMsg::command_as<EMC::TrajSetVelocity>() const {
  return command_as_traj_set_velocity();
}

template<> inline const EMC::TrajSetAcceleration *CmdChannelMsg::command_as<EMC::TrajSetAcceleration>() const {
  return command_as_tral_set_acceleration();
}

template<> inline const EMC::TrajSetMaxVelocity *CmdChannelMsg::command_as<EMC::TrajSetMaxVelocity>() const {
  return command_as_traj_set_max_velocity();
}

template<> inline const EMC::TrajSetScale *CmdChannelMsg::command_as<EMC::TrajSetScale>() const {
  return command_as_traj_set_scale();
}

template<> inline const EMC::TrajSetRapidScale *CmdChannelMsg::command_as<EMC::TrajSetRapidScale>() const {
  return command_as_traj_set_rapid_scale();
}

template<> inline const EMC::TrajSetSpindleScale *CmdChannelMsg::command_as<EMC::TrajSetSpindleScale>() const {
  return command_as_traj_set_spindl_scale();
}

template<> inline const EMC::TrajSetFOEnable *CmdChannelMsg::command_as<EMC::TrajSetFOEnable>() const {
  return command_as_traj_set_fo_enable();
}

template<> inline const EMC::TrajSetSOEnable *CmdChannelMsg::command_as<EMC::TrajSetSOEnable>() const {
  return command_as_traj_set_so_enable();
}

template<> inline const EMC::TrajSetFHEnable *CmdChannelMsg::command_as<EMC::TrajSetFHEnable>() const {
  return command_as_traj_set_fh_enable();
}

template<> inline const EMC::TrajAbort *CmdChannelMsg::command_as<EMC::TrajAbort>() const {
  return command_as_traj_abort();
}

template<> inline const EMC::TrajPause *CmdChannelMsg::command_as<EMC::TrajPause>() const {
  return command_as_traj_pause();
}

template<> inline const EMC::TrajResume *CmdChannelMsg::command_as<EMC::TrajResume>() const {
  return command_as_traj_resume();
}

template<> inline const EMC::TrajDelay *CmdChannelMsg::command_as<EMC::TrajDelay>() const {
  return command_as_traj_delay();
}

template<> inline const EMC::TrajLinearMove *CmdChannelMsg::command_as<EMC::TrajLinearMove>() const {
  return command_as_traj_linear_move();
}

template<> inline const EMC::TrajCircularMove *CmdChannelMsg::command_as<EMC::TrajCircularMove>() const {
  return command_as_traj_circular_move();
}

template<> inline const EMC::TrajSetTermCond *CmdChannelMsg::command_as<EMC::TrajSetTermCond>() const {
  return command_as_traj_set_term_cond();
}

template<> inline const EMC::TrajSetSpindleSync *CmdChannelMsg::command_as<EMC::TrajSetSpindleSync>() const {
  return command_as_traj_set_spindle_sync();
}

template<> inline const EMC::TrajSetOffset *CmdChannelMsg::command_as<EMC::TrajSetOffset>() const {
  return command_as_traj_set_offset();
}

template<> inline const EMC::TrajSetG5x *CmdChannelMsg::command_as<EMC::TrajSetG5x>() const {
  return command_as_traj_set_g5x();
}

template<> inline const EMC::TrajSetG92 *CmdChannelMsg::command_as<EMC::TrajSetG92>() const {
  return command_as_traj_set_g92();
}

template<> inline const EMC::TrajSetRotation *CmdChannelMsg::command_as<EMC::TrajSetRotation>() const {
  return command_as_traj_set_rotation();
}

template<> inline const EMC::TrajClearProbeTrippedFlag *CmdChannelMsg::command_as<EMC::TrajClearProbeTrippedFlag>() const {
  return command_as_traj_clear_probe_tripped_flag();
}

template<> inline const EMC::TrajSetTeleopEnable *CmdChannelMsg::command_as<EMC::TrajSetTeleopEnable>() const {
  return command_as_traj_set_teleop_enable();
}

template<> inline const EMC::TrajProbe *CmdChannelMsg::command_as<EMC::TrajProbe>() const {
  return command_as_traj_probe();
}

template<> inline const EMC::TrajRigidTap *CmdChannelMsg::command_as<EMC::TrajRigidTap>() const {
  return command_as_traj_rigid_tap();
}

template<> inline const EMC::MotionSetAOut *CmdChannelMsg::command_as<EMC::MotionSetAOut>() const {
  return command_as_motion_set_aout();
}

template<> inline const EMC::MotionSetDOut *CmdChannelMsg::command_as<EMC::MotionSetDOut>() const {
  return command_as_motion_set_dout();
}

template<> inline const EMC::MotionAdaptive *CmdChannelMsg::command_as<EMC::MotionAdaptive>() const {
  return command_as_motion_adaptive();
}

template<> inline const EMC::TaskAbort *CmdChannelMsg::command_as<EMC::TaskAbort>() const {
  return command_as_task_abort();
}

template<> inline const EMC::TaskSetMode *CmdChannelMsg::command_as<EMC::TaskSetMode>() const {
  return command_as_task_set_mode();
}

template<> inline const EMC::TaskSetState *CmdChannelMsg::command_as<EMC::TaskSetState>() const {
  return command_as_task_set_state();
}

template<> inline const EMC::TaskPlanOpen *CmdChannelMsg::command_as<EMC::TaskPlanOpen>() const {
  return command_as_task_plan_open();
}

template<> inline const EMC::TaskPlanRun *CmdChannelMsg::command_as<EMC::TaskPlanRun>() const {
  return command_as_task_plan_run();
}

template<> inline const EMC::TaskPlanExecute *CmdChannelMsg::command_as<EMC::TaskPlanExecute>() const {
  return command_as_task_plan_execute();
}

template<> inline const EMC::TaskPlanReverse *CmdChannelMsg::command_as<EMC::TaskPlanReverse>() const {
  return command_as_task_plan_reverse();
}

template<> inline const EMC::TaskPlanForward *CmdChannelMsg::command_as<EMC::TaskPlanForward>() const {
  return command_as_task_plan_forward();
}

template<> inline const EMC::TaskPlanStep *CmdChannelMsg::command_as<EMC::TaskPlanStep>() const {
  return command_as_task_plan_step();
}

template<> inline const EMC::TaskPlanResume *CmdChannelMsg::command_as<EMC::TaskPlanResume>() const {
  return command_as_task_plan_resume();
}

template<> inline const EMC::TaskPlanEnd *CmdChannelMsg::command_as<EMC::TaskPlanEnd>() const {
  return command_as_task_plan_end();
}

template<> inline const EMC::TaskPlanClose *CmdChannelMsg::command_as<EMC::TaskPlanClose>() const {
  return command_as_task_plan_close();
}

template<> inline const EMC::TaskPlanInit *CmdChannelMsg::command_as<EMC::TaskPlanInit>() const {
  return command_as_task_plan_init();
}

template<> inline const EMC::TaskPlanSynch *CmdChannelMsg::command_as<EMC::TaskPlanSynch>() const {
  return command_as_task_plan_synch();
}

template<> inline const EMC::TaskPlanSetOptionalStop *CmdChannelMsg::command_as<EMC::TaskPlanSetOptionalStop>() const {
  return command_as_task_plan_set_optional_stop();
}

template<> inline const EMC::TaskPlanSetBlockDelete *CmdChannelMsg::command_as<EMC::TaskPlanSetBlockDelete>() const {
  return command_as_task_plan_set_block_delete();
}

template<> inline const EMC::TaskPlanOptionalStop *CmdChannelMsg::command_as<EMC::TaskPlanOptionalStop>() const {
  return command_as_task_plan_optional_stop();
}

template<> inline const EMC::ToolCmd *CmdChannelMsg::command_as<EMC::ToolCmd>() const {
  return command_as_tool_cmd();
}

template<> inline const EMC::ToolHalt *CmdChannelMsg::command_as<EMC::ToolHalt>() const {
  return command_as_tool_halt();
}

template<> inline const EMC::ToolAbort *CmdChannelMsg::command_as<EMC::ToolAbort>() const {
  return command_as_tool_abort();
}

template<> inline const EMC::ToolPrepare *CmdChannelMsg::command_as<EMC::ToolPrepare>() const {
  return command_as_tool_prepare();
}

template<> inline const EMC::ToolLoad *CmdChannelMsg::command_as<EMC::ToolLoad>() const {
  return command_as_tool_load();
}

template<> inline const EMC::ToolLoadToolTable *CmdChannelMsg::command_as<EMC::ToolLoadToolTable>() const {
  return command_as_tool_load_tool_table();
}

template<> inline const EMC::ToolSetOffset *CmdChannelMsg::command_as<EMC::ToolSetOffset>() const {
  return command_as_tool_set_offset();
}

template<> inline const EMC::ToolSetNumber *CmdChannelMsg::command_as<EMC::ToolSetNumber>() const {
  return command_as_tool_set_number();
}

template<> inline const EMC::AuxInputWait *CmdChannelMsg::command_as<EMC::AuxInputWait>() const {
  return command_as_aux_input_wait();
}

template<> inline const EMC::SpindleSpeed *CmdChannelMsg::command_as<EMC::SpindleSpeed>() const {
  return command_as_spindle_speed();
}

template<> inline const EMC::SpindleOrient *CmdChannelMsg::command_as<EMC::SpindleOrient>() const {
  return command_as_spindle_orient();
}

template<> inline const EMC::SpindleWaitOrient *CmdChannelMsg::command_as<EMC::SpindleWaitOrient>() const {
  return command_as_spindle_wait_orient();
}

template<> inline const EMC::SpindleOn *CmdChannelMsg::command_as<EMC::SpindleOn>() const {
  return command_as_spindle_on();
}

template<> inline const EMC::SpindleOff *CmdChannelMsg::command_as<EMC::SpindleOff>() const {
  return command_as_spindle_off();
}

template<> inline const EMC::SpindleIncrease *CmdChannelMsg::command_as<EMC::SpindleIncrease>() const {
  return command_as_spindle_increase();
}

template<> inline const EMC::SpindleDecrease *CmdChannelMsg::command_as<EMC::SpindleDecrease>() const {
  return command_as_spindle_decrease();
}

template<> inline const EMC::SpindleConstant *CmdChannelMsg::command_as<EMC::SpindleConstant>() const {
  return command_as_spindle_constant();
}

template<> inline const EMC::SpindleBrakeRelease *CmdChannelMsg::command_as<EMC::SpindleBrakeRelease>() const {
  return command_as_spindle_brake_release();
}

template<> inline const EMC::SpindleBrakeEngage *CmdChannelMsg::command_as<EMC::SpindleBrakeEngage>() const {
  return command_as_spindle_brake_engage();
}

template<> inline const EMC::CoolantMistOn *CmdChannelMsg::command_as<EMC::CoolantMistOn>() const {
  return command_as_coolant_mist_on();
}

template<> inline const EMC::CoolantMistOff *CmdChannelMsg::command_as<EMC::CoolantMistOff>() const {
  return command_as_coolant_mist_off();
}

template<> inline const EMC::CoolantFloodOn *CmdChannelMsg::command_as<EMC::CoolantFloodOn>() const {
  return command_as_coolant_flood_on();
}

template<> inline const EMC::CoolantFloodOff *CmdChannelMsg::command_as<EMC::CoolantFloodOff>() const {
  return command_as_coolant_flood_off();
}

struct CmdChannelMsgBuilder {
  typedef CmdChannelMsg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command_type(EMC::Command command_type) {
    fbb_.AddElement<uint8_t>(CmdChannelMsg::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(CmdChannelMsg::VT_COMMAND, command);
  }
  explicit CmdChannelMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CmdChannelMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CmdChannelMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    EMC::Command command_type = EMC::Command_NONE,
    flatbuffers::Offset<void> command = 0) {
  CmdChannelMsgBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugLevelT : public flatbuffers::NativeTable {
  typedef DebugLevel TableType;
  int32_t debug_level;
  DebugLevelT()
      : debug_level(0) {
  }
};

struct DebugLevel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugLevelT NativeTableType;
  typedef DebugLevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG_LEVEL = 4
  };
  int32_t debug_level() const {
    return GetField<int32_t>(VT_DEBUG_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEBUG_LEVEL) &&
           verifier.EndTable();
  }
  DebugLevelT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugLevelT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DebugLevel> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugLevelT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DebugLevelBuilder {
  typedef DebugLevel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug_level(int32_t debug_level) {
    fbb_.AddElement<int32_t>(DebugLevel::VT_DEBUG_LEVEL, debug_level, 0);
  }
  explicit DebugLevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DebugLevel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugLevel>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugLevel> CreateDebugLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t debug_level = 0) {
  DebugLevelBuilder builder_(_fbb);
  builder_.add_debug_level(debug_level);
  return builder_.Finish();
}

flatbuffers::Offset<DebugLevel> CreateDebugLevel(flatbuffers::FlatBufferBuilder &_fbb, const DebugLevelT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResultT : public flatbuffers::NativeTable {
  typedef Result TableType;
  int32_t result;
  ResultT()
      : result(0) {
  }
};

struct Result FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResultT NativeTableType;
  typedef ResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  int32_t result() const {
    return GetField<int32_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
  ResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Result> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResultBuilder {
  typedef Result Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(int32_t result) {
    fbb_.AddElement<int32_t>(Result::VT_RESULT, result, 0);
  }
  explicit ResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Result> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Result>(end);
    return o;
  }
};

inline flatbuffers::Offset<Result> CreateResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t result = 0) {
  ResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline JointLoadCompT *JointLoadComp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::JointLoadCompT> _o = std::unique_ptr<EMC::JointLoadCompT>(new JointLoadCompT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void JointLoadComp::UnPackTo(JointLoadCompT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = file(); if (_e) _o->file = _e->str(); }
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<JointLoadComp> JointLoadComp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JointLoadCompT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJointLoadComp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JointLoadComp> CreateJointLoadComp(flatbuffers::FlatBufferBuilder &_fbb, const JointLoadCompT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const JointLoadCompT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _file = _o->file.empty() ? 0 : _fbb.CreateString(_o->file);
  auto _type = _o->type;
  return EMC::CreateJointLoadComp(
      _fbb,
      _file,
      _type);
}

inline TrajCircularMoveT *TrajCircularMove::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::TrajCircularMoveT> _o = std::unique_ptr<EMC::TrajCircularMoveT>(new TrajCircularMoveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TrajCircularMove::UnPackTo(TrajCircularMoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = end(); if (_e) _o->end = std::unique_ptr<EMC::Pose>(new EMC::Pose(*_e)); }
  { auto _e = center(); if (_e) _o->center = std::unique_ptr<EMC::Cartesian>(new EMC::Cartesian(*_e)); }
  { auto _e = normal(); if (_e) _o->normal = std::unique_ptr<EMC::Cartesian>(new EMC::Cartesian(*_e)); }
  { auto _e = turn(); _o->turn = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = vel(); _o->vel = _e; }
  { auto _e = ini_maxvel(); _o->ini_maxvel = _e; }
  { auto _e = acc(); _o->acc = _e; }
  { auto _e = feed_mode(); _o->feed_mode = _e; }
}

inline flatbuffers::Offset<TrajCircularMove> TrajCircularMove::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrajCircularMoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrajCircularMove(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrajCircularMove> CreateTrajCircularMove(flatbuffers::FlatBufferBuilder &_fbb, const TrajCircularMoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrajCircularMoveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _end = _o->end ? _o->end.get() : 0;
  auto _center = _o->center ? _o->center.get() : 0;
  auto _normal = _o->normal ? _o->normal.get() : 0;
  auto _turn = _o->turn;
  auto _type = _o->type;
  auto _vel = _o->vel;
  auto _ini_maxvel = _o->ini_maxvel;
  auto _acc = _o->acc;
  auto _feed_mode = _o->feed_mode;
  return EMC::CreateTrajCircularMove(
      _fbb,
      _end,
      _center,
      _normal,
      _turn,
      _type,
      _vel,
      _ini_maxvel,
      _acc,
      _feed_mode);
}

inline TaskPlanOpenT *TaskPlanOpen::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::TaskPlanOpenT> _o = std::unique_ptr<EMC::TaskPlanOpenT>(new TaskPlanOpenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaskPlanOpen::UnPackTo(TaskPlanOpenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = file(); if (_e) _o->file = _e->str(); }
}

inline flatbuffers::Offset<TaskPlanOpen> TaskPlanOpen::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanOpenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaskPlanOpen(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TaskPlanOpen> CreateTaskPlanOpen(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanOpenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TaskPlanOpenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _file = _o->file.empty() ? 0 : _fbb.CreateString(_o->file);
  return EMC::CreateTaskPlanOpen(
      _fbb,
      _file);
}

inline TaskPlanExecuteT *TaskPlanExecute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::TaskPlanExecuteT> _o = std::unique_ptr<EMC::TaskPlanExecuteT>(new TaskPlanExecuteT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaskPlanExecute::UnPackTo(TaskPlanExecuteT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = command(); if (_e) _o->command = _e->str(); }
}

inline flatbuffers::Offset<TaskPlanExecute> TaskPlanExecute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanExecuteT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaskPlanExecute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TaskPlanExecute> CreateTaskPlanExecute(flatbuffers::FlatBufferBuilder &_fbb, const TaskPlanExecuteT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TaskPlanExecuteT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _command = _o->command.empty() ? 0 : _fbb.CreateString(_o->command);
  return EMC::CreateTaskPlanExecute(
      _fbb,
      _command);
}

inline ToolLoadToolTableT *ToolLoadToolTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::ToolLoadToolTableT> _o = std::unique_ptr<EMC::ToolLoadToolTableT>(new ToolLoadToolTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ToolLoadToolTable::UnPackTo(ToolLoadToolTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = file(); if (_e) _o->file = _e->str(); }
}

inline flatbuffers::Offset<ToolLoadToolTable> ToolLoadToolTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ToolLoadToolTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateToolLoadToolTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ToolLoadToolTable> CreateToolLoadToolTable(flatbuffers::FlatBufferBuilder &_fbb, const ToolLoadToolTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ToolLoadToolTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _file = _o->file.empty() ? 0 : _fbb.CreateString(_o->file);
  return EMC::CreateToolLoadToolTable(
      _fbb,
      _file);
}

inline CmdChannelMsgT *CmdChannelMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::CmdChannelMsgT> _o = std::unique_ptr<EMC::CmdChannelMsgT>(new CmdChannelMsgT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CmdChannelMsg::UnPackTo(CmdChannelMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = command_type(); _o->command.type = _e; }
  { auto _e = command(); if (_e) _o->command.value = EMC::CommandUnion::UnPack(_e, command_type(), _resolver); }
}

inline flatbuffers::Offset<CmdChannelMsg> CmdChannelMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCmdChannelMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CmdChannelMsg> CreateCmdChannelMsg(flatbuffers::FlatBufferBuilder &_fbb, const CmdChannelMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CmdChannelMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _command_type = _o->command.type;
  auto _command = _o->command.Pack(_fbb);
  return EMC::CreateCmdChannelMsg(
      _fbb,
      _command_type,
      _command);
}

inline DebugLevelT *DebugLevel::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::DebugLevelT> _o = std::unique_ptr<EMC::DebugLevelT>(new DebugLevelT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugLevel::UnPackTo(DebugLevelT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = debug_level(); _o->debug_level = _e; }
}

inline flatbuffers::Offset<DebugLevel> DebugLevel::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DebugLevelT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugLevel(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DebugLevel> CreateDebugLevel(flatbuffers::FlatBufferBuilder &_fbb, const DebugLevelT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DebugLevelT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _debug_level = _o->debug_level;
  return EMC::CreateDebugLevel(
      _fbb,
      _debug_level);
}

inline ResultT *Result::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EMC::ResultT> _o = std::unique_ptr<EMC::ResultT>(new ResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Result::UnPackTo(ResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; }
}

inline flatbuffers::Offset<Result> Result::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Result> CreateResult(flatbuffers::FlatBufferBuilder &_fbb, const ResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  return EMC::CreateResult(
      _fbb,
      _result);
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_set_debug: {
      return verifier.Verify<EMC::SetDebug>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_cmd: {
      return verifier.Verify<EMC::JogCmd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_backlash: {
      return verifier.Verify<EMC::JointSetBacklash>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_min_position_limit: {
      return verifier.Verify<EMC::JointSetMinPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_max_position_limit: {
      return verifier.Verify<EMC::JointSetMaxPositionLimit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_ferror: {
      return verifier.Verify<EMC::JointSetFerror>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_min_ferror: {
      return verifier.Verify<EMC::JointSetMinFerror>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_set_homing_params: {
      return verifier.Verify<EMC::JointSetHomingParams>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_home: {
      return verifier.Verify<EMC::JointHome>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_unhome: {
      return verifier.Verify<EMC::JointUnhome>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_halt: {
      return verifier.Verify<EMC::JointHalt>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_cont: {
      return verifier.Verify<EMC::JogCont>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_incr: {
      return verifier.Verify<EMC::JogIncr>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_abs: {
      return verifier.Verify<EMC::JogAbs>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_jog_stop: {
      return verifier.Verify<EMC::JogStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_override_limits: {
      return verifier.Verify<EMC::JointOverrideLimits>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_joint_load_comp: {
      auto ptr = reinterpret_cast<const EMC::JointLoadComp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_traj_set_mode: {
      return verifier.Verify<EMC::TrajSetMode>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_velocity: {
      return verifier.Verify<EMC::TrajSetVelocity>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tral_set_acceleration: {
      return verifier.Verify<EMC::TrajSetAcceleration>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_max_velocity: {
      return verifier.Verify<EMC::TrajSetMaxVelocity>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_scale: {
      return verifier.Verify<EMC::TrajSetScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_rapid_scale: {
      return verifier.Verify<EMC::TrajSetRapidScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_spindl_scale: {
      return verifier.Verify<EMC::TrajSetSpindleScale>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_fo_enable: {
      return verifier.Verify<EMC::TrajSetFOEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_so_enable: {
      return verifier.Verify<EMC::TrajSetSOEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_fh_enable: {
      return verifier.Verify<EMC::TrajSetFHEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_abort: {
      return verifier.Verify<EMC::TrajAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_pause: {
      return verifier.Verify<EMC::TrajPause>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_resume: {
      return verifier.Verify<EMC::TrajResume>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_delay: {
      return verifier.Verify<EMC::TrajDelay>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_linear_move: {
      return verifier.Verify<EMC::TrajLinearMove>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_circular_move: {
      auto ptr = reinterpret_cast<const EMC::TrajCircularMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_traj_set_term_cond: {
      return verifier.Verify<EMC::TrajSetTermCond>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_spindle_sync: {
      return verifier.Verify<EMC::TrajSetSpindleSync>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_offset: {
      return verifier.Verify<EMC::TrajSetOffset>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_g5x: {
      return verifier.Verify<EMC::TrajSetG5x>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_g92: {
      return verifier.Verify<EMC::TrajSetG92>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_rotation: {
      return verifier.Verify<EMC::TrajSetRotation>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_clear_probe_tripped_flag: {
      return verifier.Verify<EMC::TrajClearProbeTrippedFlag>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_set_teleop_enable: {
      return verifier.Verify<EMC::TrajSetTeleopEnable>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_probe: {
      return verifier.Verify<EMC::TrajProbe>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_traj_rigid_tap: {
      return verifier.Verify<EMC::TrajRigidTap>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_set_aout: {
      return verifier.Verify<EMC::MotionSetAOut>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_set_dout: {
      return verifier.Verify<EMC::MotionSetDOut>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_motion_adaptive: {
      return verifier.Verify<EMC::MotionAdaptive>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_abort: {
      return verifier.Verify<EMC::TaskAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_set_mode: {
      return verifier.Verify<EMC::TaskSetMode>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_set_state: {
      return verifier.Verify<EMC::TaskSetState>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_open: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOpen *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_task_plan_run: {
      return verifier.Verify<EMC::TaskPlanRun>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_execute: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanExecute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_task_plan_reverse: {
      return verifier.Verify<EMC::TaskPlanReverse>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_forward: {
      return verifier.Verify<EMC::TaskPlanForward>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_step: {
      return verifier.Verify<EMC::TaskPlanStep>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_resume: {
      return verifier.Verify<EMC::TaskPlanResume>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_end: {
      return verifier.Verify<EMC::TaskPlanEnd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_close: {
      return verifier.Verify<EMC::TaskPlanClose>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_init: {
      return verifier.Verify<EMC::TaskPlanInit>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_synch: {
      return verifier.Verify<EMC::TaskPlanSynch>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_set_optional_stop: {
      return verifier.Verify<EMC::TaskPlanSetOptionalStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_set_block_delete: {
      return verifier.Verify<EMC::TaskPlanSetBlockDelete>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_task_plan_optional_stop: {
      return verifier.Verify<EMC::TaskPlanOptionalStop>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_cmd: {
      return verifier.Verify<EMC::ToolCmd>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_halt: {
      return verifier.Verify<EMC::ToolHalt>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_abort: {
      return verifier.Verify<EMC::ToolAbort>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_prepare: {
      return verifier.Verify<EMC::ToolPrepare>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_load: {
      return verifier.Verify<EMC::ToolLoad>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_load_tool_table: {
      auto ptr = reinterpret_cast<const EMC::ToolLoadToolTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_tool_set_offset: {
      return verifier.Verify<EMC::ToolSetOffset>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_tool_set_number: {
      return verifier.Verify<EMC::ToolSetNumber>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_aux_input_wait: {
      return verifier.Verify<EMC::AuxInputWait>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_speed: {
      return verifier.Verify<EMC::SpindleSpeed>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_orient: {
      return verifier.Verify<EMC::SpindleOrient>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_wait_orient: {
      return verifier.Verify<EMC::SpindleWaitOrient>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_on: {
      return verifier.Verify<EMC::SpindleOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_off: {
      return verifier.Verify<EMC::SpindleOff>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_increase: {
      return verifier.Verify<EMC::SpindleIncrease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_decrease: {
      return verifier.Verify<EMC::SpindleDecrease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_constant: {
      return verifier.Verify<EMC::SpindleConstant>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_brake_release: {
      return verifier.Verify<EMC::SpindleBrakeRelease>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_spindle_brake_engage: {
      return verifier.Verify<EMC::SpindleBrakeEngage>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_mist_on: {
      return verifier.Verify<EMC::CoolantMistOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_mist_off: {
      return verifier.Verify<EMC::CoolantMistOff>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_flood_on: {
      return verifier.Verify<EMC::CoolantFloodOn>(static_cast<const uint8_t *>(obj), 0);
    }
    case Command_coolant_flood_off: {
      return verifier.Verify<EMC::CoolantFloodOff>(static_cast<const uint8_t *>(obj), 0);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

inline void *CommandUnion::UnPack(const void *obj, Command type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<const EMC::SetDebug *>(obj);
      return new EMC::SetDebug(*ptr);
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<const EMC::JogCmd *>(obj);
      return new EMC::JogCmd(*ptr);
    }
    case Command_joint_set_backlash: {
      auto ptr = reinterpret_cast<const EMC::JointSetBacklash *>(obj);
      return new EMC::JointSetBacklash(*ptr);
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinPositionLimit *>(obj);
      return new EMC::JointSetMinPositionLimit(*ptr);
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(obj);
      return new EMC::JointSetMaxPositionLimit(*ptr);
    }
    case Command_joint_set_ferror: {
      auto ptr = reinterpret_cast<const EMC::JointSetFerror *>(obj);
      return new EMC::JointSetFerror(*ptr);
    }
    case Command_joint_set_min_ferror: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinFerror *>(obj);
      return new EMC::JointSetMinFerror(*ptr);
    }
    case Command_joint_set_homing_params: {
      auto ptr = reinterpret_cast<const EMC::JointSetHomingParams *>(obj);
      return new EMC::JointSetHomingParams(*ptr);
    }
    case Command_joint_home: {
      auto ptr = reinterpret_cast<const EMC::JointHome *>(obj);
      return new EMC::JointHome(*ptr);
    }
    case Command_joint_unhome: {
      auto ptr = reinterpret_cast<const EMC::JointUnhome *>(obj);
      return new EMC::JointUnhome(*ptr);
    }
    case Command_joint_halt: {
      auto ptr = reinterpret_cast<const EMC::JointHalt *>(obj);
      return new EMC::JointHalt(*ptr);
    }
    case Command_jog_cont: {
      auto ptr = reinterpret_cast<const EMC::JogCont *>(obj);
      return new EMC::JogCont(*ptr);
    }
    case Command_jog_incr: {
      auto ptr = reinterpret_cast<const EMC::JogIncr *>(obj);
      return new EMC::JogIncr(*ptr);
    }
    case Command_jog_abs: {
      auto ptr = reinterpret_cast<const EMC::JogAbs *>(obj);
      return new EMC::JogAbs(*ptr);
    }
    case Command_jog_stop: {
      auto ptr = reinterpret_cast<const EMC::JogStop *>(obj);
      return new EMC::JogStop(*ptr);
    }
    case Command_joint_override_limits: {
      auto ptr = reinterpret_cast<const EMC::JointOverrideLimits *>(obj);
      return new EMC::JointOverrideLimits(*ptr);
    }
    case Command_joint_load_comp: {
      auto ptr = reinterpret_cast<const EMC::JointLoadComp *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_traj_set_mode: {
      auto ptr = reinterpret_cast<const EMC::TrajSetMode *>(obj);
      return new EMC::TrajSetMode(*ptr);
    }
    case Command_traj_set_velocity: {
      auto ptr = reinterpret_cast<const EMC::TrajSetVelocity *>(obj);
      return new EMC::TrajSetVelocity(*ptr);
    }
    case Command_tral_set_acceleration: {
      auto ptr = reinterpret_cast<const EMC::TrajSetAcceleration *>(obj);
      return new EMC::TrajSetAcceleration(*ptr);
    }
    case Command_traj_set_max_velocity: {
      auto ptr = reinterpret_cast<const EMC::TrajSetMaxVelocity *>(obj);
      return new EMC::TrajSetMaxVelocity(*ptr);
    }
    case Command_traj_set_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetScale *>(obj);
      return new EMC::TrajSetScale(*ptr);
    }
    case Command_traj_set_rapid_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetRapidScale *>(obj);
      return new EMC::TrajSetRapidScale(*ptr);
    }
    case Command_traj_set_spindl_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSpindleScale *>(obj);
      return new EMC::TrajSetSpindleScale(*ptr);
    }
    case Command_traj_set_fo_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetFOEnable *>(obj);
      return new EMC::TrajSetFOEnable(*ptr);
    }
    case Command_traj_set_so_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSOEnable *>(obj);
      return new EMC::TrajSetSOEnable(*ptr);
    }
    case Command_traj_set_fh_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetFHEnable *>(obj);
      return new EMC::TrajSetFHEnable(*ptr);
    }
    case Command_traj_abort: {
      auto ptr = reinterpret_cast<const EMC::TrajAbort *>(obj);
      return new EMC::TrajAbort(*ptr);
    }
    case Command_traj_pause: {
      auto ptr = reinterpret_cast<const EMC::TrajPause *>(obj);
      return new EMC::TrajPause(*ptr);
    }
    case Command_traj_resume: {
      auto ptr = reinterpret_cast<const EMC::TrajResume *>(obj);
      return new EMC::TrajResume(*ptr);
    }
    case Command_traj_delay: {
      auto ptr = reinterpret_cast<const EMC::TrajDelay *>(obj);
      return new EMC::TrajDelay(*ptr);
    }
    case Command_traj_linear_move: {
      auto ptr = reinterpret_cast<const EMC::TrajLinearMove *>(obj);
      return new EMC::TrajLinearMove(*ptr);
    }
    case Command_traj_circular_move: {
      auto ptr = reinterpret_cast<const EMC::TrajCircularMove *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_traj_set_term_cond: {
      auto ptr = reinterpret_cast<const EMC::TrajSetTermCond *>(obj);
      return new EMC::TrajSetTermCond(*ptr);
    }
    case Command_traj_set_spindle_sync: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSpindleSync *>(obj);
      return new EMC::TrajSetSpindleSync(*ptr);
    }
    case Command_traj_set_offset: {
      auto ptr = reinterpret_cast<const EMC::TrajSetOffset *>(obj);
      return new EMC::TrajSetOffset(*ptr);
    }
    case Command_traj_set_g5x: {
      auto ptr = reinterpret_cast<const EMC::TrajSetG5x *>(obj);
      return new EMC::TrajSetG5x(*ptr);
    }
    case Command_traj_set_g92: {
      auto ptr = reinterpret_cast<const EMC::TrajSetG92 *>(obj);
      return new EMC::TrajSetG92(*ptr);
    }
    case Command_traj_set_rotation: {
      auto ptr = reinterpret_cast<const EMC::TrajSetRotation *>(obj);
      return new EMC::TrajSetRotation(*ptr);
    }
    case Command_traj_clear_probe_tripped_flag: {
      auto ptr = reinterpret_cast<const EMC::TrajClearProbeTrippedFlag *>(obj);
      return new EMC::TrajClearProbeTrippedFlag(*ptr);
    }
    case Command_traj_set_teleop_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetTeleopEnable *>(obj);
      return new EMC::TrajSetTeleopEnable(*ptr);
    }
    case Command_traj_probe: {
      auto ptr = reinterpret_cast<const EMC::TrajProbe *>(obj);
      return new EMC::TrajProbe(*ptr);
    }
    case Command_traj_rigid_tap: {
      auto ptr = reinterpret_cast<const EMC::TrajRigidTap *>(obj);
      return new EMC::TrajRigidTap(*ptr);
    }
    case Command_motion_set_aout: {
      auto ptr = reinterpret_cast<const EMC::MotionSetAOut *>(obj);
      return new EMC::MotionSetAOut(*ptr);
    }
    case Command_motion_set_dout: {
      auto ptr = reinterpret_cast<const EMC::MotionSetDOut *>(obj);
      return new EMC::MotionSetDOut(*ptr);
    }
    case Command_motion_adaptive: {
      auto ptr = reinterpret_cast<const EMC::MotionAdaptive *>(obj);
      return new EMC::MotionAdaptive(*ptr);
    }
    case Command_task_abort: {
      auto ptr = reinterpret_cast<const EMC::TaskAbort *>(obj);
      return new EMC::TaskAbort(*ptr);
    }
    case Command_task_set_mode: {
      auto ptr = reinterpret_cast<const EMC::TaskSetMode *>(obj);
      return new EMC::TaskSetMode(*ptr);
    }
    case Command_task_set_state: {
      auto ptr = reinterpret_cast<const EMC::TaskSetState *>(obj);
      return new EMC::TaskSetState(*ptr);
    }
    case Command_task_plan_open: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOpen *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_task_plan_run: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanRun *>(obj);
      return new EMC::TaskPlanRun(*ptr);
    }
    case Command_task_plan_execute: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanExecute *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_task_plan_reverse: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanReverse *>(obj);
      return new EMC::TaskPlanReverse(*ptr);
    }
    case Command_task_plan_forward: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanForward *>(obj);
      return new EMC::TaskPlanForward(*ptr);
    }
    case Command_task_plan_step: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanStep *>(obj);
      return new EMC::TaskPlanStep(*ptr);
    }
    case Command_task_plan_resume: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanResume *>(obj);
      return new EMC::TaskPlanResume(*ptr);
    }
    case Command_task_plan_end: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanEnd *>(obj);
      return new EMC::TaskPlanEnd(*ptr);
    }
    case Command_task_plan_close: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanClose *>(obj);
      return new EMC::TaskPlanClose(*ptr);
    }
    case Command_task_plan_init: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanInit *>(obj);
      return new EMC::TaskPlanInit(*ptr);
    }
    case Command_task_plan_synch: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSynch *>(obj);
      return new EMC::TaskPlanSynch(*ptr);
    }
    case Command_task_plan_set_optional_stop: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSetOptionalStop *>(obj);
      return new EMC::TaskPlanSetOptionalStop(*ptr);
    }
    case Command_task_plan_set_block_delete: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSetBlockDelete *>(obj);
      return new EMC::TaskPlanSetBlockDelete(*ptr);
    }
    case Command_task_plan_optional_stop: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOptionalStop *>(obj);
      return new EMC::TaskPlanOptionalStop(*ptr);
    }
    case Command_tool_cmd: {
      auto ptr = reinterpret_cast<const EMC::ToolCmd *>(obj);
      return new EMC::ToolCmd(*ptr);
    }
    case Command_tool_halt: {
      auto ptr = reinterpret_cast<const EMC::ToolHalt *>(obj);
      return new EMC::ToolHalt(*ptr);
    }
    case Command_tool_abort: {
      auto ptr = reinterpret_cast<const EMC::ToolAbort *>(obj);
      return new EMC::ToolAbort(*ptr);
    }
    case Command_tool_prepare: {
      auto ptr = reinterpret_cast<const EMC::ToolPrepare *>(obj);
      return new EMC::ToolPrepare(*ptr);
    }
    case Command_tool_load: {
      auto ptr = reinterpret_cast<const EMC::ToolLoad *>(obj);
      return new EMC::ToolLoad(*ptr);
    }
    case Command_tool_load_tool_table: {
      auto ptr = reinterpret_cast<const EMC::ToolLoadToolTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case Command_tool_set_offset: {
      auto ptr = reinterpret_cast<const EMC::ToolSetOffset *>(obj);
      return new EMC::ToolSetOffset(*ptr);
    }
    case Command_tool_set_number: {
      auto ptr = reinterpret_cast<const EMC::ToolSetNumber *>(obj);
      return new EMC::ToolSetNumber(*ptr);
    }
    case Command_aux_input_wait: {
      auto ptr = reinterpret_cast<const EMC::AuxInputWait *>(obj);
      return new EMC::AuxInputWait(*ptr);
    }
    case Command_spindle_speed: {
      auto ptr = reinterpret_cast<const EMC::SpindleSpeed *>(obj);
      return new EMC::SpindleSpeed(*ptr);
    }
    case Command_spindle_orient: {
      auto ptr = reinterpret_cast<const EMC::SpindleOrient *>(obj);
      return new EMC::SpindleOrient(*ptr);
    }
    case Command_spindle_wait_orient: {
      auto ptr = reinterpret_cast<const EMC::SpindleWaitOrient *>(obj);
      return new EMC::SpindleWaitOrient(*ptr);
    }
    case Command_spindle_on: {
      auto ptr = reinterpret_cast<const EMC::SpindleOn *>(obj);
      return new EMC::SpindleOn(*ptr);
    }
    case Command_spindle_off: {
      auto ptr = reinterpret_cast<const EMC::SpindleOff *>(obj);
      return new EMC::SpindleOff(*ptr);
    }
    case Command_spindle_increase: {
      auto ptr = reinterpret_cast<const EMC::SpindleIncrease *>(obj);
      return new EMC::SpindleIncrease(*ptr);
    }
    case Command_spindle_decrease: {
      auto ptr = reinterpret_cast<const EMC::SpindleDecrease *>(obj);
      return new EMC::SpindleDecrease(*ptr);
    }
    case Command_spindle_constant: {
      auto ptr = reinterpret_cast<const EMC::SpindleConstant *>(obj);
      return new EMC::SpindleConstant(*ptr);
    }
    case Command_spindle_brake_release: {
      auto ptr = reinterpret_cast<const EMC::SpindleBrakeRelease *>(obj);
      return new EMC::SpindleBrakeRelease(*ptr);
    }
    case Command_spindle_brake_engage: {
      auto ptr = reinterpret_cast<const EMC::SpindleBrakeEngage *>(obj);
      return new EMC::SpindleBrakeEngage(*ptr);
    }
    case Command_coolant_mist_on: {
      auto ptr = reinterpret_cast<const EMC::CoolantMistOn *>(obj);
      return new EMC::CoolantMistOn(*ptr);
    }
    case Command_coolant_mist_off: {
      auto ptr = reinterpret_cast<const EMC::CoolantMistOff *>(obj);
      return new EMC::CoolantMistOff(*ptr);
    }
    case Command_coolant_flood_on: {
      auto ptr = reinterpret_cast<const EMC::CoolantFloodOn *>(obj);
      return new EMC::CoolantFloodOn(*ptr);
    }
    case Command_coolant_flood_off: {
      auto ptr = reinterpret_cast<const EMC::CoolantFloodOff *>(obj);
      return new EMC::CoolantFloodOff(*ptr);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> CommandUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<const EMC::SetDebug *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<const EMC::JogCmd *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_backlash: {
      auto ptr = reinterpret_cast<const EMC::JointSetBacklash *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinPositionLimit *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<const EMC::JointSetMaxPositionLimit *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_ferror: {
      auto ptr = reinterpret_cast<const EMC::JointSetFerror *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_min_ferror: {
      auto ptr = reinterpret_cast<const EMC::JointSetMinFerror *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_set_homing_params: {
      auto ptr = reinterpret_cast<const EMC::JointSetHomingParams *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_home: {
      auto ptr = reinterpret_cast<const EMC::JointHome *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_unhome: {
      auto ptr = reinterpret_cast<const EMC::JointUnhome *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_halt: {
      auto ptr = reinterpret_cast<const EMC::JointHalt *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_cont: {
      auto ptr = reinterpret_cast<const EMC::JogCont *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_incr: {
      auto ptr = reinterpret_cast<const EMC::JogIncr *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_abs: {
      auto ptr = reinterpret_cast<const EMC::JogAbs *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_jog_stop: {
      auto ptr = reinterpret_cast<const EMC::JogStop *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_override_limits: {
      auto ptr = reinterpret_cast<const EMC::JointOverrideLimits *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_joint_load_comp: {
      auto ptr = reinterpret_cast<const EMC::JointLoadCompT *>(value);
      return CreateJointLoadComp(_fbb, ptr, _rehasher).Union();
    }
    case Command_traj_set_mode: {
      auto ptr = reinterpret_cast<const EMC::TrajSetMode *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_velocity: {
      auto ptr = reinterpret_cast<const EMC::TrajSetVelocity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tral_set_acceleration: {
      auto ptr = reinterpret_cast<const EMC::TrajSetAcceleration *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_max_velocity: {
      auto ptr = reinterpret_cast<const EMC::TrajSetMaxVelocity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetScale *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_rapid_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetRapidScale *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_spindl_scale: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSpindleScale *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_fo_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetFOEnable *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_so_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSOEnable *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_fh_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetFHEnable *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_abort: {
      auto ptr = reinterpret_cast<const EMC::TrajAbort *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_pause: {
      auto ptr = reinterpret_cast<const EMC::TrajPause *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_resume: {
      auto ptr = reinterpret_cast<const EMC::TrajResume *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_delay: {
      auto ptr = reinterpret_cast<const EMC::TrajDelay *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_linear_move: {
      auto ptr = reinterpret_cast<const EMC::TrajLinearMove *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_circular_move: {
      auto ptr = reinterpret_cast<const EMC::TrajCircularMoveT *>(value);
      return CreateTrajCircularMove(_fbb, ptr, _rehasher).Union();
    }
    case Command_traj_set_term_cond: {
      auto ptr = reinterpret_cast<const EMC::TrajSetTermCond *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_spindle_sync: {
      auto ptr = reinterpret_cast<const EMC::TrajSetSpindleSync *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_offset: {
      auto ptr = reinterpret_cast<const EMC::TrajSetOffset *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_g5x: {
      auto ptr = reinterpret_cast<const EMC::TrajSetG5x *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_g92: {
      auto ptr = reinterpret_cast<const EMC::TrajSetG92 *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_rotation: {
      auto ptr = reinterpret_cast<const EMC::TrajSetRotation *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_clear_probe_tripped_flag: {
      auto ptr = reinterpret_cast<const EMC::TrajClearProbeTrippedFlag *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_set_teleop_enable: {
      auto ptr = reinterpret_cast<const EMC::TrajSetTeleopEnable *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_probe: {
      auto ptr = reinterpret_cast<const EMC::TrajProbe *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_traj_rigid_tap: {
      auto ptr = reinterpret_cast<const EMC::TrajRigidTap *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_motion_set_aout: {
      auto ptr = reinterpret_cast<const EMC::MotionSetAOut *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_motion_set_dout: {
      auto ptr = reinterpret_cast<const EMC::MotionSetDOut *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_motion_adaptive: {
      auto ptr = reinterpret_cast<const EMC::MotionAdaptive *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_abort: {
      auto ptr = reinterpret_cast<const EMC::TaskAbort *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_set_mode: {
      auto ptr = reinterpret_cast<const EMC::TaskSetMode *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_set_state: {
      auto ptr = reinterpret_cast<const EMC::TaskSetState *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_open: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOpenT *>(value);
      return CreateTaskPlanOpen(_fbb, ptr, _rehasher).Union();
    }
    case Command_task_plan_run: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanRun *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_execute: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanExecuteT *>(value);
      return CreateTaskPlanExecute(_fbb, ptr, _rehasher).Union();
    }
    case Command_task_plan_reverse: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanReverse *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_forward: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanForward *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_step: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanStep *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_resume: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanResume *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_end: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanEnd *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_close: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanClose *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_init: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanInit *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_synch: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSynch *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_set_optional_stop: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSetOptionalStop *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_set_block_delete: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanSetBlockDelete *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_task_plan_optional_stop: {
      auto ptr = reinterpret_cast<const EMC::TaskPlanOptionalStop *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_cmd: {
      auto ptr = reinterpret_cast<const EMC::ToolCmd *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_halt: {
      auto ptr = reinterpret_cast<const EMC::ToolHalt *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_abort: {
      auto ptr = reinterpret_cast<const EMC::ToolAbort *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_prepare: {
      auto ptr = reinterpret_cast<const EMC::ToolPrepare *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_load: {
      auto ptr = reinterpret_cast<const EMC::ToolLoad *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_load_tool_table: {
      auto ptr = reinterpret_cast<const EMC::ToolLoadToolTableT *>(value);
      return CreateToolLoadToolTable(_fbb, ptr, _rehasher).Union();
    }
    case Command_tool_set_offset: {
      auto ptr = reinterpret_cast<const EMC::ToolSetOffset *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_tool_set_number: {
      auto ptr = reinterpret_cast<const EMC::ToolSetNumber *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_aux_input_wait: {
      auto ptr = reinterpret_cast<const EMC::AuxInputWait *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_speed: {
      auto ptr = reinterpret_cast<const EMC::SpindleSpeed *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_orient: {
      auto ptr = reinterpret_cast<const EMC::SpindleOrient *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_wait_orient: {
      auto ptr = reinterpret_cast<const EMC::SpindleWaitOrient *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_on: {
      auto ptr = reinterpret_cast<const EMC::SpindleOn *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_off: {
      auto ptr = reinterpret_cast<const EMC::SpindleOff *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_increase: {
      auto ptr = reinterpret_cast<const EMC::SpindleIncrease *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_decrease: {
      auto ptr = reinterpret_cast<const EMC::SpindleDecrease *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_constant: {
      auto ptr = reinterpret_cast<const EMC::SpindleConstant *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_brake_release: {
      auto ptr = reinterpret_cast<const EMC::SpindleBrakeRelease *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_spindle_brake_engage: {
      auto ptr = reinterpret_cast<const EMC::SpindleBrakeEngage *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_coolant_mist_on: {
      auto ptr = reinterpret_cast<const EMC::CoolantMistOn *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_coolant_mist_off: {
      auto ptr = reinterpret_cast<const EMC::CoolantMistOff *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_coolant_flood_on: {
      auto ptr = reinterpret_cast<const EMC::CoolantFloodOn *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case Command_coolant_flood_off: {
      auto ptr = reinterpret_cast<const EMC::CoolantFloodOff *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    default: return 0;
  }
}

inline CommandUnion::CommandUnion(const CommandUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Command_set_debug: {
      value = new EMC::SetDebug(*reinterpret_cast<EMC::SetDebug *>(u.value));
      break;
    }
    case Command_jog_cmd: {
      value = new EMC::JogCmd(*reinterpret_cast<EMC::JogCmd *>(u.value));
      break;
    }
    case Command_joint_set_backlash: {
      value = new EMC::JointSetBacklash(*reinterpret_cast<EMC::JointSetBacklash *>(u.value));
      break;
    }
    case Command_joint_set_min_position_limit: {
      value = new EMC::JointSetMinPositionLimit(*reinterpret_cast<EMC::JointSetMinPositionLimit *>(u.value));
      break;
    }
    case Command_joint_set_max_position_limit: {
      value = new EMC::JointSetMaxPositionLimit(*reinterpret_cast<EMC::JointSetMaxPositionLimit *>(u.value));
      break;
    }
    case Command_joint_set_ferror: {
      value = new EMC::JointSetFerror(*reinterpret_cast<EMC::JointSetFerror *>(u.value));
      break;
    }
    case Command_joint_set_min_ferror: {
      value = new EMC::JointSetMinFerror(*reinterpret_cast<EMC::JointSetMinFerror *>(u.value));
      break;
    }
    case Command_joint_set_homing_params: {
      value = new EMC::JointSetHomingParams(*reinterpret_cast<EMC::JointSetHomingParams *>(u.value));
      break;
    }
    case Command_joint_home: {
      value = new EMC::JointHome(*reinterpret_cast<EMC::JointHome *>(u.value));
      break;
    }
    case Command_joint_unhome: {
      value = new EMC::JointUnhome(*reinterpret_cast<EMC::JointUnhome *>(u.value));
      break;
    }
    case Command_joint_halt: {
      value = new EMC::JointHalt(*reinterpret_cast<EMC::JointHalt *>(u.value));
      break;
    }
    case Command_jog_cont: {
      value = new EMC::JogCont(*reinterpret_cast<EMC::JogCont *>(u.value));
      break;
    }
    case Command_jog_incr: {
      value = new EMC::JogIncr(*reinterpret_cast<EMC::JogIncr *>(u.value));
      break;
    }
    case Command_jog_abs: {
      value = new EMC::JogAbs(*reinterpret_cast<EMC::JogAbs *>(u.value));
      break;
    }
    case Command_jog_stop: {
      value = new EMC::JogStop(*reinterpret_cast<EMC::JogStop *>(u.value));
      break;
    }
    case Command_joint_override_limits: {
      value = new EMC::JointOverrideLimits(*reinterpret_cast<EMC::JointOverrideLimits *>(u.value));
      break;
    }
    case Command_joint_load_comp: {
      value = new EMC::JointLoadCompT(*reinterpret_cast<EMC::JointLoadCompT *>(u.value));
      break;
    }
    case Command_traj_set_mode: {
      value = new EMC::TrajSetMode(*reinterpret_cast<EMC::TrajSetMode *>(u.value));
      break;
    }
    case Command_traj_set_velocity: {
      value = new EMC::TrajSetVelocity(*reinterpret_cast<EMC::TrajSetVelocity *>(u.value));
      break;
    }
    case Command_tral_set_acceleration: {
      value = new EMC::TrajSetAcceleration(*reinterpret_cast<EMC::TrajSetAcceleration *>(u.value));
      break;
    }
    case Command_traj_set_max_velocity: {
      value = new EMC::TrajSetMaxVelocity(*reinterpret_cast<EMC::TrajSetMaxVelocity *>(u.value));
      break;
    }
    case Command_traj_set_scale: {
      value = new EMC::TrajSetScale(*reinterpret_cast<EMC::TrajSetScale *>(u.value));
      break;
    }
    case Command_traj_set_rapid_scale: {
      value = new EMC::TrajSetRapidScale(*reinterpret_cast<EMC::TrajSetRapidScale *>(u.value));
      break;
    }
    case Command_traj_set_spindl_scale: {
      value = new EMC::TrajSetSpindleScale(*reinterpret_cast<EMC::TrajSetSpindleScale *>(u.value));
      break;
    }
    case Command_traj_set_fo_enable: {
      value = new EMC::TrajSetFOEnable(*reinterpret_cast<EMC::TrajSetFOEnable *>(u.value));
      break;
    }
    case Command_traj_set_so_enable: {
      value = new EMC::TrajSetSOEnable(*reinterpret_cast<EMC::TrajSetSOEnable *>(u.value));
      break;
    }
    case Command_traj_set_fh_enable: {
      value = new EMC::TrajSetFHEnable(*reinterpret_cast<EMC::TrajSetFHEnable *>(u.value));
      break;
    }
    case Command_traj_abort: {
      value = new EMC::TrajAbort(*reinterpret_cast<EMC::TrajAbort *>(u.value));
      break;
    }
    case Command_traj_pause: {
      value = new EMC::TrajPause(*reinterpret_cast<EMC::TrajPause *>(u.value));
      break;
    }
    case Command_traj_resume: {
      value = new EMC::TrajResume(*reinterpret_cast<EMC::TrajResume *>(u.value));
      break;
    }
    case Command_traj_delay: {
      value = new EMC::TrajDelay(*reinterpret_cast<EMC::TrajDelay *>(u.value));
      break;
    }
    case Command_traj_linear_move: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajLinearMove not copyable.
      break;
    }
    case Command_traj_circular_move: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajCircularMoveT not copyable.
      break;
    }
    case Command_traj_set_term_cond: {
      value = new EMC::TrajSetTermCond(*reinterpret_cast<EMC::TrajSetTermCond *>(u.value));
      break;
    }
    case Command_traj_set_spindle_sync: {
      value = new EMC::TrajSetSpindleSync(*reinterpret_cast<EMC::TrajSetSpindleSync *>(u.value));
      break;
    }
    case Command_traj_set_offset: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajSetOffset not copyable.
      break;
    }
    case Command_traj_set_g5x: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajSetG5x not copyable.
      break;
    }
    case Command_traj_set_g92: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajSetG92 not copyable.
      break;
    }
    case Command_traj_set_rotation: {
      value = new EMC::TrajSetRotation(*reinterpret_cast<EMC::TrajSetRotation *>(u.value));
      break;
    }
    case Command_traj_clear_probe_tripped_flag: {
      value = new EMC::TrajClearProbeTrippedFlag(*reinterpret_cast<EMC::TrajClearProbeTrippedFlag *>(u.value));
      break;
    }
    case Command_traj_set_teleop_enable: {
      value = new EMC::TrajSetTeleopEnable(*reinterpret_cast<EMC::TrajSetTeleopEnable *>(u.value));
      break;
    }
    case Command_traj_probe: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajProbe not copyable.
      break;
    }
    case Command_traj_rigid_tap: {
      FLATBUFFERS_ASSERT(false);  // EMC::TrajRigidTap not copyable.
      break;
    }
    case Command_motion_set_aout: {
      value = new EMC::MotionSetAOut(*reinterpret_cast<EMC::MotionSetAOut *>(u.value));
      break;
    }
    case Command_motion_set_dout: {
      value = new EMC::MotionSetDOut(*reinterpret_cast<EMC::MotionSetDOut *>(u.value));
      break;
    }
    case Command_motion_adaptive: {
      value = new EMC::MotionAdaptive(*reinterpret_cast<EMC::MotionAdaptive *>(u.value));
      break;
    }
    case Command_task_abort: {
      value = new EMC::TaskAbort(*reinterpret_cast<EMC::TaskAbort *>(u.value));
      break;
    }
    case Command_task_set_mode: {
      value = new EMC::TaskSetMode(*reinterpret_cast<EMC::TaskSetMode *>(u.value));
      break;
    }
    case Command_task_set_state: {
      value = new EMC::TaskSetState(*reinterpret_cast<EMC::TaskSetState *>(u.value));
      break;
    }
    case Command_task_plan_open: {
      value = new EMC::TaskPlanOpenT(*reinterpret_cast<EMC::TaskPlanOpenT *>(u.value));
      break;
    }
    case Command_task_plan_run: {
      value = new EMC::TaskPlanRun(*reinterpret_cast<EMC::TaskPlanRun *>(u.value));
      break;
    }
    case Command_task_plan_execute: {
      value = new EMC::TaskPlanExecuteT(*reinterpret_cast<EMC::TaskPlanExecuteT *>(u.value));
      break;
    }
    case Command_task_plan_reverse: {
      value = new EMC::TaskPlanReverse(*reinterpret_cast<EMC::TaskPlanReverse *>(u.value));
      break;
    }
    case Command_task_plan_forward: {
      value = new EMC::TaskPlanForward(*reinterpret_cast<EMC::TaskPlanForward *>(u.value));
      break;
    }
    case Command_task_plan_step: {
      value = new EMC::TaskPlanStep(*reinterpret_cast<EMC::TaskPlanStep *>(u.value));
      break;
    }
    case Command_task_plan_resume: {
      value = new EMC::TaskPlanResume(*reinterpret_cast<EMC::TaskPlanResume *>(u.value));
      break;
    }
    case Command_task_plan_end: {
      value = new EMC::TaskPlanEnd(*reinterpret_cast<EMC::TaskPlanEnd *>(u.value));
      break;
    }
    case Command_task_plan_close: {
      value = new EMC::TaskPlanClose(*reinterpret_cast<EMC::TaskPlanClose *>(u.value));
      break;
    }
    case Command_task_plan_init: {
      value = new EMC::TaskPlanInit(*reinterpret_cast<EMC::TaskPlanInit *>(u.value));
      break;
    }
    case Command_task_plan_synch: {
      value = new EMC::TaskPlanSynch(*reinterpret_cast<EMC::TaskPlanSynch *>(u.value));
      break;
    }
    case Command_task_plan_set_optional_stop: {
      value = new EMC::TaskPlanSetOptionalStop(*reinterpret_cast<EMC::TaskPlanSetOptionalStop *>(u.value));
      break;
    }
    case Command_task_plan_set_block_delete: {
      value = new EMC::TaskPlanSetBlockDelete(*reinterpret_cast<EMC::TaskPlanSetBlockDelete *>(u.value));
      break;
    }
    case Command_task_plan_optional_stop: {
      value = new EMC::TaskPlanOptionalStop(*reinterpret_cast<EMC::TaskPlanOptionalStop *>(u.value));
      break;
    }
    case Command_tool_cmd: {
      value = new EMC::ToolCmd(*reinterpret_cast<EMC::ToolCmd *>(u.value));
      break;
    }
    case Command_tool_halt: {
      value = new EMC::ToolHalt(*reinterpret_cast<EMC::ToolHalt *>(u.value));
      break;
    }
    case Command_tool_abort: {
      value = new EMC::ToolAbort(*reinterpret_cast<EMC::ToolAbort *>(u.value));
      break;
    }
    case Command_tool_prepare: {
      value = new EMC::ToolPrepare(*reinterpret_cast<EMC::ToolPrepare *>(u.value));
      break;
    }
    case Command_tool_load: {
      value = new EMC::ToolLoad(*reinterpret_cast<EMC::ToolLoad *>(u.value));
      break;
    }
    case Command_tool_load_tool_table: {
      value = new EMC::ToolLoadToolTableT(*reinterpret_cast<EMC::ToolLoadToolTableT *>(u.value));
      break;
    }
    case Command_tool_set_offset: {
      FLATBUFFERS_ASSERT(false);  // EMC::ToolSetOffset not copyable.
      break;
    }
    case Command_tool_set_number: {
      value = new EMC::ToolSetNumber(*reinterpret_cast<EMC::ToolSetNumber *>(u.value));
      break;
    }
    case Command_aux_input_wait: {
      value = new EMC::AuxInputWait(*reinterpret_cast<EMC::AuxInputWait *>(u.value));
      break;
    }
    case Command_spindle_speed: {
      value = new EMC::SpindleSpeed(*reinterpret_cast<EMC::SpindleSpeed *>(u.value));
      break;
    }
    case Command_spindle_orient: {
      value = new EMC::SpindleOrient(*reinterpret_cast<EMC::SpindleOrient *>(u.value));
      break;
    }
    case Command_spindle_wait_orient: {
      value = new EMC::SpindleWaitOrient(*reinterpret_cast<EMC::SpindleWaitOrient *>(u.value));
      break;
    }
    case Command_spindle_on: {
      value = new EMC::SpindleOn(*reinterpret_cast<EMC::SpindleOn *>(u.value));
      break;
    }
    case Command_spindle_off: {
      value = new EMC::SpindleOff(*reinterpret_cast<EMC::SpindleOff *>(u.value));
      break;
    }
    case Command_spindle_increase: {
      value = new EMC::SpindleIncrease(*reinterpret_cast<EMC::SpindleIncrease *>(u.value));
      break;
    }
    case Command_spindle_decrease: {
      value = new EMC::SpindleDecrease(*reinterpret_cast<EMC::SpindleDecrease *>(u.value));
      break;
    }
    case Command_spindle_constant: {
      value = new EMC::SpindleConstant(*reinterpret_cast<EMC::SpindleConstant *>(u.value));
      break;
    }
    case Command_spindle_brake_release: {
      value = new EMC::SpindleBrakeRelease(*reinterpret_cast<EMC::SpindleBrakeRelease *>(u.value));
      break;
    }
    case Command_spindle_brake_engage: {
      value = new EMC::SpindleBrakeEngage(*reinterpret_cast<EMC::SpindleBrakeEngage *>(u.value));
      break;
    }
    case Command_coolant_mist_on: {
      value = new EMC::CoolantMistOn(*reinterpret_cast<EMC::CoolantMistOn *>(u.value));
      break;
    }
    case Command_coolant_mist_off: {
      value = new EMC::CoolantMistOff(*reinterpret_cast<EMC::CoolantMistOff *>(u.value));
      break;
    }
    case Command_coolant_flood_on: {
      value = new EMC::CoolantFloodOn(*reinterpret_cast<EMC::CoolantFloodOn *>(u.value));
      break;
    }
    case Command_coolant_flood_off: {
      value = new EMC::CoolantFloodOff(*reinterpret_cast<EMC::CoolantFloodOff *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void CommandUnion::Reset() {
  switch (type) {
    case Command_set_debug: {
      auto ptr = reinterpret_cast<EMC::SetDebug *>(value);
      delete ptr;
      break;
    }
    case Command_jog_cmd: {
      auto ptr = reinterpret_cast<EMC::JogCmd *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_backlash: {
      auto ptr = reinterpret_cast<EMC::JointSetBacklash *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_min_position_limit: {
      auto ptr = reinterpret_cast<EMC::JointSetMinPositionLimit *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_max_position_limit: {
      auto ptr = reinterpret_cast<EMC::JointSetMaxPositionLimit *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_ferror: {
      auto ptr = reinterpret_cast<EMC::JointSetFerror *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_min_ferror: {
      auto ptr = reinterpret_cast<EMC::JointSetMinFerror *>(value);
      delete ptr;
      break;
    }
    case Command_joint_set_homing_params: {
      auto ptr = reinterpret_cast<EMC::JointSetHomingParams *>(value);
      delete ptr;
      break;
    }
    case Command_joint_home: {
      auto ptr = reinterpret_cast<EMC::JointHome *>(value);
      delete ptr;
      break;
    }
    case Command_joint_unhome: {
      auto ptr = reinterpret_cast<EMC::JointUnhome *>(value);
      delete ptr;
      break;
    }
    case Command_joint_halt: {
      auto ptr = reinterpret_cast<EMC::JointHalt *>(value);
      delete ptr;
      break;
    }
    case Command_jog_cont: {
      auto ptr = reinterpret_cast<EMC::JogCont *>(value);
      delete ptr;
      break;
    }
    case Command_jog_incr: {
      auto ptr = reinterpret_cast<EMC::JogIncr *>(value);
      delete ptr;
      break;
    }
    case Command_jog_abs: {
      auto ptr = reinterpret_cast<EMC::JogAbs *>(value);
      delete ptr;
      break;
    }
    case Command_jog_stop: {
      auto ptr = reinterpret_cast<EMC::JogStop *>(value);
      delete ptr;
      break;
    }
    case Command_joint_override_limits: {
      auto ptr = reinterpret_cast<EMC::JointOverrideLimits *>(value);
      delete ptr;
      break;
    }
    case Command_joint_load_comp: {
      auto ptr = reinterpret_cast<EMC::JointLoadCompT *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_mode: {
      auto ptr = reinterpret_cast<EMC::TrajSetMode *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_velocity: {
      auto ptr = reinterpret_cast<EMC::TrajSetVelocity *>(value);
      delete ptr;
      break;
    }
    case Command_tral_set_acceleration: {
      auto ptr = reinterpret_cast<EMC::TrajSetAcceleration *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_max_velocity: {
      auto ptr = reinterpret_cast<EMC::TrajSetMaxVelocity *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_scale: {
      auto ptr = reinterpret_cast<EMC::TrajSetScale *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_rapid_scale: {
      auto ptr = reinterpret_cast<EMC::TrajSetRapidScale *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_spindl_scale: {
      auto ptr = reinterpret_cast<EMC::TrajSetSpindleScale *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_fo_enable: {
      auto ptr = reinterpret_cast<EMC::TrajSetFOEnable *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_so_enable: {
      auto ptr = reinterpret_cast<EMC::TrajSetSOEnable *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_fh_enable: {
      auto ptr = reinterpret_cast<EMC::TrajSetFHEnable *>(value);
      delete ptr;
      break;
    }
    case Command_traj_abort: {
      auto ptr = reinterpret_cast<EMC::TrajAbort *>(value);
      delete ptr;
      break;
    }
    case Command_traj_pause: {
      auto ptr = reinterpret_cast<EMC::TrajPause *>(value);
      delete ptr;
      break;
    }
    case Command_traj_resume: {
      auto ptr = reinterpret_cast<EMC::TrajResume *>(value);
      delete ptr;
      break;
    }
    case Command_traj_delay: {
      auto ptr = reinterpret_cast<EMC::TrajDelay *>(value);
      delete ptr;
      break;
    }
    case Command_traj_linear_move: {
      auto ptr = reinterpret_cast<EMC::TrajLinearMove *>(value);
      delete ptr;
      break;
    }
    case Command_traj_circular_move: {
      auto ptr = reinterpret_cast<EMC::TrajCircularMoveT *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_term_cond: {
      auto ptr = reinterpret_cast<EMC::TrajSetTermCond *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_spindle_sync: {
      auto ptr = reinterpret_cast<EMC::TrajSetSpindleSync *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_offset: {
      auto ptr = reinterpret_cast<EMC::TrajSetOffset *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_g5x: {
      auto ptr = reinterpret_cast<EMC::TrajSetG5x *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_g92: {
      auto ptr = reinterpret_cast<EMC::TrajSetG92 *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_rotation: {
      auto ptr = reinterpret_cast<EMC::TrajSetRotation *>(value);
      delete ptr;
      break;
    }
    case Command_traj_clear_probe_tripped_flag: {
      auto ptr = reinterpret_cast<EMC::TrajClearProbeTrippedFlag *>(value);
      delete ptr;
      break;
    }
    case Command_traj_set_teleop_enable: {
      auto ptr = reinterpret_cast<EMC::TrajSetTeleopEnable *>(value);
      delete ptr;
      break;
    }
    case Command_traj_probe: {
      auto ptr = reinterpret_cast<EMC::TrajProbe *>(value);
      delete ptr;
      break;
    }
    case Command_traj_rigid_tap: {
      auto ptr = reinterpret_cast<EMC::TrajRigidTap *>(value);
      delete ptr;
      break;
    }
    case Command_motion_set_aout: {
      auto ptr = reinterpret_cast<EMC::MotionSetAOut *>(value);
      delete ptr;
      break;
    }
    case Command_motion_set_dout: {
      auto ptr = reinterpret_cast<EMC::MotionSetDOut *>(value);
      delete ptr;
      break;
    }
    case Command_motion_adaptive: {
      auto ptr = reinterpret_cast<EMC::MotionAdaptive *>(value);
      delete ptr;
      break;
    }
    case Command_task_abort: {
      auto ptr = reinterpret_cast<EMC::TaskAbort *>(value);
      delete ptr;
      break;
    }
    case Command_task_set_mode: {
      auto ptr = reinterpret_cast<EMC::TaskSetMode *>(value);
      delete ptr;
      break;
    }
    case Command_task_set_state: {
      auto ptr = reinterpret_cast<EMC::TaskSetState *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_open: {
      auto ptr = reinterpret_cast<EMC::TaskPlanOpenT *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_run: {
      auto ptr = reinterpret_cast<EMC::TaskPlanRun *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_execute: {
      auto ptr = reinterpret_cast<EMC::TaskPlanExecuteT *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_reverse: {
      auto ptr = reinterpret_cast<EMC::TaskPlanReverse *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_forward: {
      auto ptr = reinterpret_cast<EMC::TaskPlanForward *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_step: {
      auto ptr = reinterpret_cast<EMC::TaskPlanStep *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_resume: {
      auto ptr = reinterpret_cast<EMC::TaskPlanResume *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_end: {
      auto ptr = reinterpret_cast<EMC::TaskPlanEnd *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_close: {
      auto ptr = reinterpret_cast<EMC::TaskPlanClose *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_init: {
      auto ptr = reinterpret_cast<EMC::TaskPlanInit *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_synch: {
      auto ptr = reinterpret_cast<EMC::TaskPlanSynch *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_set_optional_stop: {
      auto ptr = reinterpret_cast<EMC::TaskPlanSetOptionalStop *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_set_block_delete: {
      auto ptr = reinterpret_cast<EMC::TaskPlanSetBlockDelete *>(value);
      delete ptr;
      break;
    }
    case Command_task_plan_optional_stop: {
      auto ptr = reinterpret_cast<EMC::TaskPlanOptionalStop *>(value);
      delete ptr;
      break;
    }
    case Command_tool_cmd: {
      auto ptr = reinterpret_cast<EMC::ToolCmd *>(value);
      delete ptr;
      break;
    }
    case Command_tool_halt: {
      auto ptr = reinterpret_cast<EMC::ToolHalt *>(value);
      delete ptr;
      break;
    }
    case Command_tool_abort: {
      auto ptr = reinterpret_cast<EMC::ToolAbort *>(value);
      delete ptr;
      break;
    }
    case Command_tool_prepare: {
      auto ptr = reinterpret_cast<EMC::ToolPrepare *>(value);
      delete ptr;
      break;
    }
    case Command_tool_load: {
      auto ptr = reinterpret_cast<EMC::ToolLoad *>(value);
      delete ptr;
      break;
    }
    case Command_tool_load_tool_table: {
      auto ptr = reinterpret_cast<EMC::ToolLoadToolTableT *>(value);
      delete ptr;
      break;
    }
    case Command_tool_set_offset: {
      auto ptr = reinterpret_cast<EMC::ToolSetOffset *>(value);
      delete ptr;
      break;
    }
    case Command_tool_set_number: {
      auto ptr = reinterpret_cast<EMC::ToolSetNumber *>(value);
      delete ptr;
      break;
    }
    case Command_aux_input_wait: {
      auto ptr = reinterpret_cast<EMC::AuxInputWait *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_speed: {
      auto ptr = reinterpret_cast<EMC::SpindleSpeed *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_orient: {
      auto ptr = reinterpret_cast<EMC::SpindleOrient *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_wait_orient: {
      auto ptr = reinterpret_cast<EMC::SpindleWaitOrient *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_on: {
      auto ptr = reinterpret_cast<EMC::SpindleOn *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_off: {
      auto ptr = reinterpret_cast<EMC::SpindleOff *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_increase: {
      auto ptr = reinterpret_cast<EMC::SpindleIncrease *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_decrease: {
      auto ptr = reinterpret_cast<EMC::SpindleDecrease *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_constant: {
      auto ptr = reinterpret_cast<EMC::SpindleConstant *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_brake_release: {
      auto ptr = reinterpret_cast<EMC::SpindleBrakeRelease *>(value);
      delete ptr;
      break;
    }
    case Command_spindle_brake_engage: {
      auto ptr = reinterpret_cast<EMC::SpindleBrakeEngage *>(value);
      delete ptr;
      break;
    }
    case Command_coolant_mist_on: {
      auto ptr = reinterpret_cast<EMC::CoolantMistOn *>(value);
      delete ptr;
      break;
    }
    case Command_coolant_mist_off: {
      auto ptr = reinterpret_cast<EMC::CoolantMistOff *>(value);
      delete ptr;
      break;
    }
    case Command_coolant_flood_on: {
      auto ptr = reinterpret_cast<EMC::CoolantFloodOn *>(value);
      delete ptr;
      break;
    }
    case Command_coolant_flood_off: {
      auto ptr = reinterpret_cast<EMC::CoolantFloodOff *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Command_NONE;
}

inline const EMC::CmdChannelMsg *GetCmdChannelMsg(const void *buf) {
  return flatbuffers::GetRoot<EMC::CmdChannelMsg>(buf);
}

inline const EMC::CmdChannelMsg *GetSizePrefixedCmdChannelMsg(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<EMC::CmdChannelMsg>(buf);
}

inline bool VerifyCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline bool VerifySizePrefixedCmdChannelMsgBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EMC::CmdChannelMsg>(nullptr);
}

inline void FinishCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCmdChannelMsgBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<EMC::CmdChannelMsg> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<EMC::CmdChannelMsgT> UnPackCmdChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::CmdChannelMsgT>(GetCmdChannelMsg(buf)->UnPack(res));
}

inline std::unique_ptr<EMC::CmdChannelMsgT> UnPackSizePrefixedCmdChannelMsg(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<EMC::CmdChannelMsgT>(GetSizePrefixedCmdChannelMsg(buf)->UnPack(res));
}

}  // namespace EMC

#endif  // FLATBUFFERS_GENERATED_EMCCMD_EMC_H_
